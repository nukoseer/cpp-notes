<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-12-02 Mon 15:44 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>C++ Notes</title>
<meta name="author" content="nukoseer" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/search.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/search.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<style> pre.src { background-color: black; color: white; font-size: 14px; }</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">C++ Notes</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org5fcae37">Fundemental Differences Between C and C++</a>
<ul>
<li><a href="#orga1fc8f7">Syntax Differences</a>
<ul>
<li><a href="#orgd93e3a7">Implicit int</a></li>
<li><a href="#org6e5e270">Missing return statement in functions with non-void return type</a></li>
<li><a href="#orgab5f342">Implicit/default function declaration</a></li>
<li><a href="#orgfffa6a3">Declaration of functions without parameter</a></li>
<li><a href="#org4d122e5">Nameless parameters in function definitions</a></li>
<li><a href="#orge2159ad">Scope of for-statement</a></li>
</ul>
</li>
<li><a href="#org4a78720">Differences About Types and Type Conversions</a>
<ul>
<li><a href="#orgbc048ca">Logic data type (boolean)</a></li>
<li><a href="#org04097b5">User defined types</a></li>
<li><a href="#org6fe92b9">Empty structs</a></li>
<li><a href="#org7639379">Implicit conversion from arithmetic types to pointer types</a></li>
<li><a href="#org0f97733">Implicit conversion between different pointer types.</a></li>
<li><a href="#orgfd6042e">Implicit conversion from <code>void*</code> to <code>T*</code></a></li>
<li><a href="#org54c861a">Underlying enumeration type</a></li>
<li><a href="#orge741635">Implicit conversion from arithmetic types to enumeration types</a></li>
<li><a href="#org8030c64">Implicit conversion between different enumeration types</a></li>
<li><a href="#orga8b6161">Implicit conversion from enumeration types to arithmetic types.</a></li>
<li><a href="#orgfddcc77">Character literals</a></li>
<li><a href="#orgf00794e">String literals</a></li>
</ul>
</li>
<li><a href="#orgc6d437c">Differences About const Keyword</a>
<ul>
<li><a href="#org0ab305e">Initialization of const objects</a></li>
<li><a href="#orga1c3e64">Const expressions</a></li>
<li><a href="#org8d15c74">Global const objects and linkage</a></li>
<li><a href="#org863a45d">Implicit conversion from <code>const T*</code> to <code>T*</code></a></li>
</ul>
</li>
<li><a href="#org0446ecb">Differences About Value Categories</a>
<ul>
<li><a href="#org16f7f9c">Primary value categories</a></li>
<li><a href="#org0c51469">Prefix increment/decrement operator</a></li>
<li><a href="#org2aaf86b">Assignment operator</a></li>
<li><a href="#orgcc332de">Comma operator</a></li>
<li><a href="#orgbed6536">Ternary operator</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb415b13">C++ Topics</a>
<ul>
<li><a href="#orgebe69b7">Initialization</a>
<ul>
<li><a href="#org6801840">Default initialization</a></li>
<li><a href="#orgba11023">Zero initialization</a></li>
<li><a href="#orgc26323e">Copy initialization</a></li>
<li><a href="#orgd71aeec">Direct initialization</a></li>
<li><a href="#org344d22d">Direct-list / brace initialization (uniform initialization)</a></li>
<li><a href="#org3b49a89">Value initialization</a></li>
</ul>
</li>
<li><a href="#org4431e97">nullptr</a></li>
<li><a href="#org0c131c1">Reference Semantics</a>
<ul>
<li><a href="#org8d6ed5c">L-value references</a></li>
<li><a href="#org39e4188">L-value references and const semantics</a></li>
<li><a href="#org4075d4b">Differences between pointers and L-value references</a></li>
<li><a href="#org264e0d2">R-value references</a></li>
</ul>
</li>
<li><a href="#org1bbac5f">Type Deduction</a>
<ul>
<li><a href="#orgb94ae63">auto type deduction</a></li>
<li><a href="#orgf912347">decltype type deduction</a></li>
</ul>
</li>
<li><a href="#orgde594a7">Default Function Arguments</a></li>
<li><a href="#orgd123df8">Scoped enum / Enum class</a>
<ul>
<li><a href="#org9c0ccbc">Disadvantages of the traditional enum type</a></li>
<li><a href="#org85c7450">Advantages of the scoped enum type</a></li>
</ul>
</li>
<li><a href="#org68dbf70">Type Cast Operators</a>
<ul>
<li><a href="#org69878d0">Why C-style type cast is not enough?</a></li>
</ul>
</li>
<li><a href="#orgf8b7760">Function Overloading</a>
<ul>
<li><a href="#org41a5942">Function overload resolution</a></li>
</ul>
</li>
<li><a href="#org6b1ea2d">Name Mangling</a></li>
<li><a href="#orgfa343fc">One Definition Rule (ODR)</a></li>
<li><a href="#orgb1677a5">Inline functions</a></li>
<li><a href="#org3588f28">Inline variables</a></li>
<li><a href="#org2faa43b">constexpr</a>
<ul>
<li><a href="#org77ce377">constexpr variables</a></li>
<li><a href="#org60f4ea5">constexpr functions</a></li>
</ul>
</li>
<li><a href="#org561f0c2">Classes</a>
<ul>
<li><a href="#orgf5b92e0">Class definition</a></li>
<li><a href="#org1a46a1e">Access control</a></li>
<li><a href="#org7ebbd02">Non-static data members</a></li>
<li><a href="#org98a13af">Non-static member functions</a></li>
<li><a href="#org5140c92">Class scope</a></li>
<li><a href="#org4feddca">this keyword</a></li>
<li><a href="#orgb0a6a7f">Const member functions</a></li>
<li><a href="#orgcca7afb">mutable keyword</a></li>
<li><a href="#org876ba8b">Constructor and destructor of classes</a></li>
<li><a href="#orga3e8862">Special member functions</a></li>
<li><a href="#org156f984">Move Semantics</a></li>
<li><a href="#org48dd706">Default member initializer / In-class initializer</a></li>
<li><a href="#org43710c7">Delegating Constructor</a></li>
<li><a href="#orgde3dbb3">Temporary Objects</a></li>
<li><a href="#org8a6c8eb">Reference qualifiers</a></li>
<li><a href="#org7de554d">Conversion constructor</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org5fcae37" class="outline-2">
<h2 id="org5fcae37">Fundemental Differences Between C and C++</h2>
<div class="outline-text-2" id="text-org5fcae37">
<p>
Main purpose of this section is to point out the differences between C and C++. It isn't about how code should or should not be written in C or C++. It is only about validity of the code.
</p>
</div>
<div id="outline-container-orga1fc8f7" class="outline-3">
<h3 id="orga1fc8f7">Syntax Differences</h3>
<div class="outline-text-3" id="text-orga1fc8f7">
</div>
<div id="outline-container-orgd93e3a7" class="outline-4">
<h4 id="orgd93e3a7">Implicit int</h4>
<div class="outline-text-4" id="text-orgd93e3a7">
<p>
If a function does not have a return type:
</p>
<ul class="org-ul">
<li>In C, it is allowed and compilers assume it returns <code>int</code>. It is also allowed in function declarations.</li>
<li>In C++, it is syntax error.</li>
</ul>
<p>
This code is valid in C and invalid in C++:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #b6a0ff;">return</span> x + <span style="color: #00bcff;">1</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org6e5e270" class="outline-4">
<h4 id="org6e5e270">Missing return statement in functions with non-void return type</h4>
<div class="outline-text-4" id="text-org6e5e270">
<p>
If a function has return type but does not return anything:
</p>
<ul class="org-ul">
<li>In C, it is allowed. Compilers can show a warning but they don't have to.</li>
<li>In C++, it is syntax error.</li>
</ul>
<p>
This code is valid in C and invalid in C++:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #ffffff;">{}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgab5f342" class="outline-4">
<h4 id="orgab5f342">Implicit/default function declaration</h4>
<div class="outline-text-4" id="text-orgab5f342">
<p>
If name lookup fails for a function:
</p>
<ul class="org-ul">
<li>In C, compilers will assume it is an external function with the default declaration: <code>int func();</code></li>
<li>In C++, it is syntax error.</li>
</ul>
<p>
This code will compile in C and compiler will assume <code>bar()</code> function has <code>int bar();</code> declaration:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #feacd0;">bar</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfffa6a3" class="outline-4">
<h4 id="orgfffa6a3">Declaration of functions without parameter</h4>
<div class="outline-text-4" id="text-orgfffa6a3">
<p>
There are different rules for C and C++.
</p>
<div class="org-src-container">
<pre class="src src-C++">    <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
    <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">bar</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">void</span><span style="color: #ffffff;">)</span>;
</pre>
</div>
<ul class="org-ul">
<li>In C, these 2 function declarations have different meaning.
<ul class="org-ul">
<li><code>int foo();</code> means, we don't have any information about parameters so we can pass what ever we want.</li>
<li><code>int bar(void);</code> means, function does not take any parameters.</li>
</ul></li>
<li>In C++, both of the declarations have the same meaning. Functions do not take any parameters.</li>
</ul>
<p>
According to the declarations above, this code is valid in C. Invalid in C++, because <code>int foo();</code> does not take any parameters.
</p>
<div class="org-src-container">
<pre class="src src-C++">    <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">1</span>, <span style="color: #00bcff;">2</span><span style="color: #ffffff;">)</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-org4d122e5" class="outline-4">
<h4 id="org4d122e5">Nameless parameters in function definitions</h4>
<div class="outline-text-4" id="text-org4d122e5">
<p>
This is about function definitions not declarations.
</p>
<ul class="org-ul">
<li>In C, it is not allowed. (Since C20, it is also allowed in C.)</li>
<li>In C++, it is allowed.</li>
</ul>
<p>
This code is invalid for C (before C20) and valid for C++:
</p>
<div class="org-src-container">
<pre class="src src-C++">    <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span> <span style="color: #ffffff;">{}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orge2159ad" class="outline-4">
<h4 id="orge2159ad">Scope of for-statement</h4>
<div class="outline-text-4" id="text-orge2159ad">
<ul class="org-ul">
<li>In C, inside of the for loop has a different block scope than for-statement itself.</li>
<li>In C++, inside of the for loop and for-statement itself are in same block scope.</li>
</ul>
<p>
Because of this difference, name shadowing inside a for loop is valid in C, but invalid in C++:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #feacd0;">for </span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">i</span> = <span style="color: #00bcff;">0</span>; i &lt; <span style="color: #00bcff;">10</span>; ++i<span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">i</span> = <span style="color: #00bcff;">99</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>
<p>
We can say above code looks like this for C compiler:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #feacd0;">for </span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">i</span> = <span style="color: #00bcff;">0</span>; i &lt; <span style="color: #00bcff;">10</span>; ++i<span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">i</span> = <span style="color: #00bcff;">99</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>
<p>
<i>Note: For C and C++, name shadowing is only valid between different scopes.</i>
</p>
</div>
</div>
</div>
<div id="outline-container-org4a78720" class="outline-3">
<h3 id="org4a78720">Differences About Types and Type Conversions</h3>
<div class="outline-text-3" id="text-org4a78720">
</div>
<div id="outline-container-orgbc048ca" class="outline-4">
<h4 id="orgbc048ca">Logic data type (boolean)</h4>
<div class="outline-text-4" id="text-orgbc048ca">
<p>
In C:
</p>
<ul class="org-ul">
<li><code>int</code> is used instead of logic data type.</li>
<li><code>_Bool</code> type is added in C99, but it is not widely used.</li>
<li>C doesn't have <code>false</code>, <code>true</code> constants. <code>stdbool.h</code> defines macros for them.</li>
</ul>

<p>
In C++:
</p>
<ul class="org-ul">
<li><code>bool</code> type, <code>false</code> and <code>true</code> constants are build-in to the language. No need to include anything.</li>
<li>Implicit type conversion from arithmetic types and pointer types to <code>bool</code> is allowed.</li>
<li>Implicit type conversion from <code>bool</code> to arithmetic types is allowed.</li>
</ul>
<p>
These are valid in C++:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Implicit conversion from arithmetic types to bool</span>
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">45</span>;
   <span style="color: #6ae4b9;">bool</span> <span style="color: #ffffff;">b1</span> = x;

   <span style="color: #6ae4b9;">double</span> <span style="color: #ffffff;">y</span> = <span style="color: #00bcff;">33.11</span>;
   <span style="color: #6ae4b9;">bool</span> <span style="color: #ffffff;">b2</span> = y;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Implicit conversion from pointer types to bool</span>
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">z</span> = <span style="color: #00bcff;">100</span>;
   <span style="color: #6ae4b9;">int</span>* <span style="color: #ffffff;">p</span> = &amp;z;
   <span style="color: #6ae4b9;">bool</span> <span style="color: #ffffff;">b3</span> = p;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Implicit conversion from bool to arithmetic types</span>
   <span style="color: #6ae4b9;">bool</span> <span style="color: #ffffff;">b4</span> = <span style="color: #00bcff;">true</span>;
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">t</span> = b4;
</pre>
</div>

<p>
But, this is invalid:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">No implicit conversion from bool to pointer types</span>
   <span style="color: #6ae4b9;">bool</span> <span style="color: #ffffff;">b5</span> = <span style="color: #00bcff;">false</span>;
   <span style="color: #6ae4b9;">int</span>* <span style="color: #ffffff;">ptr</span> = b5;
</pre>
</div>
</div>
</div>
<div id="outline-container-org04097b5" class="outline-4">
<h4 id="org04097b5">User defined types</h4>
<div class="outline-text-4" id="text-org04097b5">
<ul class="org-ul">
<li>In C, <code>struct</code>, <code>enum</code> and <code>union</code> tags don't represent type itself. A keyword (<code>struct</code>, <code>enum</code> or <code>union</code>) must be used before a tag name to represent a type. A <code>typedef</code> declaration can be used too.</li>
<li>In C++, tag names directly represent type names.</li>
</ul>
<p>
Here are some examples:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">struct</span> <span style="color: #6ae4b9;">Data</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">a</span>, <span style="color: #ffffff;">b</span>, <span style="color: #ffffff;">c</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid in C. Valid in C++. There is no need to use struct keyword or typedef declaration in C++.</span>
   <span style="color: #6ae4b9;">Data</span> <span style="color: #ffffff;">data0</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid in C and C++.</span>
   <span style="color: #b6a0ff;">struct</span> <span style="color: #6ae4b9;">Data</span> <span style="color: #ffffff;">data1</span>;

   <span style="color: #b6a0ff;">typedef</span> <span style="color: #b6a0ff;">struct</span> <span style="color: #6ae4b9;">Example</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">a</span>, <span style="color: #ffffff;">b</span>, <span style="color: #ffffff;">c</span>;
   <span style="color: #ffffff;">}</span> <span style="color: #6ae4b9;">Example</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid in C and C++.</span>
   <span style="color: #6ae4b9;">Example</span> <span style="color: #ffffff;">example0</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-org6fe92b9" class="outline-4">
<h4 id="org6fe92b9">Empty structs</h4>
<div class="outline-text-4" id="text-org6fe92b9">
<ul class="org-ul">
<li>In C, empty structs are invalid.</li>
<li>In C++, empty structs are valid.</li>
</ul>
<p>
An example:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">struct</span> <span style="color: #6ae4b9;">Data</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-org7639379" class="outline-4">
<h4 id="org7639379">Implicit conversion from arithmetic types to pointer types</h4>
<div class="outline-text-4" id="text-org7639379">
<ul class="org-ul">
<li>In C, implicit conversion from arithmetic types to pointer types is allowed. Compilers might show a warning.</li>
<li>In C++, there is no implicit conversion from arithmetic types to pointer types.</li>
</ul>
<p>
This is valid in C and invalid in C++:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">20</span>;
   <span style="color: #6ae4b9;">int</span>* <span style="color: #ffffff;">p</span> = x;
</pre>
</div>
</div>
</div>
<div id="outline-container-org0f97733" class="outline-4">
<h4 id="org0f97733">Implicit conversion between different pointer types.</h4>
<div class="outline-text-4" id="text-org0f97733">
<ul class="org-ul">
<li>In C, implicit conversion between different pointer is allowed. Compilers might show a warning.</li>
<li>In C++, there is no implicit conversion between different pointer types.</li>
</ul>
<p>
This is valid in C and invalid in C++:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">double</span> <span style="color: #ffffff;">d</span> = <span style="color: #00bcff;">33.11</span>;
   <span style="color: #6ae4b9;">char</span>* <span style="color: #ffffff;">ptr</span> = &amp;d;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfd6042e" class="outline-4">
<h4 id="orgfd6042e">Implicit conversion from <code>void*</code> to <code>T*</code></h4>
<div class="outline-text-4" id="text-orgfd6042e">
<ul class="org-ul">
<li>In C, implicit conversion from <code>void*</code> to <code>T*</code> is allowed.</li>
<li>In C++, implicit conversion from <code>void*</code> to <code>T*</code> is not allowed.</li>
</ul>
<p>
This code is valid in C but invalid in C++:
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span style="color: #6ae4b9;">int</span>* <span style="color: #ffffff;">p</span> = <span style="color: #feacd0;">malloc</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">1000</span> * <span style="color: #feacd0;">sizeof</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">))</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-org54c861a" class="outline-4">
<h4 id="org54c861a">Underlying enumeration type</h4>
<div class="outline-text-4" id="text-org54c861a">
<ul class="org-ul">
<li>In C, underlying enumeration type has to be <code>int</code>.</li>
<li>In C++, it does not have to be <code>int</code> and can be specified with special syntax.</li>
</ul>
</div>
</div>
<div id="outline-container-orge741635" class="outline-4">
<h4 id="orge741635">Implicit conversion from arithmetic types to enumeration types</h4>
<div class="outline-text-4" id="text-orge741635">
<ul class="org-ul">
<li>In C, it is allowed.</li>
<li>In C++, it is not.</li>
</ul>
<p>
This code is valid in C but invalid in C++:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">enum</span> <span style="color: #6ae4b9;">Color</span> <span style="color: #ffffff;">{</span> <span style="color: #ffffff;">Red</span>, <span style="color: #ffffff;">Green</span>, <span style="color: #ffffff;">Blue</span> <span style="color: #ffffff;">}</span>;
   <span style="color: #b6a0ff;">enum</span> <span style="color: #6ae4b9;">Color</span> <span style="color: #ffffff;">color</span>;
   color = <span style="color: #00bcff;">3</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-org8030c64" class="outline-4">
<h4 id="org8030c64">Implicit conversion between different enumeration types</h4>
<div class="outline-text-4" id="text-org8030c64">
<ul class="org-ul">
<li>In C, it is allowed.</li>
<li>In C++, it is not.</li>
</ul>
<p>
This code is valid in C but invalid in C++:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">enum</span> <span style="color: #6ae4b9;">Color</span> <span style="color: #ffffff;">{</span> <span style="color: #ffffff;">Red</span>, <span style="color: #ffffff;">Green</span>, <span style="color: #ffffff;">Blue</span> <span style="color: #ffffff;">}</span>;
   <span style="color: #b6a0ff;">enum</span> <span style="color: #6ae4b9;">Count</span> <span style="color: #ffffff;">{</span> <span style="color: #ffffff;">Zero</span>, <span style="color: #ffffff;">One</span>, <span style="color: #ffffff;">Two</span> <span style="color: #ffffff;">}</span>;
   <span style="color: #b6a0ff;">enum</span> <span style="color: #6ae4b9;">Color</span> <span style="color: #ffffff;">color</span> = Red;
   <span style="color: #b6a0ff;">enum</span> <span style="color: #6ae4b9;">Count</span> <span style="color: #ffffff;">count</span> = Zero;
   color = count;
</pre>
</div>
</div>
</div>
<div id="outline-container-orga8b6161" class="outline-4">
<h4 id="orga8b6161">Implicit conversion from enumeration types to arithmetic types.</h4>
<div class="outline-text-4" id="text-orga8b6161">
<ul class="org-ul">
<li>In C, it is allowed.</li>
<li>In C++, it is also allowed. Scoped enums can be used to prevent this.</li>
</ul>
<p>
This code is valid in C and C++:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">enum</span> <span style="color: #6ae4b9;">Color</span> <span style="color: #ffffff;">{</span> <span style="color: #ffffff;">Red</span>, <span style="color: #ffffff;">Green</span>, <span style="color: #ffffff;">Blue</span> <span style="color: #ffffff;">}</span>;
   <span style="color: #b6a0ff;">enum</span> <span style="color: #6ae4b9;">Color</span> <span style="color: #ffffff;">color</span> = Red;
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = color;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfddcc77" class="outline-4">
<h4 id="orgfddcc77">Character literals</h4>
<div class="outline-text-4" id="text-orgfddcc77">
<ul class="org-ul">
<li>In C, character literals are <code>int</code>.</li>
<li>In C++, character literals are <code>char</code>.</li>
</ul>
<p>
This code prints 4 in C and 1 in C++:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #feacd0;">printf</span><span style="color: #ffffff;">(</span><span style="color: #79a8ff;">"%zu\n"</span>, <span style="color: #feacd0;">sizeof</span><span style="color: #ffffff;">(</span><span style="color: #79a8ff;">'A'</span><span style="color: #ffffff;">))</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf00794e" class="outline-4">
<h4 id="orgf00794e">String literals</h4>
<div class="outline-text-4" id="text-orgf00794e">
<ul class="org-ul">
<li>In C, the type of string literals is <code>char[n]</code>. When string literals are used in an expression they are converted to address of the first element (array decay - array to pointer conversion). The type after array decay is <code>char*</code>.</li>
<li>In C++, the type of string literals is <code>const char[n]</code>. Array decay also applies to C++ but the type after array decay is <code>const char*</code>.</li>
</ul>
<p>
This string literal is <code>char[8]</code> in C and <code>const char[8]</code> in C++:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #79a8ff;">"example"</span>
</pre>
</div>
<p>
This is valid in C but invalid in C++:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">In C++, it is decayed to const char* and there is no implicit conversion from const T* to T*.</span>
   <span style="color: #6ae4b9;">char</span>* <span style="color: #ffffff;">s</span> = <span style="color: #79a8ff;">"example"</span>;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc6d437c" class="outline-3">
<h3 id="orgc6d437c">Differences About const Keyword</h3>
<div class="outline-text-3" id="text-orgc6d437c">
</div>
<div id="outline-container-org0ab305e" class="outline-4">
<h4 id="org0ab305e">Initialization of const objects</h4>
<div class="outline-text-4" id="text-org0ab305e">
<ul class="org-ul">
<li>In C, <code>const</code> objects don't have to be initialized.</li>
<li>In C++, <code>const</code> objects have to be initialized.</li>
</ul>
<p>
This is code is valid in C and invalid in C++:
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span>;
</pre>
</div>
<p>
Might be a bit tricky to understand at first but this is also valid in C++:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is a pointer to const int. Object/variable itself is not const here it just points to const int</span>
   <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span>* <span style="color: #ffffff;">ptr</span>;
</pre>
</div>
<p>
But this is invalid:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is a const pointer to int. Object/variable itself is const</span>
   <span style="color: #6ae4b9;">int</span>* <span style="color: #b6a0ff;">const</span> <span style="color: #ffffff;">ptr</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orga1c3e64" class="outline-4">
<h4 id="orga1c3e64">Const expressions</h4>
<div class="outline-text-4" id="text-orga1c3e64">
<ul class="org-ul">
<li>In C, expressions generated by const variables are not counted as const expressions.</li>
<li>In C++, they count as const expressions.</li>
</ul>
<p>
This is invalid in C (assuming no VLA) but valid in C++:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">arr</span><span style="color: #ffffff;">[</span>x<span style="color: #ffffff;">]</span> = <span style="color: #ffffff;">{</span> <span style="color: #00bcff;">0</span> <span style="color: #ffffff;">}</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-org8d15c74" class="outline-4">
<h4 id="org8d15c74">Global const objects and linkage</h4>
<div class="outline-text-4" id="text-org8d15c74">
<ul class="org-ul">
<li>In C, global const objects are in external linkage.</li>
<li>In C++, global const objects are in internal linkage like <code>static</code> objects.</li>
</ul>
<p>
<code>x</code> is in external linkage in C and internal linkage in C++:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">In global scope</span>
   <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-org863a45d" class="outline-4">
<h4 id="org863a45d">Implicit conversion from <code>const T*</code> to <code>T*</code></h4>
<div class="outline-text-4" id="text-org863a45d">
<ul class="org-ul">
<li>In C, implicit conversion from <code>const T*</code> to <code>T*</code> is allowed. Compilers might show a warning.</li>
<li>In C++, there is no implicit conversion from <code>const T*</code> to <code>T*</code>.</li>
</ul>
<p>
This is valid in C and invalid in C++:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
   <span style="color: #6ae4b9;">int</span>* <span style="color: #ffffff;">p</span> = &amp;x;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org0446ecb" class="outline-3">
<h3 id="org0446ecb">Differences About Value Categories</h3>
<div class="outline-text-3" id="text-org0446ecb">
</div>
<div id="outline-container-org16f7f9c" class="outline-4">
<h4 id="org16f7f9c">Primary value categories</h4>
<div class="outline-text-4" id="text-org16f7f9c">
<ul class="org-ul">
<li>In C, there are 2 primary value categories.
<ul class="org-ul">
<li>L-value</li>
<li>R-value</li>
</ul></li>
<li>In C++, there are 3 primary value categories.
<ul class="org-ul">
<li>L-value</li>
<li>PR-value (pure R-value)</li>
<li>X-value (expired value)</li>
</ul></li>
</ul>
<p>
The combination of the <code>PR-value</code> and <code>X-value</code> categories is called the <code>R-value</code> category. (<code>PR-value</code> &cup; <code>X-value</code> = <code>R-value</code>). When we say an expression is <code>R-value</code> it means it may be an <code>PR-value</code> or <code>X-value</code> in C++.
</p>

<p>
The combination of the <code>L-value</code> and <code>X-value</code> categories is called the <code>GL-value</code> category. (<code>L-value</code> &cup; <code>X-value</code> = <code>GL-value</code>). When we say an expression is <code>GL-value</code> it means it may be an <code>L-value</code> or <code>X-value</code> in C++.
</p>

<p>
The <code>GL-value</code> and <code>R-value</code> categories are not <code>primary value categories</code>. They are called <code>combined value categories</code>.
</p>
</div>
</div>
<div id="outline-container-org0c51469" class="outline-4">
<h4 id="org0c51469">Prefix increment/decrement operator</h4>
<div class="outline-text-4" id="text-org0c51469">
<ul class="org-ul">
<li>In C, expressions generated by prefix increment/decrement operator are R-value expressions.</li>
<li>In C++, they are L-value expressions.</li>
</ul>
<p>
This code is valid in C++ and invalid in C:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">These are invalid in C, because R-value expressions cannot be an operand of the address(&amp;) operator.</span>
   &amp;++x;
   &amp;--x;
</pre>
</div>
</div>
</div>
<div id="outline-container-org2aaf86b" class="outline-4">
<h4 id="org2aaf86b">Assignment operator</h4>
<div class="outline-text-4" id="text-org2aaf86b">
<ul class="org-ul">
<li>In C, expressions generated by assignment operator are R-value expressions.</li>
<li>In C++, they are L-value expressions.</li>
</ul>
<p>
This code is valid in C++ and invalid in C:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
   &amp;<span style="color: #ffffff;">(</span>x = <span style="color: #00bcff;">5</span><span style="color: #ffffff;">)</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcc332de" class="outline-4">
<h4 id="orgcc332de">Comma operator</h4>
<div class="outline-text-4" id="text-orgcc332de">
<ul class="org-ul">
<li>In C, expressions generated by comma operator are R-value expressions.</li>
<li>In C++, they can be L-value or R-value expressions.</li>
</ul>
<p>
This code is valid in C++ and invalid in C:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span> = <span style="color: #00bcff;">20</span>;
   <span style="color: #ffffff;">(</span>x, y<span style="color: #ffffff;">)</span> = <span style="color: #00bcff;">30</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">y = 30;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbed6536" class="outline-4">
<h4 id="orgbed6536">Ternary operator</h4>
<div class="outline-text-4" id="text-orgbed6536">
<ul class="org-ul">
<li>In C, expressions generated by ternary operator are R-value expressions.</li>
<li>In C++, they can be L-value or R-value expressions.</li>
</ul>
<p>
This code is valid in C++ and invalid in C:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span> = <span style="color: #00bcff;">20</span>;
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">z</span> = <span style="color: #00bcff;">30</span>;
   <span style="color: #ffffff;">(</span>x == <span style="color: #00bcff;">10</span> ? y : z<span style="color: #ffffff;">)</span> = <span style="color: #00bcff;">40</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">y = 40;</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb415b13" class="outline-2">
<h2 id="orgb415b13">C++ Topics</h2>
<div class="outline-text-2" id="text-orgb415b13">
</div>
<div id="outline-container-orgebe69b7" class="outline-3">
<h3 id="orgebe69b7">Initialization</h3>
<div class="outline-text-3" id="text-orgebe69b7">
<p>
There are very different ways to initialize objects in C++.
</p>
</div>
<div id="outline-container-org6801840" class="outline-4">
<h4 id="org6801840">Default initialization</h4>
<div class="outline-text-4" id="text-org6801840">
<p>
Default initialized objects are created with a garbage value.
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Default initialization.</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgba11023" class="outline-4">
<h4 id="orgba11023">Zero initialization</h4>
<div class="outline-text-4" id="text-orgba11023">
<p>
Compilers zero initialize objects in the global scope. <code>zero initialization</code> is not a way to initialize objects it is more like a compiler process.
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Global scope</span>
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span>;  <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">x = 0;</span>
   <span style="color: #6ae4b9;">bool</span> <span style="color: #ffffff;">b</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">b = false;</span>
   <span style="color: #6ae4b9;">int</span>* <span style="color: #ffffff;">p</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">p = nullptr;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc26323e" class="outline-4">
<h4 id="orgc26323e">Copy initialization</h4>
<div class="outline-text-4" id="text-orgc26323e">
<p>
If objects are initialized like in the C language, it is called <code>copy initialization</code>.
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Copy initialization.</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd71aeec" class="outline-4">
<h4 id="orgd71aeec">Direct initialization</h4>
<div class="outline-text-4" id="text-orgd71aeec">
<p>
If objects are initialized by using paranthesis, it is called <code>direct initialization</code>.
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">x</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">98</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Direct initialization.</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org344d22d" class="outline-4">
<h4 id="org344d22d">Direct-list / brace initialization (uniform initialization)</h4>
<div class="outline-text-4" id="text-org344d22d">
<p>
If objects are initialized by using braces, it is called <code>direct-list initialization</code>. <code>direct-list/brace initialization</code> is added to the language to have a uniform way to initialize objects. This is why it is also called <code>uniform initialization</code>. It can be used to initialize any object.
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">{</span> <span style="color: #00bcff;">10</span> <span style="color: #ffffff;">}</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Direct-list initialization.</span>
</pre>
</div>

<p>
Unlike other initialization methods, if an implicit narrowing conversion occurs during <code>direct-list initialization</code>, it is a syntax error.
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">double</span> <span style="color: #ffffff;">dval</span> = <span style="color: #00bcff;">5.6</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Implicit narrowing conversion does not cause any error but compilers might show a warning.</span>
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">i1</span> = dval;
   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">i2</span><span style="color: #ffffff;">(</span>dval<span style="color: #ffffff;">)</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid. Implicit narrowing conversion causes a syntax error. Explicit cast is needed.</span>
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">i3</span><span style="color: #ffffff;">{</span>dval<span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
In C++, there are such declarations that can be interpreted as both <code>object instantiation</code> and <code>function declaration</code> at the same time. In such cases, <code>function declaration</code> has the priority. This is called <code>most vexing parse</code> and sometimes it leads to problems.
Example:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">struct</span> <span style="color: #6ae4b9;">A</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #b6a0ff;">struct</span> <span style="color: #6ae4b9;">B</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #feacd0;">B</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">A</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Here, we wanted to create a bx object from class B type by calling its constructor with a temporary object with class A type.</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C++ understands this as a function declaration. It is a function named bx and it has a return type of class B,</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">and takes a function pointer as a parameter. Sigh..</span>
   <span style="color: #6ae4b9;">B</span> <span style="color: #feacd0;">bx</span><span style="color: #ffffff;">(</span><span style="color: #feacd0;">A</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">))</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This can be prevented by using direct-list initialization.</span>
   <span style="color: #6ae4b9;">B</span> <span style="color: #ffffff;">by</span><span style="color: #ffffff;">{</span><span style="color: #feacd0;">A</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)}</span>;
   <span style="color: #6ae4b9;">B</span> <span style="color: #feacd0;">bz</span><span style="color: #ffffff;">(</span>A<span style="color: #ffffff;">{})</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-org3b49a89" class="outline-4">
<h4 id="org3b49a89">Value initialization</h4>
<div class="outline-text-4" id="text-org3b49a89">
<p>
If objects are initialized by using braces but inside of the braces are empty, it is called <code>value initialization</code>. Value initialized objects are first initialized to zero, if any additional initialization steps are required, this is done after <code>zero initialization</code>.
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">{}</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Value initialization.</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org4431e97" class="outline-3">
<h3 id="org4431e97">nullptr</h3>
<div class="outline-text-3" id="text-org4431e97">
<p>
In C++, there is a keyword that represents a null pointer, and it is called <code>nullptr</code>. It is not a macro like in C. It is a keyword, a constant and its type is <code>nullptr_t</code>.
</p>

<p>
You can assign <code>nullptr</code> to other pointer types but there is no implicit conversion from <code>nullptr_t</code> type to arithmetic types.
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid</span>
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">nullptr</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid</span>
   <span style="color: #6ae4b9;">int</span>* <span style="color: #ffffff;">y</span> = <span style="color: #00bcff;">nullptr</span>;
   <span style="color: #6ae4b9;">double</span>* <span style="color: #ffffff;">z</span> = <span style="color: #00bcff;">nullptr</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-org0c131c1" class="outline-3">
<h3 id="org0c131c1">Reference Semantics</h3>
<div class="outline-text-3" id="text-org0c131c1">
<p>
There is an alternative way to represent pointers in C++, which is called <code>reference</code>, but this is only an alternative at the language layer, the underlying representation does not change once the code is compiled. Everything works with the pointers in assembly level.
</p>

<p>
There are 3 different reference categories:
</p>
<ul class="org-ul">
<li>L-value reference</li>
<li>R-value reference (move semantics, perfect forwarding (generic prog.))</li>
<li>Forwarding/universal reference</li>
</ul>
<p>
An example:
</p>
<div class="org-src-container">
<pre class="src src-C++">    <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">L-value reference</span>
    <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">y</span> = x;
    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">R-value reference</span>
    <span style="color: #6ae4b9;">int</span>&amp;&amp; <span style="color: #ffffff;">z</span> = <span style="color: #00bcff;">10</span>;
    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Forwarding/universal reference</span>
    <span style="color: #b6a0ff;">auto</span>&amp;&amp; <span style="color: #ffffff;">t</span> = <span style="color: #00bcff;">10</span>;
</pre>
</div>
</div>
<div id="outline-container-org8d6ed5c" class="outline-4">
<h4 id="org8d6ed5c">L-value references</h4>
<div class="outline-text-4" id="text-org8d6ed5c">
<p>
L-value references are similar to <code>top-level const pointer objects</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">    <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;

    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">We cannot change the value of the ptr because it is a const pointer. It will always point to the same object</span>
    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">which is x in this case. Whenever *ptr is used, it means x.</span>
    <span style="color: #6ae4b9;">int</span>* <span style="color: #b6a0ff;">const</span> <span style="color: #ffffff;">ptr</span> = &amp;x;
    <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span> = *ptr; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int y = x;</span>
</pre>
</div>

<p>
L-value references represent their underlying object directly, there is no need for dereferencing like pointers. They cannot be default initialized, cannot be initialized with R-value objects and cannot be reassigned/rebound(like <code>top-level const pointer</code>).
</p>
<div class="org-src-container">
<pre class="src src-C++">       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Reference r directly represents x</span>
       <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">r</span> = x;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">No need to dereference like a pointer</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span> = r; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int y = x;</span>

       <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">r1</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Syntax error. References cannot be default initialized.</span>
       <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">r2</span> = <span style="color: #00bcff;">10</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Syntax error. References cannot be initialized with R-value objects.</span>

       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">z</span> = <span style="color: #00bcff;">10</span>;
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">t</span> = <span style="color: #00bcff;">20</span>;
       <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">r3</span> = z;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is valid but equals to z = t. r3 still represents z, what we did is changing value of z.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">References cannot be reassigned.</span>
       r3 = t; 
</pre>
</div>

<p>
We can say that when we define a L-value reference we bind it to underlying object and they will stay bound until the end of scope.
</p>
<div class="org-src-container">
<pre class="src src-C++">    <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">All r1, r2 and r3 bound to x</span>
    <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">r1</span> = x;
    <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">r2</span> = r1;
    <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">r3</span> = r2;

    ++r1;
    ++r2;
    ++r3;
    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">x is 13 here</span>

</pre>
</div>

<p>
L-value rereferences can also be bound to arrays and array decay rules do not change:
</p>
<div class="org-src-container">
<pre class="src src-C++">    <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">a</span><span style="color: #ffffff;">[]</span> = <span style="color: #ffffff;">{</span> <span style="color: #00bcff;">1</span>, <span style="color: #00bcff;">3</span>, <span style="color: #00bcff;">5</span>, <span style="color: #00bcff;">7</span>, <span style="color: #00bcff;">9</span> <span style="color: #ffffff;">}</span>;
    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">r is bound to a</span>
    <span style="color: #feacd0;">int </span><span style="color: #ffffff;">(</span>&amp;ra<span style="color: #ffffff;">)[]</span> = a; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Normally, we do not have to write the type directly. we can use type deduction.</span>

    <span style="color: #feacd0;">for </span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">i</span> = <span style="color: #00bcff;">0</span>; i &lt; <span style="color: #00bcff;">5</span>; ++i<span style="color: #ffffff;">)</span>
    <span style="color: #ffffff;">{</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">ra[i] equals to a[i]</span>
    <span style="color: #ffffff;">}</span>

    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Same rules apply for array decay</span>
    <span style="color: #6ae4b9;">int</span>* <span style="color: #ffffff;">p1</span> = a;
    <span style="color: #6ae4b9;">int</span>* <span style="color: #ffffff;">p2</span> = ra;
</pre>
</div>

<p>
L-value references often used to pass the object to the function (<code>call by reference</code>) and also to return the object itself from the function.
</p>
<div class="org-src-container">
<pre class="src src-C++">    <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">r</span><span style="color: #ffffff;">)</span>
    <span style="color: #ffffff;">{</span>
    ++r;
    <span style="color: #b6a0ff;">return</span> r;
    <span style="color: #ffffff;">}</span>

    <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;

    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Value of x will be 11 after foo() is called</span>
    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">r represents x</span>
    <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">r</span> = <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-org39e4188" class="outline-4">
<h4 id="org39e4188">L-value references and const semantics</h4>
<div class="outline-text-4" id="text-org39e4188">
<p>
We said that L-value references are like <code>top-level const pointer</code> by default but they can also be used like <code>low-level const pointer</code>.
Pointer parameters can be used as a mutator or accessor. L-value references also can be used in a similar way:
</p>
<div class="org-src-container">
<pre class="src src-C++">    <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>* <span style="color: #ffffff;">p</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Mutator</span>
    <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span>* <span style="color: #ffffff;">p</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Accessor</span>

    <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f3</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">r</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Mutator</span>
    <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f4</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">r</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Accessor</span>
</pre>
</div>

<p>
<code>const</code> objects can only be bound by <code>const</code> L-value references similar to pointers:
</p>
<div class="org-src-container">
<pre class="src src-C++">    <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
    <span style="color: #6ae4b9;">int</span>* <span style="color: #ffffff;">p</span> = &amp;x; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid. int* p cannot point to const int x.</span>
    <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">r</span> = x; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Also invalid. int&amp; r cannot bind to const int x.</span>

    <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">cr</span> = x; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid.</span>
</pre>
</div>

<p>
Normally, initializing an L-value reference with a different/mismatching object type is syntax error:
</p>
<div class="org-src-container">
<pre class="src src-C++">    <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
    <span style="color: #6ae4b9;">double</span>&amp; <span style="color: #ffffff;">r</span> = x; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Syntax error. double&amp; r cannot bind to int object.</span>
</pre>
</div>

<p>
But, if we try to initialize a <code>const</code> L-value reference with a different/mismatching object type and there is an implicit conversion from that object type to the type represented by the <code>const</code> L-value reference, the compiler creates a temporary object and the <code>const</code> L-value reference is bound to that temporary object:
</p>
<div class="org-src-container">
<pre class="src src-C++">    <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is valid. Normally, double and int types do not match but implicit conversion is allowed from int to double.</span>
    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">So, compiler creates a temporary double object and assign x to it, then cr binds to that temporary object.</span>
    <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">double</span>&amp; <span style="color: #ffffff;">cr</span> = x; 

    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">We can think that compiler generates something like this for above code.</span>
    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">double temporary_object = x;</span>
    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">const double&amp; cr = temporary_object;</span>
</pre>
</div>

<p>
This also applies, when we try to initialize <code>const</code> L-value references with R-value objects:
</p>
<div class="org-src-container">
<pre class="src src-C++">     <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is syntax error. L-value references cannot be initialized with R-value objects.</span>
    <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">r</span> = <span style="color: #00bcff;">10</span>;

    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is valid when we use const L-value reference, because compiler creates a temporary object like the example above.</span>
    <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">cr</span> = <span style="color: #00bcff;">10</span>;

    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Compiler might generate something like this for above code.</span>
    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int temporary_object = 10;</span>
    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">const int&amp; cr = temporary_object;</span>
</pre>
</div>

<p>
This becomes even more important when we call functions that take L-value reference parameters, for example:
</p>
<div class="org-src-container">
<pre class="src src-C++">     <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">We can only pass an L-value objects to f1(). If we try to pass a R-value object it will be syntax error.</span>
     <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span>;
     <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
     <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid.</span>
     <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid, syntax error.</span>

     <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">It is not the same for f2() however. We can pass L-value objects to f2() but if we try to pass a R-value object, it will not cause</span>
     <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">any syntax error because of the rules above. The temporary object will be passed to f2() instead of R-value object itself. (Assuming there is no type problem)</span>
     <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span>;
     <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span> = <span style="color: #00bcff;">10</span>;
     <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span>y<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid.</span>
     <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Also valid.</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org4075d4b" class="outline-4">
<h4 id="org4075d4b">Differences between pointers and L-value references</h4>
<div class="outline-text-4" id="text-org4075d4b">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Pointers</th>
<th scope="col" class="org-left">References</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">don't have to be initialized</td>
<td class="org-left">have to be initialized</td>
</tr>

<tr>
<td class="org-left">pointer to pointer exists</td>
<td class="org-left">reference to reference doesn't exist (ignoring reference collapsing)</td>
</tr>

<tr>
<td class="org-left">arrays can store pointers</td>
<td class="org-left">arrays cannot store references</td>
</tr>

<tr>
<td class="org-left">pointers can be null (nullptr)</td>
<td class="org-left">references cannot be null</td>
</tr>

<tr>
<td class="org-left">pointers can be reassigned</td>
<td class="org-left">references cannot be reassigned</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org264e0d2" class="outline-4">
<h4 id="org264e0d2">R-value references</h4>
<div class="outline-text-4" id="text-org264e0d2">
<p>
R-value references are mostly about move semantics and perfect forwarding. Details will be discussed in the future. We will just briefly explain the syntax for now.
R-value references cannot be default-initialized like L-value references, and can be initialized only with R-value objects.
</p>
<div class="org-src-container">
<pre class="src src-C++">    <span style="color: #6ae4b9;">int</span>&amp;&amp; <span style="color: #ffffff;">r</span> = <span style="color: #00bcff;">10</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid, R-value reference.</span>

    <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
    <span style="color: #6ae4b9;">int</span>&amp;&amp; <span style="color: #ffffff;">rr</span> = x; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid. R-value references cannot be initialized with L-value objects.</span>
</pre>
</div>

<p>
&#x2026;
</p>
</div>
</div>
</div>
<div id="outline-container-org1bbac5f" class="outline-3">
<h3 id="org1bbac5f">Type Deduction</h3>
<div class="outline-text-3" id="text-org1bbac5f">
<p>
In C++, we don't need to write the type explicitly in some contexts. We can use one of the type deduction mechanisms to have the compiler determine the type for us by looking at the code.
There are several different mechanisms for type deduction:
</p>
<ul class="org-ul">
<li>auto</li>
<li>decltype</li>
<li>decltyoe(auto)</li>
<li>template</li>
</ul>
</div>
<div id="outline-container-orgb94ae63" class="outline-4">
<h4 id="orgb94ae63">auto type deduction</h4>
<div class="outline-text-4" id="text-orgb94ae63">
<p>
The <code>auto</code> keyword can be used to determine the type of the variable during initialization. A very important point is that the type deduction is made for <code>auto</code> keyword not for the variable itself.
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int x = 10;</span>

   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span> = <span style="color: #00bcff;">45</span>;
   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">z</span> = y; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int z = y;</span>

   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">t</span> = <span style="color: #00bcff;">0U</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">unsigned int t = 0U;</span>
   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">k</span> = <span style="color: #00bcff;">0</span>.; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">double k = 0.;</span>

   <span style="color: #6ae4b9;">char</span> <span style="color: #ffffff;">c</span> = <span style="color: #79a8ff;">'a'</span>;
   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">a</span> = c; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">char a = c;</span>
   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">b</span> = +c; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int b = +c;</span>

   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">d</span> = <span style="color: #00bcff;">10</span> &gt; <span style="color: #00bcff;">5</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">bool d = 10 &gt; 5;</span>
</pre>
</div>

<p>
We cannot <code>default initialize</code> an object with <code>auto</code> because in this case the compiler cannot determine its type:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">x</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid.</span>
</pre>
</div>

<p>
If an object is <code>auto</code> initialized with a <code>const</code> object and does not have any declarator (such as *, &amp;), <code>const</code> qualifier drops:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">cx</span> = <span style="color: #00bcff;">6</span>;
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This equals to int y = cx;. const qualifier drops.</span>
   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">y</span> = cx;

   <span style="color: #6ae4b9;">int</span>* <span style="color: #b6a0ff;">const</span> <span style="color: #ffffff;">ptr</span> = <span style="color: #00bcff;">0</span>;
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">ptr is const pointer to int. If the object itself is const, const qualifier drops.</span>
   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">p</span> = ptr; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int* p = ptr;</span>

   <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span>* <span style="color: #ffffff;">ptr1</span> = <span style="color: #00bcff;">0</span>;
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">ptr1 is pointer to const int. The object itself is not const, const qualifier does not drop in this case.</span>
   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">p1</span> = ptr1; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">const int* p1 = ptr1;</span>
</pre>
</div>

<p>
If an object is <code>auto</code> initialized with a <code>reference</code> and does not have any declarator (such as *, &amp;), <code>reference</code> qualifier drops:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
   <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">r</span> = x;
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This equals to int y = r;. reference qualifier drops.</span>
   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">y</span> = r;

   <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">cr</span> = x;
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This equals to int z = cr;. const and reference qualifiers drop.</span>
   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">z</span> = cr;
</pre>
</div>

<p>
Array decay rules are still valid: 
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">a</span><span style="color: #ffffff;">[]</span> = <span style="color: #ffffff;">{</span> <span style="color: #00bcff;">1</span>, <span style="color: #00bcff;">3</span>, <span style="color: #00bcff;">6</span>, <span style="color: #00bcff;">7</span> <span style="color: #ffffff;">}</span>;
   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">p</span> = a; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int* p = a;</span>

   <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">ca</span><span style="color: #ffffff;">[]</span> = <span style="color: #ffffff;">{</span> <span style="color: #00bcff;">1</span>, <span style="color: #00bcff;">3</span>, <span style="color: #00bcff;">6</span>, <span style="color: #00bcff;">7</span> <span style="color: #ffffff;">}</span>;
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Here const qualifier does not drop. The object itself 'ca' is not const.</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">It is a pointer to const int after array decay.</span>
   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">cp</span> = ca; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">const int* cp = ca;</span>

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The type of the "test" is const char[5], it decays to const char*.</span>
   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">str</span> = <span style="color: #79a8ff;">"test"</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">const char* str = "test";</span>
</pre>
</div>

<p>
<code>auto</code> initialization with functions:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Normally, type of the foo is int(int) but it decays to int (*)(int).</span>
   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">fp</span> = foo; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int (*fp)(int) = foo;</span>
</pre>
</div>

<p>
<code>auto</code> initialization and <code>std::initializer_list</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">x</span> = <span style="color: #ffffff;">{</span> <span style="color: #00bcff;">3</span> <span style="color: #ffffff;">}</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">std::initializer_list x = { 3 };</span>
   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">y</span><span style="color: #ffffff;">{</span> <span style="color: #00bcff;">3</span> <span style="color: #ffffff;">}</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int y{ 3 }; This rule was different before. It was also meaning std::initializer_list y{ 3 };</span>
</pre>
</div>

<p>
Type deduction is made for <code>auto</code> keyword not for variable itself:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">p1</span> = &amp;x; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int* p1 = &amp;x; auto -&gt; int*</span>
   <span style="color: #b6a0ff;">auto</span>* <span style="color: #ffffff;">p2</span> = &amp;x; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int* p2 = &amp;x; auto -&gt; int</span>

   <span style="color: #6ae4b9;">int</span>* <span style="color: #ffffff;">ptr</span> = &amp;x;
   <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">p1</span> = &amp;ptr; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int** p1 = &amp;ptr; auto -&gt; int**</span>
   <span style="color: #b6a0ff;">auto</span>* <span style="color: #ffffff;">p2</span> = &amp;ptr; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int** p2 = &amp;ptr; auto -&gt; int*</span>
   <span style="color: #b6a0ff;">auto</span>** <span style="color: #ffffff;">p3</span> = &amp;ptr; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int** p3 = &amp;ptr; auto -&gt; int</span>
</pre>
</div>

<p>
If declarators and <code>auto</code> are used together, rules are a bit different:
In this example there is no difference:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
   <span style="color: #b6a0ff;">auto</span>&amp; <span style="color: #ffffff;">r</span> = x; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int&amp; r = x;</span>
</pre>
</div>

<p>
But when we use a <code>const</code> object:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">const qualifier does not drop here.</span>
   <span style="color: #b6a0ff;">auto</span>&amp; <span style="color: #ffffff;">r</span> = x; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">const int&amp; r = x;</span>
</pre>
</div>

<p>
Array and function rules are also different:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">a</span><span style="color: #ffffff;">[</span><span style="color: #00bcff;">3</span><span style="color: #ffffff;">]</span> = <span style="color: #ffffff;">{</span> <span style="color: #00bcff;">1</span>, <span style="color: #00bcff;">2</span>, <span style="color: #00bcff;">3</span> <span style="color: #ffffff;">}</span>;
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Array decay does not occur here.</span>
   <span style="color: #b6a0ff;">auto</span>&amp; <span style="color: #ffffff;">x</span> = a; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int (&amp;x)[3] = a;</span>
   <span style="color: #b6a0ff;">auto</span>&amp; <span style="color: #ffffff;">str</span> = <span style="color: #79a8ff;">"test"</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">const char (&amp;str)[5] = "test";</span>

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">There is no decay here. Type deduction will be int(int) type for auto.</span>
   <span style="color: #b6a0ff;">auto</span>&amp; <span style="color: #ffffff;">f1</span> = foo; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int (&amp;f1)(int) = foo;   </span>
</pre>
</div>

<p>
If double reference (&amp;&amp;) declarator (forwarding-reference) is used with <code>auto</code>, the rules change significantly. If <code>auto&amp;&amp;</code> is used, the type deduction for the <code>auto</code> keyword depends on the value category of the object used for initialization. Different rules are applied for L-value expressions and R-value expressions (PR-value or X-value).
</p>

<p>
If value of category of the initializer is PR-value, the type deduction for <code>auto</code> will be the type of the expression:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Type deduction for auto will be int because type of 20 is int.</span>
   <span style="color: #b6a0ff;">auto</span>&amp;&amp; <span style="color: #ffffff;">p</span> = <span style="color: #00bcff;">20</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int&amp;&amp; p = 20;</span>
</pre>
</div>

<p>
If value of category of the initializer is L-value, the type deduction for <code>auto</code> will be L-value reference:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span>;
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Type deduction for auto will be int&amp; but there is no int&amp;&amp;&amp;, so reference collapsing rules apply here.</span>
   <span style="color: #b6a0ff;">auto</span>&amp;&amp; <span style="color: #ffffff;">p</span> = x; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">After reference collapsing this equals to int&amp; p = x;</span>
</pre>
</div>

<p>
Reference collapsing rules:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">reference type</th>
<th scope="col" class="org-left">binding reference type</th>
<th scope="col" class="org-left">result after reference collapsing</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">T&amp;</td>
<td class="org-left">T&amp;&amp;</td>
<td class="org-left">T&amp;</td>
</tr>

<tr>
<td class="org-left">T&amp;&amp;</td>
<td class="org-left">T&amp;</td>
<td class="org-left">T&amp;</td>
</tr>

<tr>
<td class="org-left">T&amp;</td>
<td class="org-left">T&amp;</td>
<td class="org-left">T&amp;</td>
</tr>

<tr>
<td class="org-left">T&amp;&amp;</td>
<td class="org-left">T&amp;&amp;</td>
<td class="org-left">T&amp;&amp;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgf912347" class="outline-4">
<h4 id="orgf912347">decltype type deduction</h4>
<div class="outline-text-4" id="text-orgf912347">
<p>
<code>auto</code> type deduction can be used for initialization but <code>decltype</code> type deduction does not have this limitation. It can be used in any context intead of types. <code>decltype</code> is also <code>unevaluated context</code> like <code>sizeof</code>.
</p>

<p>
<code>decltype</code> has quite complex rules. Using paranthesis is necessary while using <code>decltype</code>. There are 2 different rulesets for <code>decltype</code>:
</p>

<p>
Rulesets:
</p>
<ul class="org-ul">
<li>If the operand of the <code>decltype</code> is an <code>identifier</code>, different rules are applied.</li>
<li>If the operand of the <code>decltype</code> is an <code>expression</code>, different rules are applied.</li>
</ul>

<p>
Example for rulesets:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">struct</span> <span style="color: #6ae4b9;">Data</span> <span style="color: #ffffff;">{</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">a</span>, <span style="color: #ffffff;">b</span>, <span style="color: #ffffff;">c</span>; <span style="color: #ffffff;">}</span>;
   
   <span style="color: #6ae4b9;">Data</span> <span style="color: #ffffff;">my_data</span><span style="color: #ffffff;">{}</span>;
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;   
   
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Identifier rules applied here.</span>
   <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span>my_data<span style="color: #ffffff;">)</span>;
   <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span>my_data.a<span style="color: #ffffff;">)</span>;
   <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span>;
   
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">But here expression rules are applied.</span>
   <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">))</span>;
   <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span>+x<span style="color: #ffffff;">)</span>;
</pre>
</div>

<p>
<code>decltype</code> can be used in a lot of contexts:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;

   <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Function declaration. int foo();</span>
   <span style="color: #b6a0ff;">using</span> <span style="color: #6ae4b9;">my_type</span> = <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">using my_type = int;</span>

   <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span> = <span style="color: #00bcff;">5</span>;
   <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span> z = <span style="color: #00bcff;">0</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">const int z = 0;</span>
</pre>
</div>

<p>
<code>decltype</code> and references:
</p>
<div class="org-src-container">
<pre class="src src-C++">    <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">{}</span>;
    <span style="color: #b6a0ff;">auto</span>&amp; <span style="color: #ffffff;">r</span><span style="color: #ffffff;">{</span> x <span style="color: #ffffff;">}</span>;

    <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span>r<span style="color: #ffffff;">)</span> r2 = x; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int&amp; r2 = x;</span>

    <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span><span style="color: #ffffff;">{}</span>;
    <span style="color: #b6a0ff;">const</span> <span style="color: #b6a0ff;">auto</span>&amp; <span style="color: #ffffff;">r3</span> = y;
    <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span>r3<span style="color: #ffffff;">)</span> r4 = y; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">const int&amp; r4 = y;</span>
</pre>
</div>

<p>
When the operand of the <code>decltype</code> is an expression. The type will be determined by the <code>primary value category</code> of the expression.
If the expression is:
</p>
<ul class="org-ul">
<li>L-value deduction will be <code>T&amp;</code></li>
<li>PR-value deduction will be <code>T</code></li>
<li>X-value deduction will be <code>T&amp;&amp;</code></li>
</ul>

<p>
PR-value expression:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">PR-Value. int</span>
</pre>
</div>

<p>
L-value expression:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
   <span style="color: #6ae4b9;">int</span>* <span style="color: #ffffff;">ptr</span> = &amp;x;
   <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span>*ptr<span style="color: #ffffff;">)</span> r = x; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">L-value. int&amp; r = x;</span>
 
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span> = <span style="color: #00bcff;">5</span>;
   <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">(</span>y<span style="color: #ffffff;">))</span> z = y; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">L-value. int&amp; z = y;</span>
 
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">t</span> = <span style="color: #00bcff;">10</span>;
   <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span>t++<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int</span>
   <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span>++t<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int&amp;</span>
</pre>
</div>

<p>
<code>decltype</code> and arrays:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">a</span><span style="color: #ffffff;">[</span><span style="color: #00bcff;">5</span><span style="color: #ffffff;">]{}</span>;
 
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">a is an identifier</span>
   <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span>a<span style="color: #ffffff;">)</span> b; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int b[5]; No array decay.</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">a[0] is an expression</span>
   <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span>a<span style="color: #ffffff;">[</span><span style="color: #00bcff;">0</span><span style="color: #ffffff;">])</span> c = a<span style="color: #ffffff;">[</span><span style="color: #00bcff;">1</span><span style="color: #ffffff;">]</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int&amp; c = a[1];</span>
</pre>
</div>

<p>
X-value expression:
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
  <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
  <span style="color: #6ae4b9;">int</span>&amp;&amp; <span style="color: #feacd0;">f3</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

  <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span><span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">))</span> x = <span style="color: #00bcff;">5</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">PR-value. int x = 5;</span>
  <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span><span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">))</span> y = x; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">L-value. int&amp; y = x;</span>
  <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span><span style="color: #feacd0;">f3</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">))</span> z = <span style="color: #00bcff;">5</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">X-value. int&amp;&amp; z = 5;</span>
</pre>
</div>

<p>
Other type deduction mechanisms will be discussed later.
</p>

<p>
&#x2026; 
</p>
</div>
</div>
</div>
<div id="outline-container-orgde594a7" class="outline-3">
<h3 id="orgde594a7">Default Function Arguments</h3>
<div class="outline-text-3" id="text-orgde594a7">
<p>
Unlike C, C++ supports default function arguments. If a function mostly takes the same value for an argument, default function arguments are very helpful.
When the <code>default function argument</code> is used, we do not need to pass a value to that argument when calling the function. The compiler will insert the value that we specified:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span> = <span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">1</span>;
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span> = <span style="color: #00bcff;">2</span>;
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">z</span> = <span style="color: #00bcff;">3</span>;

   <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span>x, y, z<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">func(x, y, z);</span>
   <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span>x, y<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">func(x, y, 10); The compiler will insert 10 for the 3rd argument because we did not send any argument for the 3rd parameter.</span>
</pre>
</div>

<p>
If a parameter of a function takes a <code>default argument</code>, all parameters to the right of it must also take a <code>default argument</code>. This essentially means that the <code>default arguments</code> are valid for the last function parameters:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span> = <span style="color: #00bcff;">5</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">z</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid.</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span> = <span style="color: #00bcff;">5</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">z</span> = <span style="color: #00bcff;">7</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid.</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f3</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">3</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span> = <span style="color: #00bcff;">5</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">z</span> = <span style="color: #00bcff;">7</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid.</span>

   <span style="color: #feacd0;">f3</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">f3(3, 5, 7);</span>
   <span style="color: #feacd0;">f3</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">40</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">f3(40, 5, 7);</span>
   <span style="color: #feacd0;">f3</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">40</span>, <span style="color: #00bcff;">50</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">f3(40, 50, 7);</span>
   <span style="color: #feacd0;">f3</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">40</span>, <span style="color: #00bcff;">50</span>, <span style="color: #00bcff;">60</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">f3(40, 50, 60);</span>
</pre>
</div>

<p>
Variables also can be used for <code>default function arguments</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">{</span> <span style="color: #00bcff;">5</span> <span style="color: #ffffff;">}</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> = x<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid.</span>

   <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">func(x);</span>

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">0</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span> = <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">))</span>;

   <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">f2(f1(0));</span>

   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span><span style="color: #ffffff;">{</span> <span style="color: #00bcff;">5</span> <span style="color: #ffffff;">}</span>;
   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">n</span> = y++<span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #b6a0ff;">return</span> n;
   <span style="color: #ffffff;">}</span>

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">y = 5;</span>
   <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">foo(y++); returns 5;</span>
   <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">foo(y++); returns 6;</span>
   <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">foo(y++); returns 7;</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">y = 8;</span>
</pre>
</div>

<p>
If <code>the default function arguments</code> are defined both in the function definition and in the declaration, this is a syntax error:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid.</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #989898; font-style: italic;">//</span>
   <span style="color: #ffffff;">}</span>

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid.</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f3</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f3</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #989898; font-style: italic;">//</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
If a function parameter does not take a <code>default argument</code>, we can redeclare the function so that it takes a <code>default argument</code>. This can, for example, allow us to pass <code>default arguments</code> to functions coming from external header files:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">external.h</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Function without any default arguments.</span>

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">#include "external.h"</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span> = <span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid.</span>

   <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">1</span>, <span style="color: #00bcff;">5</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">func(1, 5, 10);</span>
</pre>
</div>

<p>
The compiler takes the <code>default arguments</code> cumulatively:
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid, because there are multiple definitions for the same parameter's default argument.</span>
  <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>;
  <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>;

  <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">f2 does not take any default arguments. </span>
  <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
  <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">f2 takes a default argument for the 3rd parameter.</span>
  <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span> = <span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>;
  <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">f2 takes default arguments for the 2nd and 3rd parameters. This equals to void f2(int, int = 5, int = 10);</span>
  <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">because the compiler takes the default arguments cumulatively.</span>
  <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span> = <span style="color: #00bcff;">5</span>, <span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;

  <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">1</span><span style="color: #ffffff;">)</span> <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">f2(1, 5, 10);</span>

  <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">f3 does not take any default arguments. </span>
  <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f3</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
  <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid. This is a different case, only last parameters can take default arguments.</span>
  <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f3</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span> = <span style="color: #00bcff;">5</span>, <span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>; 
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd123df8" class="outline-3">
<h3 id="orgd123df8">Scoped enum / Enum class</h3>
<div class="outline-text-3" id="text-orgd123df8">
<p>
In addition to the <code>traditional enum type</code>, C++ has a new enum type called <code>scoped enum</code> / <code>enum class</code>. <code>Scoped enum</code> were introduced to overcome the disadvantages of the <code>traditional enum type</code>.
</p>
</div>
<div id="outline-container-org9c0ccbc" class="outline-4">
<h4 id="org9c0ccbc">Disadvantages of the traditional enum type</h4>
<div class="outline-text-4" id="text-org9c0ccbc">
<ul class="org-ul">
<li><p>
<code>Underlying type</code> depends to the compiler. The compiler chooses <code>int</code> as default type but if <code>int</code> isn't big enough to store the <code>enumeration constants</code>, the type choosen is compiler dependent. This is why <code>traditional enum types</code> cannot be used as <code>incomplete types</code>. The compiler cannot know the size when used as an <code>incomplete type</code>, because it may be larger than <code>int</code>.
</p>
<div class="org-src-container">
<pre class="src src-C++">    <span style="color: #b6a0ff;">enum</span> <span style="color: #6ae4b9;">Color</span> <span style="color: #ffffff;">{</span> <span style="color: #ffffff;">Red</span>, <span style="color: #ffffff;">Green</span>, <span style="color: #ffffff;">Blue</span> <span style="color: #ffffff;">}</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Underlying type is int.</span>
    <span style="color: #b6a0ff;">enum</span> <span style="color: #6ae4b9;">MyEnum</span> <span style="color: #ffffff;">{</span> <span style="color: #ffffff;">Aa</span>, <span style="color: #ffffff;">Bb</span>, <span style="color: #ffffff;">Cc</span>, <span style="color: #ffffff;">Dd</span> = <span style="color: #00bcff;">13024325325</span> <span style="color: #ffffff;">}</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Underlying type is compiler dependent.</span>
</pre>
</div></li>
<li><p>
Implicit type conversion from <code>traditional enum types</code> to <code>arithmetic types</code> is allowed. Unfortunately, this can also lead to many problems.
</p>
<div class="org-src-container">
<pre class="src src-C++">    <span style="color: #b6a0ff;">enum</span> <span style="color: #6ae4b9;">Color</span> <span style="color: #ffffff;">{</span> <span style="color: #ffffff;">Red</span>, <span style="color: #ffffff;">Green</span>, <span style="color: #ffffff;">Blue</span> <span style="color: #ffffff;">}</span>;
    <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = Red; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid.</span>
</pre>
</div></li>
<li><p>
<code>Enumeration constants</code> don't have separate scope. This can cause name conflicts, especially with names from external header files.
</p>
<div class="org-src-container">
<pre class="src src-C++">    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">traffic.h</span>
    <span style="color: #b6a0ff;">enum</span> <span style="color: #6ae4b9;">TrafficLight</span> <span style="color: #ffffff;">{</span> <span style="color: #ffffff;">Red</span>, <span style="color: #ffffff;">Yellow</span>, <span style="color: #ffffff;">Green</span> <span style="color: #ffffff;">}</span>;
    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">screen.h</span>
    <span style="color: #b6a0ff;">enum</span> <span style="color: #6ae4b9;">ScreenColor</span> <span style="color: #ffffff;">{</span> <span style="color: #ffffff;">Gray</span>, <span style="color: #ffffff;">White</span>, <span style="color: #ffffff;">Red</span> <span style="color: #ffffff;">}</span>;
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org85c7450" class="outline-4">
<h4 id="org85c7450">Advantages of the scoped enum type</h4>
<div class="outline-text-4" id="text-org85c7450">
<ul class="org-ul">
<li><p>
The <code>underlying type</code> can be specified. If not specified <code>int</code> is default.
</p>
<div class="org-src-container">
<pre class="src src-C++">     <span style="color: #b6a0ff;">enum</span> <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">Color</span> : <span style="color: #6ae4b9;">unsigned</span> <span style="color: #6ae4b9;">char</span> <span style="color: #ffffff;">{</span> <span style="color: #ffffff;">White</span>, <span style="color: #ffffff;">Black</span>, <span style="color: #ffffff;">Gray</span> <span style="color: #ffffff;">}</span>;
     <span style="color: #b6a0ff;">enum</span> <span style="color: #6ae4b9;">Count</span> : <span style="color: #6ae4b9;">unsigned</span> <span style="color: #6ae4b9;">char</span> <span style="color: #ffffff;">{</span> <span style="color: #ffffff;">Zero</span>, <span style="color: #ffffff;">One</span>, <span style="color: #ffffff;">Two</span>, <span style="color: #ffffff;">Three</span> <span style="color: #ffffff;">}</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C++ also extended the traditional enum types, so that specifying underlying types is possible.</span>
</pre>
</div></li>
<li><p>
No implicit type conversion from <code>scoped enum types</code> to <code>arithmetic types</code>.
</p>
<div class="org-src-container">
<pre class="src src-C++">     <span style="color: #b6a0ff;">enum</span> <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">Color</span> : <span style="color: #6ae4b9;">unsigned</span> <span style="color: #6ae4b9;">char</span> <span style="color: #ffffff;">{</span> <span style="color: #ffffff;">White</span>, <span style="color: #ffffff;">Black</span>, <span style="color: #ffffff;">Gray</span> <span style="color: #ffffff;">}</span>;
     <span style="color: #6ae4b9;">Color</span> <span style="color: #ffffff;">color</span><span style="color: #ffffff;">{</span> <span style="color: #00bcff;">Color</span>::Black <span style="color: #ffffff;">}</span>;
     <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = color; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid.</span>
</pre>
</div></li>
<li><p>
<code>Enumeration constants</code> are no longer in the same scope with the <code>enumeration type</code>. As the name indicates, they have a separate scope. This eliminates the name conflict problems.
</p>
<div class="org-src-container">
<pre class="src src-C++">     <span style="color: #b6a0ff;">enum</span> <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">Color</span> : <span style="color: #6ae4b9;">unsigned</span> <span style="color: #6ae4b9;">char</span> <span style="color: #ffffff;">{</span> <span style="color: #ffffff;">White</span>, <span style="color: #ffffff;">Black</span>, <span style="color: #ffffff;">Gray</span> <span style="color: #ffffff;">}</span>;
     <span style="color: #6ae4b9;">Color</span> <span style="color: #ffffff;">color1</span> = White; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid.</span>
     <span style="color: #6ae4b9;">Color</span> <span style="color: #ffffff;">color2</span> = <span style="color: #00bcff;">Color</span>::White; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid.</span>

     <span style="color: #b6a0ff;">enum</span> <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">TrafficLight</span> <span style="color: #ffffff;">{</span> <span style="color: #ffffff;">Red</span>, <span style="color: #ffffff;">Yellow</span>, <span style="color: #ffffff;">Green</span> <span style="color: #ffffff;">}</span>;
     <span style="color: #b6a0ff;">enum</span> <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">ScreenColor</span> <span style="color: #ffffff;">{</span> <span style="color: #ffffff;">Gray</span>, <span style="color: #ffffff;">White</span>, <span style="color: #ffffff;">Red</span> <span style="color: #ffffff;">}</span>;
     <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">sc</span> = <span style="color: #00bcff;">ScreenColor</span>::Red;
     <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">tl</span> = <span style="color: #00bcff;">TrafficLight</span>::Red;
</pre>
</div></li>
</ul>

<p>
In C++20, <code>using enum declaration</code> was added to the language. If we are sure that there is no name conflict, we can use <code>using enum declaration</code> to use <code>enumeration constants</code> without specifying them with a namespace.
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">enum</span> <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">Color</span> : <span style="color: #6ae4b9;">unsigned</span> <span style="color: #6ae4b9;">char</span> <span style="color: #ffffff;">{</span> <span style="color: #ffffff;">White</span>, <span style="color: #ffffff;">Black</span>, <span style="color: #ffffff;">Gray</span> <span style="color: #ffffff;">}</span>;
   <span style="color: #b6a0ff;">enum</span> <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">Count</span> : <span style="color: #6ae4b9;">unsigned</span> <span style="color: #6ae4b9;">char</span> <span style="color: #ffffff;">{</span> <span style="color: #ffffff;">Zero</span>, <span style="color: #ffffff;">One</span>, <span style="color: #ffffff;">Two</span> <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C++20, using enum declaration</span>
       <span style="color: #b6a0ff;">using</span> <span style="color: #b6a0ff;">enum</span> Color;
       <span style="color: #b6a0ff;">using</span> <span style="color: #b6a0ff;">enum</span> <span style="color: #00bcff;">Count</span>::Zero;

       <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">color1</span> = White; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid.</span>
       <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">color2</span> = Black; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid.</span>

       <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">count1</span> = Zero; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid.</span>
       <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">count2</span> = One; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid.</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org68dbf70" class="outline-3">
<h3 id="org68dbf70">Type Cast Operators</h3>
<div class="outline-text-3" id="text-org68dbf70">
<p>
In C++, there 2 different type conversions: <code>implicit type conversion</code> and <code>explicit type conversion</code>. In some cases the compiler is free to do <code>implicit type conversion</code> depending on the rules of the language, but if we want to explicity convert a type, we have to do <code>explicit type conversion</code> by using <code>type cast operators</code>.
</p>

<p>
There are 4-different type cast operators in C++ (excluding <code>C-style cast</code>):
</p>
<ul class="org-ul">
<li><code>static_cast&lt;target_type&gt;(operand)</code>
<ul class="org-ul">
<li>Mostly used casting between different arithmetic and enumeration types, also can be used to cast from <code>void*</code> to another pointer type.</li>
</ul></li>
<li><code>const_cast&lt;target_type&gt;(operand)</code>
<ul class="org-ul">
<li>Used for casting <code>const T*</code> to <code>T*</code>.</li>
</ul></li>
<li><code>reinterpret_cast&lt;target_type&gt;(operand)</code>
<ul class="org-ul">
<li>Used for casting between different pointer and reference types. Ex. <code>int*</code> to <code>char*</code>.</li>
</ul></li>
<li><code>dynamic_cast&lt;target_type&gt;(operand)</code>
<ul class="org-ul">
<li>This cast is about runtime polymorphism, can be used to cast from <code>base class</code> to <code>derived class</code>.</li>
</ul></li>
</ul>

<p>
Example for <code>static_cast</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span> = <span style="color: #00bcff;">3</span>;

   <span style="color: #6ae4b9;">double</span> <span style="color: #ffffff;">dval</span> = <span style="color: #b6a0ff;">static_cast</span>&lt;<span style="color: #6ae4b9;">double</span>&gt;<span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span> / y;
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">ival</span> = <span style="color: #b6a0ff;">static_cast</span>&lt;<span style="color: #6ae4b9;">int</span>&gt;<span style="color: #ffffff;">(</span>dval<span style="color: #ffffff;">)</span>;

   <span style="color: #b6a0ff;">enum</span> <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">Pos</span> <span style="color: #ffffff;">{</span> <span style="color: #ffffff;">off</span>, <span style="color: #ffffff;">on</span>, <span style="color: #ffffff;">hold</span> <span style="color: #ffffff;">}</span>;
   <span style="color: #6ae4b9;">Pos</span> <span style="color: #ffffff;">pos</span> = <span style="color: #00bcff;">Pos</span>::off;
   ival = <span style="color: #b6a0ff;">static_cast</span>&lt;<span style="color: #6ae4b9;">int</span>&gt;<span style="color: #ffffff;">(</span>pos<span style="color: #ffffff;">)</span>;
</pre>
</div>

<p>
Example for <code>const_cast</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">char</span>* <span style="color: #feacd0;">mystrchr</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">char</span>* <span style="color: #ffffff;">p</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">c</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #feacd0;">while </span><span style="color: #ffffff;">(</span>*p<span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
       <span style="color: #feacd0;">if </span><span style="color: #ffffff;">(</span>*p == c<span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #b6a0ff;">return</span> <span style="color: #b6a0ff;">const_cast</span>&lt;<span style="color: #6ae4b9;">char</span>*&gt;<span style="color: #ffffff;">(</span>p<span style="color: #ffffff;">)</span>;
       <span style="color: #ffffff;">}</span>
       ++p;
       <span style="color: #ffffff;">}</span>

       <span style="color: #feacd0;">if </span><span style="color: #ffffff;">(</span>c == <span style="color: #79a8ff;">'\0'</span><span style="color: #ffffff;">)</span>
       <span style="color: #b6a0ff;">return</span> <span style="color: #b6a0ff;">const_cast</span>&lt;<span style="color: #6ae4b9;">char</span>*&gt;<span style="color: #ffffff;">(</span>p<span style="color: #ffffff;">)</span>;

       <span style="color: #b6a0ff;">return</span> <span style="color: #00bcff;">nullptr</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
Example for <code>reinterpret_cast</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">double</span> <span style="color: #ffffff;">dval</span> = <span style="color: #00bcff;">451.2356</span>;
   <span style="color: #6ae4b9;">char</span>* <span style="color: #ffffff;">p</span> = <span style="color: #b6a0ff;">reinterpret_cast</span>&lt;<span style="color: #6ae4b9;">char</span>*&gt;<span style="color: #ffffff;">(</span>&amp;dval<span style="color: #ffffff;">)</span>;

   <span style="color: #feacd0;">for </span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9;">size_t</span> <span style="color: #ffffff;">i</span><span style="color: #ffffff;">{}</span>; i &lt; <span style="color: #feacd0;">sizeof</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">double</span><span style="color: #ffffff;">)</span>; ++i<span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; p<span style="color: #ffffff;">[</span>i<span style="color: #ffffff;">]</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
Example for <code>dynamic_cast</code>:
 Will be explained later.
 &#x2026;
</p>
</div>
<div id="outline-container-org69878d0" class="outline-4">
<h4 id="org69878d0">Why C-style type cast is not enough?</h4>
<div class="outline-text-4" id="text-org69878d0">
<p>
Different <code>explicit type conversions</code> can have different intentions and meanings. There can be many different reasons for converting one type to another type:
</p>
<ul class="org-ul">
<li><code>Explicit type conversion</code> can be used to indicate that there will be data loss and that this is not a problem.</li>
<li><code>Explicit type conversion</code> can be used to convert <code>const T*</code> to <code>T*</code>, if we know the actual object is not a <code>const</code> object.</li>
<li><code>Explicit type conversion</code> can be used to convert <code>T*</code> to <code>char*</code>, to use the actual object as a char array.</li>
</ul>

<p>
The list can be extended with different examples, but the point is that not every <code>explicit type conversion</code> has the same intention/meaning. The syntax of <code>C-style type cast</code> is very simple, but it is not sufficient to explain the intention of the conversion.
</p>
</div>
</div>
</div>
<div id="outline-container-orgf8b7760" class="outline-3">
<h3 id="orgf8b7760">Function Overloading</h3>
<div class="outline-text-3" id="text-orgf8b7760">
<p>
In C++, multiple functions can have the same name but with different parameters. These functions can perform different tasks based on the parameters passed to them. The compiler differentiates between the overloaded functions by their number of parameters, types of parameters, and the order of parameters. When the compiler encounters a call to an overloaded function, it uses the argument types and number of arguments to determine which version of the overloaded function to invoke. This process, called <code>static/early binding</code> or <code>compile-time polymorphism</code>, happens at compile-time, meaning the function to be executed is determined before the program runs. Function overloading is all about compile-time, it has no run-time overhead. For function overloading, there are 2 different and important points for the compiler to decide. Is there a function overloading for the particular function and if so, which function to choose. The process by the compiler to decide which function to choose is called <code>function overload resolution</code>.
</p>

<p>
To talk about function overloading, there are 3 different things to consider:
</p>
<ul class="org-ul">
<li>Function names have to be the same.</li>
<li>Function signatures have to be different.</li>
<li>Functions have to be in the same scope.
<ul class="org-ul">
<li>namespace scope</li>
<li>class scope</li>
<li>block scope</li>
</ul></li>
</ul>

<p>
If one function is in <code>namespace scope</code> and the other is in <code>block scope</code>, even if they have the same name, it will not cause function overloading. It causes <code>name shadowing</code> instead:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">double</span><span style="color: #ffffff;">)</span>;

       <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">5</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">There is no funcion overloading. foo(double) will be called due to name shadowing.</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
In order to do function overloading, functions must have different signatures. <code>return</code> type is not part of the signature:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">double</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is invalid, syntax error.</span>
</pre>
</div>

<p>
This is valid function overloading. Same function names, in the same scope and different signatures.
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
</pre>
</div>

<p>
<code>Default function arguments</code> do not effect <code>function signature</code>. These functions still have different signatures and this is valid <code>function overloading</code>. We don't talk about what happens when we call the function <code>foo()</code> with only one argument. It is about <code>function overload resolution</code>.
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span> = <span style="color: #00bcff;">0</span><span style="color: #ffffff;">)</span>;
</pre>
</div>

<p>
If the parameter itself is <code>const</code> (<code>top-level const</code>) it doesn't effect <code>function signature</code>. No <code>function overloading</code> here, it is <code>function redeclaration</code>;
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid, no overload. Function redeclaration.</span>

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">double</span>* <span style="color: #b6a0ff;">const</span> <span style="color: #ffffff;">p</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">double</span>* <span style="color: #ffffff;">p</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid, no overload. Function redeclaration</span>
</pre>
</div>

<p>
<code>const T*</code> is a different type than <code>T*</code>. <code>Low-level const</code> changes <code>function signature</code>. This is valid <code>function overloading</code> and mostly called <code>const overload</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>*<span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span>*<span style="color: #ffffff;">)</span>;
</pre>
</div>

<p>
<code>const T&amp;</code> is a different type than <code>T&amp;</code>. This is valid <code>function overloading</code> and it is commonly used:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>&amp;<span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span>&amp;<span style="color: #ffffff;">)</span>;
</pre>
</div>

<p>
A Type alias doesn't mean a different type than the underlying type. No <code>function oveloading</code> here:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">typedef</span> <span style="color: #6ae4b9;">double</span> <span style="color: #6ae4b9;">flt_type</span>;

   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">double</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">flt_type</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid, no overload. Function redeclaration.</span>
</pre>
</div>

<p>
<code>char</code>, <code>unsigned char</code> and <code>signed char</code> are 3 different distinct types. There are 3 <code>function overload</code> here:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">char</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">signed</span> <span style="color: #6ae4b9;">char</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">unsigned</span> <span style="color: #6ae4b9;">char</span><span style="color: #ffffff;">)</span>;
</pre>
</div>

<p>
There are 3 <code>function overloads</code> here:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>*<span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>**<span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>***<span style="color: #ffffff;">)</span>;
</pre>
</div>

<p>
L-value reference and R-value reference. This is valid <code>function overloading</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>&amp;<span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>&amp;&amp;<span style="color: #ffffff;">)</span>;
</pre>
</div>

<p>
There are 3 overloads:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>&amp;<span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span>&amp;<span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>&amp;&amp;<span style="color: #ffffff;">)</span>;
</pre>
</div>

<p>
We can't say there is <code>function overload</code> or not. This is <code>implementation defined</code>, <code>std::int32_t</code> is not a distinct type but a type alias and underlying type is dependent to the compiler:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">If std::int32_t is alias to int. This is function redeclaration.</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">If std::int32_t is alias to long. This is valid function overload.</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">std</span>::int32_t<span style="color: #ffffff;">)</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is valid function overload. std::int32_t and std::int16_t cannot be alias of the same type.</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">std</span>::int32_t<span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">std</span>::int16_t<span style="color: #ffffff;">)</span>;
</pre>
</div>

<p>
If array notation used in function declaration, array decay happens. There is no <code>function overloading</code> here:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">p</span><span style="color: #ffffff;">[])</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Decays to foo(int*);</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">p</span><span style="color: #ffffff;">[</span><span style="color: #00bcff;">20</span><span style="color: #ffffff;">])</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Decays to foo(int*); Function redeclaration.</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>* <span style="color: #ffffff;">p</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">foo(int*); Function redeclaration.</span>
</pre>
</div>

<p>
If a function takes function as a parameter. It decays to function pointer. No <code>function overloading</code> here:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">))</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Decays to foo(int (*)(int));</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">(</span>*<span style="color: #ffffff;">)(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">))</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Function redeclaration.</span>
</pre>
</div>

<p>
There are 4 different <code>function overloads</code> here:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #feacd0;"> </span><span style="color: #ffffff;">(</span>*<span style="color: #ffffff;">)[</span><span style="color: #00bcff;">5</span><span style="color: #ffffff;">])</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int(*)[5]; a pointer to int[5]</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #feacd0;"> </span><span style="color: #ffffff;">(</span>*<span style="color: #ffffff;">)[</span><span style="color: #00bcff;">6</span><span style="color: #ffffff;">])</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int(*)[6]; a pointer to int[6]</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #feacd0;"> </span><span style="color: #ffffff;">(</span>*<span style="color: #ffffff;">)[</span><span style="color: #00bcff;">7</span><span style="color: #ffffff;">])</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int(*)[7]; a pointer to int[7]</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #feacd0;"> </span><span style="color: #ffffff;">(</span>*<span style="color: #ffffff;">)[</span><span style="color: #00bcff;">8</span><span style="color: #ffffff;">])</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int(*)[8]; a pointer to int[8]</span>
</pre>
</div>
</div>
<div id="outline-container-org41a5942" class="outline-4">
<h4 id="org41a5942">Function overload resolution</h4>
<div class="outline-text-4" id="text-org41a5942">
<p>
<code>Function overload resolution</code> is handled by the compiler as a 3 step process. Actually, 3 steps is the maximum, it may take fewer steps:
</p>
<ul class="org-ul">
<li>Choosing <code>candidate functions</code>.
<ul class="org-ul">
<li>In this step, the compiler doesn't check function arguments but marks the visible functions in the same scope which has the same name.</li>
</ul></li>
<li>Choosing <code>viable functions</code>.
<ul class="org-ul">
<li>The compiler checks each <code>candidate function</code> too see if it can be called with the arguments we passed it without syntax errors. If there are no syntax errors, the compiler marks that function. These marked functions are called <code>viable functions</code>. After this step, all functions that are not suitable for calling are eliminated and only those functions that can be called legally remain.</li>
<li>In this step, the compiler determines the <code>viable functions</code> depending on passed arguments. The number of arguments, the types of arguments, the default function arguments and the implicit conversion rules between types all are very important in this step.</li>
<li>More than one function overload does not guarantee that a call with this name is valid. None of the function overloads may be <code>viable functions</code>, this is called <code>no match</code>.</li>
</ul></li>
<li>Choosing the <code>best viable function</code>.
<ul class="org-ul">
<li>If there are more than one <code>viable function</code>, the compiler will decide which one is the <code>best match</code> based on the rules of the language.</li>
<li>There may be more than one <code>viable function</code> among which the compiler cannot decide which one to choose, because there are no selection criteria in terms of the rules of the language, this is called <code>ambiguity</code>.</li>
</ul></li>
</ul>

<p>
Rules for choosing the <code>best viable function</code> / <code>best match</code>:
</p>
<ul class="org-ul">
<li><code>variadic conversion</code> always loses if there are any other alternatives.</li>
<li><code>user-defined conversion</code> always loses except when the alternative is <code>variadic conversion</code>.
<ul class="org-ul">
<li>If there are more than one <code>viable function</code> with <code>user-defined conversion</code>, this might cause an <code>ambiguity</code> error, if there is no better alternative (<code>standard converion</code>).</li>
</ul></li>
<li><code>standard/implicit conversion</code> always wins except when the other alternatives are also <code>standart conversion</code>. There are different rules for this case.
<ul class="org-ul">
<li><code>exact match</code> always wins over <code>promotion</code>.
<ul class="org-ul">
<li>When the function parameters and the arguments are the same.</li>
<li><code>implicit conversion</code> from <code>T*</code> to <code>const T*</code>.</li>
<li><code>array to pointer conversion</code> / <code>Array decay</code>.</li>
<li><code>function to pointer conversion</code>.</li>
</ul></li>
<li><code>promotion</code> always wins over <code>conversion</code>.
<ul class="org-ul">
<li><code>integral promotion</code> (types which have lower rank than <code>int</code> are promoted to <code>int</code>),</li>
<li><code>float to double promotion</code></li>
</ul></li>
<li><code>conversion</code> always wins over <code>user-defined conversion</code>.
<ul class="org-ul">
<li><code>conversion</code> between different types which is not <code>promotion</code>. (<code>char</code> to <code>double</code>, <code>double</code> to <code>int</code> etc.)</li>
</ul></li>
</ul></li>
</ul>

<p>
Functions with multiple parameters can also be overloaded. In this case, one of the <code>function overloads</code> must be win over to the others in at least one parameter and must be at least equal (shouldn't be weaker) in the other parameters.
</p>

<p>
From weaker <code>viable function</code> to stronger:
 <code>variadic conversion</code> &lt; <code>user-defined conversion</code> &lt; <code>standard conversion</code> &lt; <code>standard promotion</code> &lt; <code>exact match</code>
</p>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">double</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">long</span><span style="color: #ffffff;">)</span>;

   <span style="color: #feacd0;">f</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">3.4</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">f(double) will be called, exact match.</span>
   <span style="color: #feacd0;">f</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">12</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">f(int) will be called, exact match.</span>
   <span style="color: #feacd0;">f</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">12u</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">unsigned int can be converted to int, double and long. Three different standard conversion causes ambiguity.</span>
   <span style="color: #feacd0;">f</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">true</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">f(int) will be called, bool to int is integral promotion and promotion wins over conversion.</span>
   <span style="color: #feacd0;">f</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">2.3L</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">long double can be converted to int, double and long. Three different standard conversion causes ambiguity.</span>
   <span style="color: #feacd0;">f</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">2.3f</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">f(double) will be called, float to double promotion.</span>
   <span style="color: #feacd0;">f</span><span style="color: #ffffff;">(</span><span style="color: #79a8ff;">'A'</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">f(int) will be called, integral promotion from char to int.</span>
</pre>
</div>

<p>
If one of the <code>viable functions</code> takes <code>T*</code> and the other one takes <code>const T*</code>, this is called <code>const overloading</code> and means both of them are <code>exact match</code>. If the argument type is <code>const T*</code>, <code>const T*</code> will be called, otherwise <code>T*</code> will be called. This is also valid for references.
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>*<span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span>*<span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>&amp;<span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span>&amp;<span style="color: #ffffff;">)</span>;

   <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">cx</span> = <span style="color: #00bcff;">5</span>;
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">5</span>;

   <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span>&amp;cx<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">f1(const int*) will be called.</span>
   <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span>&amp;x<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">f1(int*) will be called.</span>

   <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span>&amp;cx<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">f2(const int&amp;) will be called.</span>
   <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span>&amp;x<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">f2(int&amp;) will be called.</span>
</pre>
</div>

<p>
Default function arguments can cause <code>ambiguity</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span> = <span style="color: #00bcff;">0</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span>;

   <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">12</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">There are 2 valid oveloads of func but the compiler cannot decide between them. Ambiguity error.</span>
</pre>
</div>

<p>
Having 2 different <code>function overloads</code> for <code>call by value</code> and <code>call by reference</code> can cause <code>ambiguity</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span>;

   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;

   <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid, ambigious call.</span>
   <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid, func(x) will be called.</span>
   <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid, ambigious call.</span>
   <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid, ambigious call.</span>
</pre>
</div>

<p>
Using C-style null pointer can cause <code>ambiguity</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">double</span>*<span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Let's say the intention was to call func(double*) with null pointer and then we added a new overload func(int). This code will not give any error and call to func(int), because it will be exact match. If we really want to call func(double*) with null pointer we should use nullptr.</span>
   <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">0</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid, func(int) will be called.</span>
   <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">nullptr</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid, func(double*) will be called.</span>
</pre>
</div>

<p>
We can choose the overload we want to call by using <code>explicit cast</code>. We can also use <code>name shadowing</code> to call the function we want by <code>redeclaring</code> it in the current scope.
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">double</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">long</span><span style="color: #ffffff;">)</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;

       <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">static_cast</span>&lt;<span style="color: #6ae4b9;">double</span>&gt;<span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">))</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">func(double) will be called.</span>

    <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This function redeclaration causes name shadowing. From this point on, every call to func in this scope will be call to func(long).</span>
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">long</span><span style="color: #ffffff;">)</span>;

       <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">func(long) will be called.</span>
       <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">2.3</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">func(long) will be called.</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
When one of the overloads is <code>bool</code> and the other is <code>void*</code>, this should normally cause <code>ambiguity</code> when called with pointer types, but this is an exception and the <code>void*</code> one will be called:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">bool</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">void</span>*<span style="color: #ffffff;">)</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">{}</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Implicit conversion from int* to bool and from int* to void* exist. Normally, this should cause ambiguity but this is a special case and func(void*) will be called.</span>
   <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span>&amp;x<span style="color: #ffffff;">)</span>;
</pre>
</div>

<p>
We can call <code>L-value reference</code> overloads with <code>L-value expressions</code>, and <code>R-value reference</code> overloads with <code>R-value expressions</code>. Normally, <code>const L-value reference</code> and <code>R-value reference</code> both can be called with <code>R-value expressions</code> but this doesn't cause <code>ambiguity</code>. The function which takes an <code>R-value reference</code> will be called in this case:
</p>
<div class="org-src-container">
<pre class="src src-C++">     <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>&amp;<span style="color: #ffffff;">)</span>;
     <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>&amp;&amp;<span style="color: #ffffff;">)</span>;

     <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span>&amp;<span style="color: #ffffff;">)</span>;
     <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>&amp;&amp;<span style="color: #ffffff;">)</span>;

     <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">{}</span>;

     <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid, 10 is R-value expression, f1(int&amp;&amp;) will be called.</span>
     <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid, x is L-value expression, f1(int&amp;) will be called.</span>

     <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid, x is L-value expression, f2(const int&amp;) will be called.</span>
     <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid, 10 is R-value expression, normally f2(const int&amp;) and f2(int&amp;&amp;) both</span>
     <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">can be called with a R-value expression but this does not cause ambiguity. f2(int&amp;&amp;) will be called.</span>
     <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>;
</pre>
</div>

<p>
<code>Data type</code> (<code>declaration type</code>) and <code>value category</code> are not the same thing. Variables/declarations don't have a <code>value category</code> but <code>data type</code>, we need to have an <code>expression</code> to talk about <code>value category</code>. We can observe it in this example:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #ff7f86;">   #include</span> <span style="color: #79a8ff;">&lt;iostream&gt;</span>

   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">bar</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #00bcff;">3</span>;
   <span style="color: #ffffff;">}</span>

   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">bar</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>&amp;&amp; <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #00bcff;">4</span>;
   <span style="color: #ffffff;">}</span>

   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #00bcff;">1</span>;
       <span style="color: #feacd0;">bar</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>

   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>&amp;&amp; <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #00bcff;">2</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The data/declaration type of x is int&amp;&amp; but the value category of x when used in an expression is L-value</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">so bar(int&amp;) will be called.</span>
       <span style="color: #feacd0;">bar</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;

       <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Output: 13</span>
       <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Output: 23</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
We were always using one paramater for <code>function oveloads</code>, but functions with multiple parameters can also be overloaded. In this case, one of the <code>function overloads</code> must win over to the others in at least one parameter and must be at least equal in the other parameters.
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">double</span>, <span style="color: #6ae4b9;">long</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">1</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">char</span>, <span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">double</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">2</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">long</span>, <span style="color: #6ae4b9;">unsigned</span> <span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">float</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">3</span>

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Function 1 will be chosen. The 1st parameter of function 1 wins over the 1st parameter of function 2 and 3, because it is exact match. 2nd and 3rd parameter is equal for functions 1, 2 and 3, because all of them are standart conversion.</span>
   <span style="color: #feacd0;">f</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">12</span>, <span style="color: #00bcff;">4L</span>, <span style="color: #00bcff;">1</span><span style="color: #ffffff;">)</span>;
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Function 2 will be chosen. The 2nd parameter of function 2 wins over the 2nd parameter of function 1 and 3, because it is standard promotion. 1st and 3rd parameter is equal for functions 1, 2 and 3, because all of them are standart conversion.</span>
   <span style="color: #feacd0;">f</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">2.3</span>, <span style="color: #00bcff;">true</span>, <span style="color: #00bcff;">12</span><span style="color: #ffffff;">)</span>;
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Function 3 will be chosen. The 1st parameter of function 3 wins over the 1st parameter of function 1 and 2, because it is exact match. 2nd and 3rd parameter is equal for functions 1, 2 and 3, because all of them are standart conversion.</span>
   <span style="color: #feacd0;">f</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">34L</span>, <span style="color: #00bcff;">3.5L</span>, <span style="color: #00bcff;">12</span><span style="color: #ffffff;">)</span>;
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This causes ambiguity. The 1st parameter of function 1 has exact match, but the 2nd parameter of the function 2 also has exact match. The 3rd parameters have standard conversion. There are 2 exact matches for different function overloads, in this case the compiler cannot decide. One of the overloads must win over others at least on one parameter, and at least be equal on the other parameters.</span>
   <span style="color: #feacd0;">f</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">12</span>, <span style="color: #00bcff;">12</span>, <span style="color: #00bcff;">12</span><span style="color: #ffffff;">)</span>;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6b1ea2d" class="outline-3">
<h3 id="org6b1ea2d">Name Mangling</h3>
<div class="outline-text-3" id="text-org6b1ea2d">
<p>
<code>Name mangling</code> is a process used by C++ compilers to generate unique names for functions, variables, and other entities to support features like <code>function overloading</code>, <code>namespaces</code>, and <code>template instantiation</code>. Since C++ allows multiple functions with the same name (through <code>function overloading</code>), the compiler needs a way to differentiate between these functions at the binary level. <code>Name mangling</code> achieves this by encoding additional information, such as the function's <code>parameter types</code>, <code>return type</code>, and the <code>namespace</code> or <code>class</code> it belongs to, into the function's name. 
</p>

<p>
<code>Name mangling</code> can cause some problems when we call a C function from a C++ source. An example of a problem caused by <code>name mangling</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">test.h</span>
   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">test.c</span>
   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #b6a0ff;">return</span> x + <span style="color: #00bcff;">1</span>;
   <span style="color: #ffffff;">}</span>

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">main.cpp</span>
<span style="color: #ff7f86;">   #include</span> <span style="color: #79a8ff;">"test.h"</span>

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This code will be built successfully but will not be linked. The</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">linker program will not find func(int) because the C++ compiler</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">will produce a mangled/decorated name for func(int), but it is a</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C function. The name produced by the C compiler will not match</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">the name produced by the C++ compiler, because there is no name</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">mangling in C.</span>
       <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">x</span> = <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">20</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
To solve this kind of problems we typically use <code>extern "C"</code> declaration with <code>conditional compiling</code>. By doing this we can use the same <code>header file</code> for both C and C++.
</p>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">test.h</span>
<span style="color: #ff7f86;">   #ifdef</span> __cplusplus
   <span style="color: #b6a0ff;">extern</span> <span style="color: #79a8ff;">"C"</span> <span style="color: #ffffff;">{</span> <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">open extern "C" block.</span>
<span style="color: #ff7f86;">   #endif</span>

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;

<span style="color: #ff7f86;">   #ifdef</span> __cplusplus
   <span style="color: #ffffff;">}</span> <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">close extern "C" block.</span>
<span style="color: #ff7f86;">   #endif</span>

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">test.c</span>
   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #b6a0ff;">return</span> x + <span style="color: #00bcff;">1</span>;
   <span style="color: #ffffff;">}</span>

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">main.cpp</span>
<span style="color: #ff7f86;">   #include</span> <span style="color: #79a8ff;">"test.h"</span>

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This code will be built and linked successfully. The</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">compiler won't generate mangled names for func(int)</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">because its declaration is inside of an extern "C" block.</span>
       <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">x</span> = <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">20</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfa343fc" class="outline-3">
<h3 id="orgfa343fc">One Definition Rule (ODR)</h3>
<div class="outline-text-3" id="text-orgfa343fc">
<p>
Objects (variables, functions, templates, classes etc.) in C++ can have multiple declarations but only one definition across the project. This is called <code>one definition rule</code>. If a program has more than one definition of a particular object, the program is <code>ill-formed</code> and the compiler isn't required to give any diagnostics. The linker program may give some diagnostics but it is also not guaranteed. If the same object has multiple definitions in the same source file, it is a syntax error and diagnostic is required.
</p>

<p>
Some examples:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">test.h</span>
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">If test.h is to be included from multiple source files, this is against the ODR because variable x will have multiple definitions.</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C++">  <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">test.h</span>
  <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
  <span style="color: #ffffff;">{</span>
  <span style="color: #ffffff;">}</span>
  <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">If test.h is to be included from multiple source files, this is against the ODR because func() will have multiple definitions.</span>
</pre>
</div>

<p>
When an <code>inline function</code> in a <code>header file</code> is included from multiple source files, this isn't against the <code>ODR</code> and but every source file will have its own definition for that particular function.
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">test.h</span>
  <span style="color: #b6a0ff;">static</span> <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
  <span style="color: #ffffff;">{</span>
  <span style="color: #ffffff;">}</span>
  <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">If test.h is to be included from multiple source files, this is not against the ODR because func() will be in internal linkage. Every source file will have its own func().</span>
</pre>
</div>

<p>
There are such objects that can have more than one definition in different source files but do not violate the <code>ODR</code>, but their definitions must be the same <code>token-by-token</code>. This is very important because in practice it means that the definitions of these objects can be in <code>header files</code>.
Definitions that can coexist in different source files without violating ODR:
</p>
<ul class="org-ul">
<li><code>class definitions</code></li>
<li><code>inline function definitions</code></li>
<li><code>inline variable definitions</code> (C++17)</li>
<li><code>constexpr functions</code></li>
<li><code>constexpr variables</code></li>
<li><code>class templates</code></li>
<li><code>function templates</code></li>
</ul>
</div>
</div>
<div id="outline-container-orgb1677a5" class="outline-3">
<h3 id="orgb1677a5">Inline functions</h3>
<div class="outline-text-3" id="text-orgb1677a5">
<p>
Functions defined with the <code>inline</code> keyword are called <code>inline functions</code>, meaning that they will not violate the <code>ODR</code>. This means we can define <code>inline functions</code> in <code>header files</code>. <code>inline functions</code> are not directly related with the <code>inline expansion</code>. <code>inline expansion</code> is an old and effective optimization method often used by compilers. In a nutshell, this means that instead of calling a function, the compiler embeds the code for that function directly into the source code, depending on the different parameters. The main purpose of defining an <code>inline function</code> using the <code>inline</code> keyword is not to allow the compiler to do <code>inline expansion</code> but to avoid violating <code>ODR</code>. Unless a special compiler flag is used, it is up to the compiler to decide whether to do <code>inline expansion</code> or not.
</p>

<p>
When an <code>inline function</code> in a <code>header file</code> is included from multiple source files, this is not against the <code>ODR</code> and there will be only one definition from the compiler perspective even it is included in multiple source files unlike <code>static</code> functions.
</p>

<div class="org-src-container">
<pre class="src src-C++">  <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">test.h</span>
  <span style="color: #b6a0ff;">inline</span> <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
  <span style="color: #ffffff;">{</span>
  <span style="color: #ffffff;">}</span>
  <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">If test.h is to be included from multiple source files, this is not against the ODR. There will be only one func() even it is included in multiple source files.</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org3588f28" class="outline-3">
<h3 id="org3588f28">Inline variables</h3>
<div class="outline-text-3" id="text-org3588f28">
<p>
Variables defined with the <code>inline</code> keyword are called <code>inline variables</code>, meaning that they will not violate the <code>ODR</code> similar to <code>inline functions</code>. <code>Inline variables</code> were added in C++17. When an <code>inline variable</code> in a <code>header file</code> is included from multiple source files, this is not against the <code>ODR</code> and there will be only one definition from the compiler perspective even it is included in multiple source files.
</p>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">test.h</span>
   <span style="color: #b6a0ff;">inline</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">If test.h is to be included from multiple source files, this is not against the ODR. There will be only one x even it is included in multiple source files.</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org2faa43b" class="outline-3">
<h3 id="org2faa43b">constexpr</h3>
<div class="outline-text-3" id="text-org2faa43b">
</div>
<div id="outline-container-org77ce377" class="outline-4">
<h4 id="org77ce377">constexpr variables</h4>
<div class="outline-text-4" id="text-org77ce377">
<p>
In C++, variables defined with the <code>const</code> keyword can be initialized with const and non-const expressions:
</p>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">These are valid definitions, const objects can be initialized with const and non-const expressions.</span>
   <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;
   <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span> = <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">arr1</span><span style="color: #ffffff;">[</span>x<span style="color: #ffffff;">]</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is valid because x is initialized with a const expression (10) which means expression created by x is also const expression.</span>
   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">arr2</span><span style="color: #ffffff;">[</span>y<span style="color: #ffffff;">]</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is invalid because y is initialized with a non-const expression (foo()) which means expression created by y is also non-const expression.</span>
</pre>
</div>

<p>
But, variables defined with the <code>constexpr</code> keyword has to be initialized with a constant expression:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

   <span style="color: #b6a0ff;">constexpr</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is valid. 10 is constant expression.</span>
   <span style="color: #b6a0ff;">constexpr</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span> = <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is invalid. foo() is non-const expression.</span>
</pre>
</div>

<p>
Variables defined with the <code>constexpr</code> keyword has <code>const</code> declaration type:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">constexpr</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;

   x = <span style="color: #00bcff;">5</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is invalid because x is const.</span>
   <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This equals to const int.</span>

   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">g</span><span style="color: #ffffff;">{}</span>;

   <span style="color: #b6a0ff;">constexpr</span> <span style="color: #6ae4b9;">int</span>* <span style="color: #ffffff;">p</span> = &amp;g;
   <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span>p<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This equals to int* const p;</span>

   <span style="color: #b6a0ff;">constexpr</span> <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span>* <span style="color: #ffffff;">t</span> = &amp;g;
   <span style="color: #feacd0;">decltype</span><span style="color: #ffffff;">(</span>t<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This equals to const int* const t;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org60f4ea5" class="outline-4">
<h4 id="org60f4ea5">constexpr functions</h4>
<div class="outline-text-4" id="text-org60f4ea5">
<p>
<code>constexpr</code> functions are functions whose return value is obtained at compile time when certain conditions are met. If <code>constexpr</code> functions are called with non-const arguments, the return value will be calculated at runtime like normal functions.
</p>

<p>
Some restrictions when defining <code>constexpr</code> functions:
</p>
<ul class="org-ul">
<li>Cannot define <code>static</code> local variables.</li>
<li>Cannot be a virtual function.</li>
<li>Return type cannot be <code>void</code>.</li>
<li>Return type, types of all local variables and types of arguments must be <code>literal type</code>.</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">constexpr</span> <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">sum_square</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">a</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">b</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #b6a0ff;">return</span> a * a + b * b;
   <span style="color: #ffffff;">}</span>

   <span style="color: #b6a0ff;">constexpr</span> <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">ndigit</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">digit_count</span> = <span style="color: #00bcff;">0</span>;

       <span style="color: #feacd0;">if </span><span style="color: #ffffff;">(</span>x == <span style="color: #00bcff;">0</span><span style="color: #ffffff;">)</span>
       <span style="color: #b6a0ff;">return</span> <span style="color: #00bcff;">1</span>;

       <span style="color: #feacd0;">while </span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
       ++digit_count;
       x /= <span style="color: #00bcff;">10</span>;
       <span style="color: #ffffff;">}</span>

      <span style="color: #b6a0ff;">return</span> digit_count;
   <span style="color: #ffffff;">}</span>

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">a</span> = <span style="color: #00bcff;">87234</span>;
       <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">b</span> = <span style="color: #00bcff;">7624271</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">These will be calculated at compile time and the generated return values are also constant expression. </span>
       <span style="color: #b6a0ff;">constexpr</span> <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">x</span> = <span style="color: #feacd0;">sum_square</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">10</span>, <span style="color: #00bcff;">20</span><span style="color: #ffffff;">)</span>; 
       <span style="color: #b6a0ff;">constexpr</span> <span style="color: #b6a0ff;">auto</span> <span style="color: #ffffff;">y</span> = <span style="color: #feacd0;">sum_square</span><span style="color: #ffffff;">(</span><span style="color: #feacd0;">ndigit</span><span style="color: #ffffff;">(</span>a<span style="color: #ffffff;">)</span> + <span style="color: #feacd0;">ndigit</span><span style="color: #ffffff;">(</span>b<span style="color: #ffffff;">))</span>;

       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">j</span> = <span style="color: #00bcff;">1515</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is valid. j is not const and because of that ndigit(j) will be called at runtime.</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">k</span> = <span style="color: #feacd0;">ndigit</span><span style="color: #ffffff;">(</span>j<span style="color: #ffffff;">)</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is invalid. j is not const and because of that ndigit(j) will be called at runtime. This means generated return value also will be non-const and constexpr variables cannot be initialized with non-const expressions.</span>
       <span style="color: #b6a0ff;">constexpr</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">l</span> = <span style="color: #feacd0;">ndigit</span><span style="color: #ffffff;">(</span>j<span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org561f0c2" class="outline-3">
<h3 id="org561f0c2">Classes</h3>
<div class="outline-text-3" id="text-org561f0c2">
<p>
The use of classes in C++ is not limited to object-oriented programming. Classes are the main tools for data abstraction also beyond object-oriented programming.
</p>
</div>
<div id="outline-container-orgf5b92e0" class="outline-4">
<h4 id="orgf5b92e0">Class definition</h4>
<div class="outline-text-4" id="text-orgf5b92e0">
<p>
Classes are <code>user-defined types</code> that can have <code>data members</code>, <code>member functions</code> and <code>type member / member type / nested type</code>. They are defined/declared with the keywords <code>class</code> and <code>struct</code> (note that unlike C, <code>struct</code> is also a class).
A class definition gives the compiler all the information about that class. It is also possible to declare a class without defining it. In this case, the compiler cannot get all the information about the class from the class declaration. All it knows is that the class is declared and that it must get all the necessary information about this class from the definition which can be in another source file. 
</p>

<p>
Members of the classes can be taxonomically listed as follows:
</p>
<ul class="org-ul">
<li><code>class members</code>
<ul class="org-ul">
<li><code>data members</code>
<ul class="org-ul">
<li><code>non-static data members</code></li>
<li><code>static data members</code></li>
</ul></li>
<li><code>member functions</code>
<ul class="org-ul">
<li><code>non-static member functions</code></li>
<li><code>static member functions</code></li>
</ul></li>
<li><code>type member / member type / nested type</code></li>
</ul></li>
</ul>

<p>
Defining and declaring classes:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Class declaration / Forwarding declaration. In this point, C1 is incomplete class. The compiler doesn't know anything but just the name of it. </span>
   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Class types can be empty. If a class is empty, it is called empty class.</span>
   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C2</span> <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Class definition</span>
   <span style="color: #ffffff;">{</span>

   <span style="color: #ffffff;">}</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">In C++ when we say class we also mean struct because structs are also class type.</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Note: Empty structs are invalid in C.</span>
   <span style="color: #b6a0ff;">struct</span> <span style="color: #6ae4b9;">C3</span> <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Class definition</span>
   <span style="color: #ffffff;">{</span>

   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
Classes can have different type of <code>class members</code> in the <code>class scope</code>.
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span> 
   <span style="color: #ffffff;">{</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Data members</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Member functions</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Type member / Member type / Nested type</span>
   <span style="color: #ffffff;">}</span>;

  <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C2</span>
  <span style="color: #ffffff;">{</span>
      <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mx</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Data member</span>
      <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Member function</span>
      <span style="color: #b6a0ff;">enum</span> <span style="color: #6ae4b9;">Pos</span><span style="color: #ffffff;">{</span> <span style="color: #ffffff;">ON</span>, <span style="color: #ffffff;">OFF</span> <span style="color: #ffffff;">}</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Member type</span>
  <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
If a class will be used also in other source files, the definition can be placed in a header file. It is not against the ODR.
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">test.h</span>
   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">a</span>, <span style="color: #ffffff;">b</span>;
       <span style="color: #6ae4b9;">double</span> <span style="color: #ffffff;">d1</span>, <span style="color: #ffffff;">d2</span>;
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">main.cpp</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">#include "test.h"</span>
   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>;

       <span style="color: #b6a0ff;">return</span> <span style="color: #00bcff;">0</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org1a46a1e" class="outline-4">
<h4 id="org1a46a1e">Access control</h4>
<div class="outline-text-4" id="text-org1a46a1e">
<p>
Normally, when an identifier is used, the compiler performs a name lookup to find out what object that name represents, but in C++ (also in other languages which supports OOP style programming) there is one more step after the name lookup. The compiler must check that the code trying to access an identifier has permission to access that identifier. This is called <code>access control</code>.
</p>

<p>
There are 3 different access categories that apply to the members of classes and determine who can and cannot access them. These 3 categories are actually also keywords and are called <code>access specifiers</code>:
</p>
<ul class="org-ul">
<li><code>public</code>
<ul class="org-ul">
<li><code>public class members</code> can be accessed both within the class itself and by clients using the class, meaning there is no access control for <code>public class members</code>.</li>
</ul></li>
<li><code>private</code>
<ul class="org-ul">
<li><code>private class members</code> can only be accessed within the class itself and cannot be used by external codes.</li>
</ul></li>
<li><code>protected</code>
<ul class="org-ul">
<li><code>protected class members</code> can be accessed within the class itself and from its derived classes.</li>
</ul></li>
</ul>

<p>
<code>access specifiers</code> can be used to define <code>access rights</code> for a group of <code>class members</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
  <span style="color: #ffffff;">{</span>
  <span style="color: #b6a0ff;">public</span>: <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Each class member will have public access right from here until the compiler sees another access specifier.</span>
      <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span>;
      <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span>;
      <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

  <span style="color: #b6a0ff;">private</span>:
      <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">z</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Each class member will have private access right from here until the compiler sees another access specifier.</span>
      <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

  <span style="color: #b6a0ff;">protected</span>: <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Same applies here.</span>
      <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">t</span>;
  <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
If a class type is defined with the <code>class</code> keyword, all of its <code>class members</code> are <code>private</code> by default:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">If no access specifier is used these class members are private by default.</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span>;
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">a</span>, <span style="color: #ffffff;">b</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
If a class type is defined with the <code>struct</code> keyword, all of its <code>class members</code> are <code>public</code> by default: 
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">struct</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">If no access specifier is used these class members are public by default.</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span>;
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">a</span>, <span style="color: #ffffff;">b</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
Same <code>access specifier</code> can be used multiple times:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:

   <span style="color: #b6a0ff;">private</span>:

   <span style="color: #b6a0ff;">public</span>:

   <span style="color: #b6a0ff;">private</span>:
   <span style="color: #ffffff;">}</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-org7ebbd02" class="outline-4">
<h4 id="org7ebbd02">Non-static data members</h4>
<div class="outline-text-4" id="text-org7ebbd02">
<p>
<code>non-static data members</code> are variables that are actually held within the object of a class, that is, they are variables of the object that is created of that class. 
</p>

<p>
When <code>non-static data members</code> are added to an object, the object's storage requirement will increase depending on the added members:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C2</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This will print 4 assuming int is 4 bytes.   </span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"sizeof(C1) = "</span> &lt;&lt; <span style="color: #feacd0;">sizeof</span><span style="color: #ffffff;">(</span>C1<span style="color: #ffffff;">)</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Empty classes are 1 byte.</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"sizeof(C2) = "</span> &lt;&lt; <span style="color: #feacd0;">sizeof</span><span style="color: #ffffff;">(</span>C2<span style="color: #ffffff;">)</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org98a13af" class="outline-4">
<h4 id="org98a13af">Non-static member functions</h4>
<div class="outline-text-4" id="text-org98a13af">
<p>
<code>non-static member functions</code> are no different from normal functions at the assembly level, they are just an abstraction that exists at the language layer. <code>non-static member functions</code> are functions defined in the <code>class definition</code>. They have an implicit <code>this</code> pointer that refers to the object on which they are called. <code>this</code> pointer allows them to access the object's <code>non-static data members</code> and other <code>non-static member functions</code>.
</p>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Non-static member functions have implicit ~this pointer~ which is the address of the caller object. The compiler sees it like void foo(C1* this, int);</span>

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mx</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Non-static data member</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>;    

       c1.<span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">12</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is similar to foo(&amp;c1, 12);</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
There are 2 different ways to define <code>non-static member functions</code>.
</p>

<p>
A <code>non-static member function</code> can be declared in the header file and defined it in the source file. If the signatures don't match it is a syntax error:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">fighter.h</span>
   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">Fighter</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">attack</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">Fighter</span>&amp;<span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">fighter.cpp</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">#include "fighter.h"</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #00bcff;">Fighter</span>::<span style="color: #feacd0;">attack</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">Fighter</span>&amp; <span style="color: #ffffff;">f</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>

   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
A <code>non-static member function</code> can be declared and defined directly in the <code>class definition</code>. When a <code>non-static member function</code> is defined like this, it is implicitly an <code>inline function</code>, meaning including it to multiple source file isn't against the <code>ODR</code>.
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">fighter.h</span>
   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">Fighter</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">attack</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">Fighter</span>&amp; <span style="color: #ffffff;">f</span><span style="color: #ffffff;">)</span> <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This equals to inline void attack(Fighter &amp;f);. Using inline explicity doesn't matter in this case.</span>
       <span style="color: #ffffff;">{</span>

       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
In this case, if the <code>inline</code> keyword is not used explicity in the declaration or definition, it is against the <code>ODR</code>.
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">fighter.h</span>
   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">Fighter</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">attack</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">Fighter</span>&amp; <span style="color: #ffffff;">f</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is not implicitly inline function because it doesn't have definition.</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is the definition of attack function but it is also in the header file. If we include this header file</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">from multiple source file it is agains the ODR. We should use the inline keyword explicitly in the declaration or definition</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">if we want to do this.</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #00bcff;">Fighter</span>::<span style="color: #feacd0;">attack</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">Fighter</span>&amp; <span style="color: #ffffff;">f</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
<code>unqualified identifiers</code> in the definition of a <code>non-static member function</code> are searched in this order:
</p>
<ul class="org-ul">
<li><code>block scope</code></li>
<li><code>enclosing block scopes</code> (there can be multiple <code>enclosing blocks</code>)</li>
<li><code>class scope</code></li>
<li><code>namespace scope</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">class.h</span>
   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span> <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">3</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mx</span>, <span style="color: #ffffff;">my</span>;
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">a</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">4</span>

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">class.c</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #00bcff;">C1</span>::<span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">2</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">a</span> = <span style="color: #00bcff;">0</span>;

       <span style="color: #feacd0;">if </span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">1</span><span style="color: #ffffff;">)</span> <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">1</span>
       <span style="color: #ffffff;">{</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">1 - x will be searched in this if block first. From x to beginning of if block.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">2 - x will be searched in the enclosing block (function block in this case) if it couldn't be found in 1. </span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">3 - x will be searched in the class scope if it couldn't be found in 2.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">4 - x will be searched in the namespace scope if it couldn't be found in 3.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">If it couldn't be found in 4, name look-up will fail.</span>
       x;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">mx will be found in 3 (class scope). The compiler will change it to qualified identifier by using implicit ~this pointer~.</span>
       mx; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is equal to this-&gt;mx.</span>

           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">a will be found in 2 (enclosing block). This will increase the local a inside of the function block, not the a in the class scope.</span>
           a++;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
The <code>non-static data members</code> accessed in <code>non-static member functions</code> are the data members of the object they are called on:
</p>

<div class="org-src-container">
<pre class="src src-C++">  <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">Counter</span>
  <span style="color: #ffffff;">{</span>
  <span style="color: #b6a0ff;">public</span>:
      <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">print</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
      <span style="color: #ffffff;">{</span>
          <span style="color: #00bcff;">std</span>::cout &lt;&lt; m_c &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
      <span style="color: #ffffff;">}</span>
      
      <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">set</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">val</span><span style="color: #ffffff;">)</span>
      <span style="color: #ffffff;">{</span>
          m_c = val;
      <span style="color: #ffffff;">}</span>

  <span style="color: #b6a0ff;">private</span>:
      <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">m_c</span><span style="color: #ffffff;">{}</span>;
  <span style="color: #ffffff;">}</span>;

  <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
  <span style="color: #ffffff;">{</span>
      <span style="color: #6ae4b9;">Counter</span> <span style="color: #ffffff;">c1</span>;

      c1.<span style="color: #feacd0;">set</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">78</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Sets c1's m_c to 78.</span>
      c1.<span style="color: #feacd0;">print</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Prints c1's m_c, which is 78.</span>
      c1.<span style="color: #feacd0;">set</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">99</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Sets c1's m_c to 99.</span>
      c1.<span style="color: #feacd0;">print</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Prints 99.</span>

      <span style="color: #6ae4b9;">Counter</span> <span style="color: #ffffff;">c2</span>;
      
      c2.<span style="color: #feacd0;">set</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">3333</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Sets c2's m_c to 3333.</span>
      c2.<span style="color: #feacd0;">print</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Prints c2's m_c, which is 3333.</span>
  <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org5140c92" class="outline-4">
<h4 id="org5140c92">Class scope</h4>
<div class="outline-text-4" id="text-org5140c92">
<p>
<code>class members</code> declared in the <code>class definition</code> are included in the <code>class scope</code>.
In which cases is a identifier searched within a <code>class definition</code>?
</p>
<ul class="org-ul">
<li>If the identifier is the right operand of <code>. operator</code>.
<ul class="org-ul">
<li><code>object.x</code>, <code>x</code> will be searched in the <code>class scope</code>.</li>
</ul></li>
<li>If the identifier is the right operand of <code>-&gt; operator</code>.
<ul class="org-ul">
<li><code>object-&gt;x</code>, <code>x</code> will be searched in the <code>class scope</code>.</li>
</ul></li>
<li>If the identifier is the right operand of <code>:: operator</code>.
<ul class="org-ul">
<li><code>class::x</code>, <code>x</code> will be searched in the <code>class scope</code>.</li>
</ul></li>
</ul>

<p>
All of the <code>access specifiers</code> are in the same <code>class scope</code>. <code>public</code>, <code>private</code> and <code>protected</code> don't create new scope, they share the same <code>class scope</code>.
</p>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">3477</span>;

   <span style="color: #6ae4b9;">void</span> <span style="color: #00bcff;">C1</span>::<span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span> = <span style="color: #00bcff;">10</span>;

       x = <span style="color: #00bcff;">56</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This x is defined in the block scope.</span>

       <span style="color: #00bcff;">C1</span>::x = <span style="color: #00bcff;">20</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">If we want access the x which is in the class scope. We can use qualified name. The compiler will search it only in the class scope.</span>
       ::x = <span style="color: #00bcff;">22</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This x in the namespace scope.</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
<code>Member functions</code> cannot be redeclared:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Redeclaration is invalid, syntax error.</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Redeclaration is valid.</span>
</pre>
</div>

<p>
<code>Function overloading</code> and <code>function overload resolution</code> rules also apply to <code>member functions</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is valid function overloading, because they are in the same class scope.</span>
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
<code>Access specifiers</code> don't effect <code>function overloading</code> rules because they are not related with scope:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is valid function overloading, because they are in the same class scope.</span>
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">double</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c</span>;
       c.<span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">2.3</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">After function overload resolution, foo(double) will be chosen (exact match) but access control will fail because it is a private function.</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org4feddca" class="outline-4">
<h4 id="org4feddca">this keyword</h4>
<div class="outline-text-4" id="text-org4feddca">
<p>
<code>this</code> is a keyword that can only be used in <code>non-static member functions</code> of a class. <code>this</code> represents a pointer and often called <code>this pointer</code>. <code>this pointer</code> holds the address of the object on which the function is called.
</p>

<p>
The use of <code>this</code> keyword in <code>global functions</code> or in <code>static member functions</code> of classes is a syntax error:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #b6a0ff;">this</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is valid.</span>
       <span style="color: #ffffff;">}</span>
       
       <span style="color: #b6a0ff;">static</span> <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #b6a0ff;">this</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is invalid.</span>
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
<code>this pointer</code> holds the address of the caller object:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>;
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"&amp;c1: "</span> &lt;&lt; &amp;c1 &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
           c1.<span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The address of the c1 (&amp;c1) and ~this pointer~ are same.</span>

           <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c2</span>;
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"&amp;c2: "</span> &lt;&lt; &amp;c2 &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
           c2.<span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The address of the c2 (&amp;c2) and ~this pointer~ are same.</span>
       <span style="color: #ffffff;">}</span>
    <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
The value category of an expression created by <code>this pointer</code> is <code>PR-value expression</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           &amp;<span style="color: #b6a0ff;">this</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is invalid. ~this~ is a PR-value expression. Only L-value expressions can be the operand of address operator.</span>
       <span style="color: #ffffff;">}</span>
    <span style="color: #ffffff;">}</span>;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           &amp;<span style="color: #b6a0ff;">this</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is invalid. ~this~ is a PR-value expression. Only L-value expressions can be the operand of address operator.</span>
       <span style="color: #ffffff;">}</span>
    <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
The <code>non-static data members</code> can be accessed from <code>non-static member functions</code> with or without a <code>qualifier</code>, but it is also possible to access them via <code>this pointer</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">foo</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">All of these are same.</span>
           mx = <span style="color: #00bcff;">20</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Access with unqualified identifier.</span>
           <span style="color: #00bcff;">C1</span>::mx = <span style="color: #00bcff;">20</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Access with qualified identifier.</span>
           <span style="color: #b6a0ff;">this</span>-&gt;mx = <span style="color: #00bcff;">20</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Access through ~this pointer~.</span>
       <span style="color: #ffffff;">}</span>

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mx</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
There are situations where it is not possible to do what we want without using <code>this pointer</code>. 
</p>

<p>
It is not possible to call another function within a <code>non-static member function</code> for the caller object without <code>this pointer</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">C1</span>*<span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f3</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">C1</span><span style="color: #ffffff;">)</span>;
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f4</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">C1</span>&amp;<span style="color: #ffffff;">)</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #00bcff;">C1</span>::<span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">There is no way to call f2, f3 and f4 with the caller object without ~this pointer~.</span>
       <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">this</span><span style="color: #ffffff;">)</span>;
       <span style="color: #feacd0;">f3</span><span style="color: #ffffff;">(</span>*<span style="color: #b6a0ff;">this</span><span style="color: #ffffff;">)</span>;
       <span style="color: #feacd0;">f4</span><span style="color: #ffffff;">(</span>*<span style="color: #b6a0ff;">this</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
It is not possible to return the caller object or the address of the caller object without <code>this pointer</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">C1</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
       <span style="color: #b6a0ff;">return</span> *<span style="color: #b6a0ff;">this</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #6ae4b9;">C1</span>* <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
       <span style="color: #b6a0ff;">return</span> <span style="color: #b6a0ff;">this</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #6ae4b9;">C1</span>&amp; <span style="color: #feacd0;">f3</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #b6a0ff;">return</span> *<span style="color: #b6a0ff;">this</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb0a6a7f" class="outline-4">
<h4 id="orgb0a6a7f">Const member functions</h4>
<div class="outline-text-4" id="text-orgb0a6a7f">
<p>
<code>this pointer</code> is a hidden parameter that all <code>non-static member functions</code> have, so we cannot tell whether a function is a mutator or an accessor function. To avoid this confusion, if a function is not a mutator, we can define/declare it as <code>const</code> to indicate this. When a <code>non-static member function</code> is defined as <code>const</code>, the hidden <code>this pointer</code> becomes <code>const</code>. The <code>const member functions</code> basically tell us that they will not change the value/state of the object.
</p>

<p>
There are 2 different categories for <code>non-static member functions</code>:
</p>
<ul class="org-ul">
<li><code>const member function</code></li>
<li><code>non-const member function</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Const member function / Accessor function. This equals to void get(const C1*);</span>
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">get</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Non-const member function / Mutator function. This equals to void get(C1*);</span>
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">set</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
The compiler performs the same checks for <code>const this pointer</code> as it does for other <code>const objects</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This equals to this-&gt;mx = 10;</span>
           mx = <span style="color: #00bcff;">10</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid, because ~this pointer~ is const. Mutating a const object is a syntax error.</span>
       <span style="color: #ffffff;">}</span>

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mx</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
<code>non-const member functions</code> cannot be called within <code>const member functions</code>, because there is no implicit conversion from <code>const T*</code> to <code>T*</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid. T* can be converted to const T* implicitly.</span>
       <span style="color: #ffffff;">}</span>

       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">f2() takes const ~this pointer~ and tries to call f1() which takes non-const ~this pointer~, </span>
           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">but there is no implicit cast from const T* to T*.</span>
           <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid. </span>
       <span style="color: #ffffff;">}</span>
  <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
<code>non-const/const member functions</code> can be called with <code>non-const</code> class objects:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
       <span style="color: #ffffff;">}</span>

       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span>
       <span style="color: #ffffff;">{</span>
       <span style="color: #ffffff;">}</span>
  <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">a</span>;
       
       a.<span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid.</span>
       a.<span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid.</span>
    <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
<code>const</code> class objects can only call <code>const member functions</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
       <span style="color: #ffffff;">}</span>

       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span>
       <span style="color: #ffffff;">{</span>
       <span style="color: #ffffff;">}</span>
  <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">a</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">&amp;a is const C1* but f1() has implicit non-const ~this pointer~ and</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">there is no implicit conversion from const T* to T*.</span>
       a.<span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid.</span>
       a.<span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid.</span>
    <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
To define <code>const member functions</code>, the <code>const</code> keyword must appear in both the declaration and the definition:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">void</span> <span style="color: #00bcff;">C1</span>::<span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
<code>non-const/const member functions</code> can be used for <code>function overloading</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">These are valid overloads.</span>

       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1::f1()\n"</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span>
       <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1::f1() const\n"</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">a</span>;
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">b</span>;

       a.<span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1::f1() const will be called.</span>
       b.<span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1::f1() will be called.</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcca7afb" class="outline-4">
<h4 id="orgcca7afb">mutable keyword</h4>
<div class="outline-text-4" id="text-orgcca7afb">
<p>
Normally, the <code>const member functions</code> and <code>const objects</code> of the class cannot change the value of the object's <code>non-static data members</code>, but the <code>non-static data members</code> declared with the <code>mutable</code> keyword can be changed by the <code>const member functions</code>.
</p>

<p>
If the reason for the existence of <code>const member functions</code> is to prevent modification of <code>non-static data members</code>, why do we want to allow changes by using <code>mutable</code> keyword? Not every <code>non-static data member</code> of an object has to directly represent the state of the object. For example, some <code>data members</code> can be used for debugging and caching purposes and have no direct effect on the <code>observable state</code> of the object. The <code>mutable</code> keyword is particularly useful in these cases.
</p>

<p>
Assume there is a <code>Date</code> class with some <code>non-static data members</code> to represent the day, month and year. If we want to know how many times the month was accessed, we can put an additional <code>data member</code> to count it and increment it in the month's <code>getter</code>, but this is not directly related to the state of the object. It is just additional data that is needed for some reason. If there was no <code>mutable</code> keyword, we would have to change <code>getter</code> to <code>non-const member function</code> just to have some debug information. Example:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">Date</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">get_month</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">...</span>
           ++m_debug_month_hit_count;
           <span style="color: #b6a0ff;">return</span> m_month; 
       <span style="color: #ffffff;">}</span>
   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">m_day</span>, <span style="color: #ffffff;">m_month</span>, <span style="color: #ffffff;">m_year</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This data member is not directly related with the value/state of the object. It is just a debug information.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">It is declared as mutable so it is allowed to be changed even from const member functions.</span>
       <span style="color: #b6a0ff;">mutable</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">m_debug_month_hit_count</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
<code>const objects</code> can also change the <code>mutable</code> data members:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">Date</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">get_month</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #b6a0ff;">return</span> m_month; 
       <span style="color: #ffffff;">}</span>

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">m_day</span>, <span style="color: #ffffff;">m_month</span>, <span style="color: #ffffff;">m_year</span>;

   <span style="color: #b6a0ff;">public</span>:   
       <span style="color: #b6a0ff;">mutable</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">m_debug_cache_value</span>;
  <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">Date</span> <span style="color: #ffffff;">date</span><span style="color: #ffffff;">{}</span>;
       date.m_debug_cache_value = <span style="color: #00bcff;">365</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org876ba8b" class="outline-4">
<h4 id="org876ba8b">Constructor and destructor of classes</h4>
<div class="outline-text-4" id="text-org876ba8b">
<p>
The <code>constructor</code> and <code>destructor</code> are in the category of <code>non-static member functions</code>. The instantiation of a class object is performed by the <code>constructor</code> of the class, while the end of life of the object is performed by the <code>destructor</code> of the class.
</p>

<p>
There is a special type of <code>constructor</code> called <code>default constructor</code> which will be discussed in <code>special member functions</code>. In short, a <code>constructor</code> that can be called without taking any parameters is called a <code>default constructor</code>.
</p>
</div>
<ul class="org-ul">
<li><a id="org70d33f1"></a>Constructor<br />
<div class="outline-text-5" id="text-org70d33f1">
<p>
If any class object, regardless of its type, is alive, it was brought to life by a <code>constructor</code>. There is no exception to this rule in C++. Every object is instantiated by a call to a <code>constructor</code> function. After the <code>constructor</code> is called, the class object becomes available, which means that the memory space allocated for that class object is no longer a pile of garbage, but is now filled with values that can be used by the class. This typically means initializing the <code>non-static data members</code> of the class.
</p>

<p>
<code>Constructor</code>:
</p>
<ul class="org-ul">
<li>is <code>non-static member function</code> (not allowed to be <code>static</code>).</li>
<li>is <code>non-const member functions</code> (not allowed to be <code>const</code>).</li>
<li>has <code>this pointer</code>.</li>
<li>cannot be <code>global function</code>.</li>
<li>must have the same name with the class.</li>
<li>doesn't have concept of a return value.</li>
<li>can be <code>overloaded</code>.</li>
<li>can be <code>public</code>, <code>private</code> and <code>protected</code>.</li>
<li>cannot be called by objects using <code>.</code> and <code>-&gt;</code> operators.</li>
<li>is a <code>special member function</code> if it is the <code>default constructor</code>.</li>
</ul>

<p>
Declaration of a <code>constructor</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Has to have the same name with the class.</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
A class can have multiple <code>constructors</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">These are valid function overloads.</span>
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
<code>Constructors</code> cannot be <code>static</code> or <code>const</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #b6a0ff;">static</span> <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid.</span>
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid.</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
<code>Constructors</code> don't have to be <code>public</code> they can also be <code>private</code> or <code>protected</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is valid, but when we try to create an instance of the class,</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">access control will fail and we will get a syntax error.</span>
   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
Definition and declaration of a <code>constructor</code> can be in <code>class definition</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">These are valid.</span>
           mx = <span style="color: #00bcff;">10</span>;
           <span style="color: #b6a0ff;">this</span>-&gt;mx = <span style="color: #00bcff;">10</span>;
           <span style="color: #00bcff;">C1</span>::mx = <span style="color: #00bcff;">10</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mx</span>, <span style="color: #ffffff;">my</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
Definition and declaration of a <code>constructor</code> can also be separate:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">c1.h</span>
   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mx</span>, <span style="color: #ffffff;">my</span>;
   <span style="color: #ffffff;">}</span>;
  
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">c1.cpp</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">#include "c1.h"</span>
   <span style="color: #00bcff;">C1</span>::<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       mx = x;
       <span style="color: #b6a0ff;">this</span>-&gt;mx = x;
       <span style="color: #00bcff;">C1</span>::mx = x;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
<code>Constructors</code> can't be called by objects using <code>.</code> and <code>-&gt;</code> operators:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>;

       c1.<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is invalid.</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</li>
<li><a id="org67dff53"></a>Destructor<br />
<div class="outline-text-5" id="text-org67dff53">
<p>
Every class object that is instantiated has a lifespan/lifetime, and its lifetime will end at some point in the program's runtime. End-of-life class objects are deleted with a call to a <code>destructor</code> function. There is also no exception to this rule in C++. After the call to the <code>destructor</code>, the object's life is completely over and all memory allocated for the object is freed.
</p>

<p>
<code>Destructor</code>:
</p>
<ul class="org-ul">
<li>is <code>non-static member functions</code> (not allowed to be <code>static</code>).</li>
<li>is <code>non-const member functions</code> (not allowed to be <code>const</code>).</li>
<li>has <code>this pointer</code>.</li>
<li>cannot be <code>global function</code>.</li>
<li>must have the same name with the class and have the prefix <code>~</code>.</li>
<li>don't have concept of a return value.</li>
<li>cannot have parameters, so it cannot be <code>overloaded</code>.</li>
<li>can be <code>public</code>, <code>private</code> and <code>protected</code>.</li>
<li>can be called manually by objects using <code>.</code> and <code>-&gt;</code> operators.</li>
<li>is a <code>special member function</code>.</li>
</ul>

<p>
Declaration of a <code>destructor</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Has to have the same name with the class prefixed by ~.</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
A class cannot have multiple <code>destructors</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid.</span>
        <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid. Destructors cannot have parameters and cannot be overloaded.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This means there is no way to have more than one destructor.</span>
       ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
<code>Destructor</code> cannot be <code>static</code> or <code>const</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #b6a0ff;">static</span> ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid.</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C2</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       ~<span style="color: #feacd0;">C2</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid.</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
<code>Destructor</code> can be <code>public</code>, <code>private</code> and <code>protected</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is valid, but access control will fail</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">when destructor is called and we will get a syntax error.</span>
   <span style="color: #b6a0ff;">private</span>:
       ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
Definition and declaration of a <code>destructor</code> can be in <code>class definition</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">These are valid.</span>
           mx = <span style="color: #00bcff;">0</span>;
           <span style="color: #b6a0ff;">this</span>-&gt;mx = <span style="color: #00bcff;">0</span>;
           <span style="color: #00bcff;">C1</span>::mx = <span style="color: #00bcff;">0</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mx</span>, <span style="color: #ffffff;">my</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
Definition and declaration of a <code>destructor</code> can also be separate:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">c1.h</span>
   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mx</span>, <span style="color: #ffffff;">my</span>;
   <span style="color: #ffffff;">}</span>;
  
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">c1.cpp</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">#include "c1.h"</span>
   <span style="color: #00bcff;">C1</span>::~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       mx = <span style="color: #00bcff;">0</span>;
       <span style="color: #b6a0ff;">this</span>-&gt;mx = <span style="color: #00bcff;">0</span>;
       <span style="color: #00bcff;">C1</span>::mx = <span style="color: #00bcff;">0</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
<code>Destructor</code> can be called manually by objects using <code>.</code> and <code>-&gt;</code> operators:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is valid, but the cases where this is needed are very rare.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">There is almost only one case and it is about ~placement new~ operator.</span>
       c1.~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; 
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</li>
<li><a id="org0d2ebd4"></a>When are the constructor and the destructor called?<br />
<div class="outline-text-5" id="text-org0d2ebd4">
<p>
For a <code>global class object</code>:
</p>
<ul class="org-ul">
<li>The <code>constructor</code> is called before the <code>main</code> function.</li>
<li>The <code>destructor</code> is called after the <code>main</code> function.</li>
</ul>

<p>
If there is more than one <code>global class object</code>, the calling order of its <code>constructors</code> must be the same as the order of object declarations, and the order in which their <code>destructors</code> are called must be the reverse order of the order in which <code>contructors</code> are called. This is only valid in the same source file. The order of instantiation of <code>global class objects</code> defined in different source files is not specified. The term used for this situation is <code>static initilization fiasco</code>.
</p>

<p>
Example for a <code>global class object</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 default constructor this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>

       ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 destructor this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main begins\n"</span>;
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"&amp;c1: "</span> &lt;&lt; &amp;c1 &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main ends\n"</span>;
   <span style="color: #ffffff;">}</span>

   <span style="color: #989898; font-style: italic;">/*</span>
<span style="color: #989898; font-style: italic;">       Output: </span>
<span style="color: #989898; font-style: italic;">       C1 default constructor this: &lt;c1 address&gt;</span>
<span style="color: #989898; font-style: italic;">       main begins</span>
<span style="color: #989898; font-style: italic;">       &amp;c1: &lt;c1 address&gt;</span>
<span style="color: #989898; font-style: italic;">       main ends</span>
<span style="color: #989898; font-style: italic;">       C1 destructor this: &lt;c1 address&gt;</span>
<span style="color: #989898; font-style: italic;">   */</span>
</pre>
</div>

<p>
Example for multiple <code>global class object</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 default constructor this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>

       ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 destructor this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1a</span>;
   <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1b</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main begins\n"</span>;
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main ends\n"</span>;
   <span style="color: #ffffff;">}</span>

   <span style="color: #989898; font-style: italic;">/*</span>
<span style="color: #989898; font-style: italic;">       Output: </span>
<span style="color: #989898; font-style: italic;">       C1 default constructor this: &lt;c1a address&gt;</span>
<span style="color: #989898; font-style: italic;">       C1 default constructor this: &lt;c1b address&gt;</span>
<span style="color: #989898; font-style: italic;">       main begins</span>
<span style="color: #989898; font-style: italic;">       main ends</span>
<span style="color: #989898; font-style: italic;">       C1 destructor this: &lt;c1b address&gt;</span>
<span style="color: #989898; font-style: italic;">       C1 destructor this: &lt;c1a address&gt;</span>
<span style="color: #989898; font-style: italic;">   */</span>
</pre>
</div>

<p>
Example for multiple <code>global class object</code> in different source files:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">c1.h</span>
   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 default constructor this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>

       ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 destructor this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">main.cpp</span>
   <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">a.cpp</span>
   <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1a</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">b.cpp</span>
   <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1b</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">In this case, we cannot say anything about initilization order.</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">There is no way to know in which order objects will be created.</span>
</pre>
</div>

<p>
For a <code>static local class object</code>:
</p>
<ul class="org-ul">
<li>The <code>constructor</code> is called the first time when the function containing the object is called.</li>
<li>The <code>destructor</code> is called after the <code>main</code> function.</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 default constructor this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>

       ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 destructor this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"f1() is called\n"</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">When the program reaches this point, the constructor will be called,</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">and this is the first call to f1(). If f1() gets called more than once,</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">the constructor will not be called again because the object has alreay been created and</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">is still alive (because it has static lifetime).</span>
       <span style="color: #b6a0ff;">static</span> <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>;
   <span style="color: #ffffff;">}</span>

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main begins\n"</span>;
       <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
       <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
       <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main ends\n"</span>;
   <span style="color: #ffffff;">}</span>

   <span style="color: #989898; font-style: italic;">/*</span>
<span style="color: #989898; font-style: italic;">       Output: </span>
<span style="color: #989898; font-style: italic;">       main begins</span>
<span style="color: #989898; font-style: italic;">       f1() is called</span>
<span style="color: #989898; font-style: italic;">       C1 default constructor this: &lt;c1 address&gt;</span>
<span style="color: #989898; font-style: italic;">       f1() is called</span>
<span style="color: #989898; font-style: italic;">       f1() is called</span>
<span style="color: #989898; font-style: italic;">       main ends</span>
<span style="color: #989898; font-style: italic;">       C1 destructor this: &lt;c1 address&gt;</span>
<span style="color: #989898; font-style: italic;">   */</span>
</pre>
</div>

<p>
For a <code>local/automatic class object</code>:
</p>
<ul class="org-ul">
<li>The <code>constructor</code> is called when the the program reaches the point where the object is created.</li>
<li>The <code>destructor</code> is called when the scope defining the lifetime of the object ends.</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 default constructor\n"</span>;
       <span style="color: #ffffff;">}</span>

       ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 destructor\n"</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main begins\n"</span>;

       <span style="color: #feacd0;">if </span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">1</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The constructor will be called when program reaches this point. c1 is alive after this point.</span>

           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main continues\n"</span>;

           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The destructor will be called here at the end of scope which c1 object is in.</span>
       <span style="color: #ffffff;">}</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main continues\n"</span>;

       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main ends\n"</span>;
   <span style="color: #ffffff;">}</span>

   <span style="color: #989898; font-style: italic;">/*</span>
<span style="color: #989898; font-style: italic;">       Output: </span>
<span style="color: #989898; font-style: italic;">       main begins</span>
<span style="color: #989898; font-style: italic;">       C1 default constructor</span>
<span style="color: #989898; font-style: italic;">       main continues</span>
<span style="color: #989898; font-style: italic;">       C1 destructor</span>
<span style="color: #989898; font-style: italic;">       main continues</span>
<span style="color: #989898; font-style: italic;">       main ends</span>
<span style="color: #989898; font-style: italic;">   */</span>
</pre>
</div>

<p>
Unlike <code>static local class objects</code>, <code>local/automatic class objects</code> are recreated each time the program enters the <code>block/scope</code> they are in:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 default constructor\n"</span>;
       <span style="color: #ffffff;">}</span>

       ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 destructor\n"</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main begins\n"</span>;

       <span style="color: #feacd0;">for </span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">i</span> = <span style="color: #00bcff;">0</span>; i &lt; <span style="color: #00bcff;">3</span>; ++i<span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">In each iteration, the constructor is called and c1 gets created.</span>

           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Each time the scope of the for-loop ends, the destructor is called, and c1 gets destroyed.</span>
       <span style="color: #ffffff;">}</span>

       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main ends\n"</span>;
   <span style="color: #ffffff;">}</span>

   <span style="color: #989898; font-style: italic;">/*</span>
<span style="color: #989898; font-style: italic;">       Output: </span>
<span style="color: #989898; font-style: italic;">       main begins</span>
<span style="color: #989898; font-style: italic;">       C1 default constructor</span>
<span style="color: #989898; font-style: italic;">       C1 destructor</span>
<span style="color: #989898; font-style: italic;">       C1 default constructor</span>
<span style="color: #989898; font-style: italic;">       C1 destructor</span>
<span style="color: #989898; font-style: italic;">       C1 default constructor</span>
<span style="color: #989898; font-style: italic;">       C1 destructor</span>
<span style="color: #989898; font-style: italic;">       main ends</span>
<span style="color: #989898; font-style: italic;">   */</span>
</pre>
</div>

<p>
For a <code>dynamic class objects</code>:
</p>
<ul class="org-ul">
<li>The <code>constructor</code> is called when one of the <code>new expressions/operators</code> is used.</li>
<li>The <code>destructor</code> is called when one of the <code>delete expressions/operators</code> is used.</li>
</ul>

<p>
The <code>new expressions</code> and <code>delete expressions</code> are not equivalents of <code>malloc</code> and <code>free</code>. The <code>malloc</code> and <code>free</code> functions are used to allocate and deallocate a memory space. The <code>new expressions</code> and <code>delete expressions</code> are used to create and destroy <code>class objects</code> with <code>dynamic lifetime</code>. 
</p>

<p>
When a <code>new expression</code> is used (in order):
</p>
<ul class="org-ul">
<li>The function <code>void* operator new(std::size_t)</code> is called. The <code>operator new</code> function allocates a memory space (possibly using <code>malloc</code>) for the object. It returns this address if the allocation succeeds, or throws an <code>exception</code> of type <code>std:bad_alloc</code> if it fails.</li>
<li>The address returned from <code>operator new</code> function is then <code>casted</code> from <code>void*</code> to the address of the <code>class type</code> and the <code>constructor</code> of the class is called for that address.</li>
<li>The allocated address is returned to the caller.</li>
</ul>

<p>
When a <code>delete expression</code> is used (in order):
</p>
<ul class="org-ul">
<li>The <code>destructor</code> of the class is called for the object.</li>
<li>The function <code>void operator delete(void*)</code> is called with the address of the object (which is allocated by <code>operator new</code> function). The <code>operator delete</code> function deallocates the memory space (possibly using <code>free</code>).</li>
</ul>

<p>
The <code>operator new</code> and <code>operator delete</code> functions are part of the C++ standard library.
</p>

<p>
What <code>new expressions</code> and <code>delete expressions</code> do:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #989898; font-style: italic;">//  </span><span style="color: #989898; font-style: italic;">Memory is allocated for the object.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1* address_obj = (C1*)operator new(sizeof(C1));</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The constructor is called with the allocated address of the object.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Normally, we cannot call the constructor manually but the compiler can do it.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">address_obj-&gt;constructor(); </span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The allocated address is returned to the caller.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">c1 = address_obj;</span>
       <span style="color: #6ae4b9;">C1</span>* <span style="color: #ffffff;">c1</span> = <span style="color: #b6a0ff;">new</span> <span style="color: #6ae4b9;">C1</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The destructor is called for the object.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">c1-&gt;~C1();</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The operator delete function is called with the allocated address of the object.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">operator delete(c1);</span>
       <span style="color: #b6a0ff;">delete</span> c1;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 default constructor this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>

       ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 destructor this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"f1() is called\n"</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main begins\n"</span>;
      
       <span style="color: #6ae4b9;">C1</span>* <span style="color: #ffffff;">c1</span> = <span style="color: #b6a0ff;">new</span> <span style="color: #6ae4b9;">C1</span>;
       
       c1-&gt;<span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

       <span style="color: #b6a0ff;">delete</span> c1;
      
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main ends\n"</span>;
   <span style="color: #ffffff;">}</span>

   <span style="color: #989898; font-style: italic;">/*</span>
<span style="color: #989898; font-style: italic;">       Output: </span>
<span style="color: #989898; font-style: italic;">       main begins</span>
<span style="color: #989898; font-style: italic;">       C1 default constructor this: &lt;c1 address&gt;</span>
<span style="color: #989898; font-style: italic;">       f1() is called</span>
<span style="color: #989898; font-style: italic;">       C1 destructor this: &lt;c1 address&gt;</span>
<span style="color: #989898; font-style: italic;">       main ends</span>
<span style="color: #989898; font-style: italic;">   */</span>
</pre>
</div>

<p>
The <code>pointer</code> and <code>reference</code> types do not cause the constructor and destructor to be called:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 default constructor\n"</span>;
       <span style="color: #ffffff;">}</span>

       ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 destructor\n"</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The constructor will be only called when c1 gets created in the first line.</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">c1p and c1p are just pointer/reference types, they don't directly represent the class.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">No constructor/destructor will be called for c1p and c1r.</span>
       <span style="color: #6ae4b9;">C1</span>* <span style="color: #ffffff;">c1p</span> = &amp;c1; 
       <span style="color: #6ae4b9;">C1</span>&amp; <span style="color: #ffffff;">c1r</span> = c1;

      <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The destructor for c1 will be called here. Nothing will happen for c1p and c1r.</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
For arrays of <code>class objects</code>, the <code>constructor</code> and <code>destructor</code> are called separately for each ~class object:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 default constructor this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>

       ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 destructor this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">char</span> <span style="color: #ffffff;">m_buf</span><span style="color: #ffffff;">[</span><span style="color: #00bcff;">16</span><span style="color: #ffffff;">]{}</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span><span style="color: #ffffff;">[</span><span style="color: #00bcff;">5</span><span style="color: #ffffff;">]</span>;
   <span style="color: #ffffff;">}</span>

   <span style="color: #989898; font-style: italic;">/*</span>
<span style="color: #989898; font-style: italic;">       Output: </span>
<span style="color: #989898; font-style: italic;">       C1 default constructor this: &lt;c1 address&gt;</span>
<span style="color: #989898; font-style: italic;">       C1 default constructor this: &lt;c1 address + 16&gt;</span>
<span style="color: #989898; font-style: italic;">       C1 default constructor this: &lt;c1 address + 32&gt;</span>
<span style="color: #989898; font-style: italic;">       C1 default constructor this: &lt;c1 address + 48&gt;</span>
<span style="color: #989898; font-style: italic;">       C1 default constructor this: &lt;c1 address + 64&gt;</span>
<span style="color: #989898; font-style: italic;">       C1 destructor this: &lt;c1 address + 64&gt;</span>
<span style="color: #989898; font-style: italic;">       C1 destructor this: &lt;c1 address + 48&gt;</span>
<span style="color: #989898; font-style: italic;">       C1 destructor this: &lt;c1 address + 32&gt;</span>
<span style="color: #989898; font-style: italic;">       C1 destructor this: &lt;c1 address + 16&gt;</span>
<span style="color: #989898; font-style: italic;">       C1 destructor this: &lt;c1 address&gt;</span>
<span style="color: #989898; font-style: italic;">   */</span>
</pre>
</div>
</div>
</li>
<li><a id="orgdf89030"></a>When the default constructor is called?<br />
<div class="outline-text-5" id="text-orgdf89030">
<p>
Normally, <code>default initialized</code> objects are created with <code>garbage value</code>, but <code>default initialized</code> class objects are created with a call to the <code>default constructor</code>. The <code>non-static data members</code> of the class can still have garbage value if they are not initialized in the <code>default constructor</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 default constructor\n"</span>;
       <span style="color: #ffffff;">}</span>

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mx</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">x is default initialized and have garbage value.</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">c1 is default initialized and the default constructor is called.</span>

       c1.mx; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">c1.mx still has a garbage value because it is not initialized in the default constructor.</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
<code>value initialized</code> class objects are created with a call to the <code>default constructor</code>. The <code>non-static data members</code> of the class will be also <code>zero initialized</code> before the <code>default constructor</code> is called. This means built-in types like <code>int</code> will be set to <code>0</code>, and pointers will be set to <code>nullptr</code>.
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 default constructor\n"</span>;
       <span style="color: #ffffff;">}</span>

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mx</span>;
  <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">{}</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">x is value initialized and set to 0. </span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span><span style="color: #ffffff;">{}</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">c1 is value initialized.</span>

       c1.mx <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">c1.mx is also value initialized before the default constructor is called, meaning it is zero initialized.</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
<code>direct initialization</code> without providing a value is not possible because of <code>most vexing parse</code>. The compiler might give a warning:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 default constructor\n"</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">x</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">5</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">x is direct initialized and set to 5.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid but doesn't mean direct initilization.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Because of the most vexing parse, the compiler understand this as a function declaration.</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">x</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">It is same for the class objects. Valid but doesn't mean direct initilization.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Because of the most vexing parse, the compiler understand this as a function declaration.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The default constructor is not called because there is no object instantiation here.</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #feacd0;">c1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
The <code>default constructor</code> is also called when the elements of an array are <code>class objects</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 default constructor\n"</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span><span style="color: #ffffff;">[</span><span style="color: #00bcff;">5</span><span style="color: #ffffff;">]</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The default constructor is called one by one for each element of array c1.</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
It is also important to understand that classes do not have to have a <code>default constructor</code>. The <code>default constructor</code> may not be declared. There are different rules for cases where the <code>default constructor</code> is not declared, which will be discussed later.
</p>
</div>
</li>
<li><a id="orgc053688"></a>How non-default constructors can be called?<br />
<div class="outline-text-5" id="text-orgc053688">
<p>
A <code>non-default constructor</code> is any <code>constructor</code> that requires one or more arguments to be passed when an object is created. These <code>constructors</code> differ from the <code>default constructor</code>, which either takes no arguments or has all default values for its parameters. <code>non-default constructors</code> are explicitly defined by the programmer and are used to initialize objects with specific values.
</p>

<p>
<code>non-default constructors</code> can be called when an object is created with <code>direct initialization</code>, <code>direct-list initialization</code> and <code>copy initialization</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1(int x) x: "</span> &lt;&lt; x &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1(int x, int y) x: "</span> &lt;&lt; x &lt;&lt; <span style="color: #79a8ff;">" y: "</span> &lt;&lt; y &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #feacd0;">c1</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">c1 is direct initialized. C1(int x) constructor is called.</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span><span style="color: #ffffff;">{</span><span style="color: #00bcff;">20</span><span style="color: #ffffff;">}</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">c1 is direct-list initialized. C1(int x) constructor is called.</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span> = <span style="color: #00bcff;">30</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">c1 is copy initialized. C1(int x) constructor is called.</span>

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1(int x, int y) constructor is called for all of these.</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #feacd0;">c1</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">1</span>, <span style="color: #00bcff;">2</span><span style="color: #ffffff;">)</span>;
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span><span style="color: #ffffff;">{</span><span style="color: #00bcff;">3</span>, <span style="color: #00bcff;">4</span><span style="color: #ffffff;">}</span>;
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span> = <span style="color: #ffffff;">{</span><span style="color: #00bcff;">5</span>, <span style="color: #00bcff;">6</span><span style="color: #ffffff;">}</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</li>
<li><a id="orga3f6d0c"></a>Constructor initializer list<br />
<div class="outline-text-5" id="text-orga3f6d0c">
<p>
The <code>constructor</code> initializes the <code>non-static data members</code> of the class object it creates. The syntax used by <code>constructors</code> to initialize <code>non-static data members</code> is called the <code>constructor initializer list</code>.
</p>

<p>
Usage of the <code>constructor initializer list</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This means that when this constructor is called, mx, my, and md are initialized to 10, 20, and 8.8 respectively,</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">before the constructor's body is executed.</span>
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> : <span style="color: #feacd0;">mx</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>, <span style="color: #feacd0;">my</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">20</span><span style="color: #ffffff;">)</span>, md<span style="color: #ffffff;">{</span> <span style="color: #00bcff;">8.8</span> <span style="color: #ffffff;">}</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">mx, my and md are already initialized here.</span>
           mx; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">10</span>
           my; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">20</span>
           md; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">8.8</span>
       <span style="color: #ffffff;">}</span>

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mx</span>, <span style="color: #ffffff;">my</span>;
       <span style="color: #6ae4b9;">double</span> <span style="color: #ffffff;">md</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
Not all <code>non-static data members</code> of the class have to be initialized with the <code>constructor initializer list</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> : mx<span style="color: #ffffff;">{</span> <span style="color: #00bcff;">10</span> <span style="color: #ffffff;">}</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Note that these are assignments, not initializations. </span>
           my = <span style="color: #00bcff;">20</span>;
           md = <span style="color: #00bcff;">8.8</span>;
       <span style="color: #ffffff;">}</span>

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mx</span>, <span style="color: #ffffff;">my</span>;
       <span style="color: #6ae4b9;">double</span> <span style="color: #ffffff;">md</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
<code>non-static data members</code> are initialized in <code>declaration order</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">mx will be initialized before my because mx is declared first.</span>
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> : my<span style="color: #ffffff;">{</span> <span style="color: #00bcff;">10</span> <span style="color: #ffffff;">}</span>, mx<span style="color: #ffffff;">{</span> <span style="color: #00bcff;">20</span> <span style="color: #ffffff;">}</span>
       <span style="color: #ffffff;">{</span>

       <span style="color: #ffffff;">}</span>

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">mx is declarared before my;</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mx</span>, <span style="color: #ffffff;">my</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
When using the constructor initializer list, the <code>constructor</code> block must exist even if it is empty:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> : <span style="color: #feacd0;">mx</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>, <span style="color: #feacd0;">mx</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">20</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid.</span>
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> : <span style="color: #feacd0;">mx</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>, <span style="color: #feacd0;">mx</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">20</span><span style="color: #ffffff;">)</span> <span style="color: #ffffff;">{}</span> <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid, the constructor block must exist even it is empty.</span>

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mx</span>, <span style="color: #ffffff;">my</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
The <code>constructor initializer list</code> can also be used with <code>non-default constructors</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">date.h</span>
   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">Date</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">Date</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">day</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mon</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">year</span><span style="color: #ffffff;">)</span>;

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">m_day</span>, <span style="color: #ffffff;">m_mon</span>, <span style="color: #ffffff;">m_year</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">date.cpp</span>
   <span style="color: #00bcff;">Date</span>::<span style="color: #feacd0;">Date</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">day</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mon</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">year</span><span style="color: #ffffff;">)</span> : m_day<span style="color: #ffffff;">{</span> day <span style="color: #ffffff;">}</span>, m_mon <span style="color: #ffffff;">{</span> mon <span style="color: #ffffff;">}</span>, m_year<span style="color: #ffffff;">{</span> year <span style="color: #ffffff;">}</span> <span style="color: #ffffff;">{}</span>

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">main.cpp</span>
   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">Date</span> <span style="color: #feacd0;">date</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">19</span>, <span style="color: #00bcff;">9</span>, <span style="color: #00bcff;">2024</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
<code>reference</code> and <code>const</code> types must be initialized with the <code>constructor initializer list</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid, mr is a reference and not initialized with the constructor initializer list.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">mx is a const variable and not initialized with the constructor initializer list.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Reference and const types cannot be default initialized.</span>
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> : mx<span style="color: #ffffff;">{</span> <span style="color: #00bcff;">10</span> <span style="color: #ffffff;">}</span>
       <span style="color: #ffffff;">{</span>

       <span style="color: #ffffff;">}</span>

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span>&amp; <span style="color: #ffffff;">mr</span>;
       <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mx</span>;
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mx</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-orga3e8862" class="outline-4">
<h4 id="orga3e8862">Special member functions</h4>
<div class="outline-text-4" id="text-orga3e8862">
<p>
<code>special member functions</code> are <code>member functions</code> related to a very important group of functions of a class. There are 6 different <code>special member functions</code>.
</p>

<p>
These <code>special member functions</code> are:
</p>
<ul class="org-ul">
<li><code>default constructor</code></li>
<li><code>destructor</code></li>
<li><code>copy constructor</code></li>
<li><code>move constructor</code> (C++11)</li>
<li><code>copy assignment</code></li>
<li><code>move assignment</code>  (C++11)</li>
</ul>

<p>
<code>special member functions</code> can be in one of the following states:
</p>
<ul class="org-ul">
<li><code>not declared</code></li>
<li><code>implicitly declared</code>
<ul class="org-ul">
<li><code>implicitly declared</code> and <code>defaulted</code></li>
<li><code>implicitly declared</code> and <code>deleted</code></li>
</ul></li>
<li><code>explicitly/user declared</code>
<ul class="org-ul">
<li><code>explicitly/user declared</code> and <code>defined</code></li>
<li><code>explicitly/user declared</code> and <code>defaulted</code></li>
<li><code>explicitly/user declared</code> and <code>deleted</code></li>
</ul></li>
</ul>

<p>
The definitions of these functions can be written by the compiler if certain conditions are met. These functions, which are generated automatically by the compiler are called <code>defaulted functions</code>. Only <code>special member functions</code> can be <code>defaulted</code>.
</p>

<p>
<code>special member functions</code> can be <code>defaulted</code> in 2 different ways:
</p>
<ul class="org-ul">
<li>The compiler can declare and define the <code>special member functions</code> <code>implicitly</code> according to the rules of the language.</li>
<li>We can <code>explicitly</code> ask the compiler to write the code for the <code>special member functions</code>.</li>
</ul>

<p>
<code>special member functions</code> can be <code>deleted</code> in 2 different ways:
</p>
<ul class="org-ul">
<li>The compiler can <code>delete</code> the <code>special member functions</code> <code>implicitly</code> according to the rules of the language.</li>
<li>We can <code>explicitly</code> ask the compiler to <code>delete</code> the <code>special member functions</code>.</li>
</ul>

<p>
<code>deleted function</code> means that the function exists, but calling it would cause a syntax error. <code>deleted functions</code> are distinguished from functions that were <code>not declared</code>. They are included in the <code>function overload resolution</code> process. With some exceptions, <code>special member functions</code>, <code>class member functions</code> and <code>global functions</code> can be <code>deleted</code>, but most of the time <code>deleted functions</code> are about <code>special member functions</code>.
</p>

<p>
Calling <code>deleted functions</code> is invalid:
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">delete</span>;

  <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
  <span style="color: #ffffff;">{</span>
      <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">10</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid. Deleted functions cannot be referenced.</span>
  <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
<code>deleted functions</code> are included in <code>function overload resolution</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">delete</span>;
  <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">float</span><span style="color: #ffffff;">)</span>;

  <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
  <span style="color: #ffffff;">{</span>
      <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">2.3</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid, func(float) will be called.</span>
      <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">2</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid, func(int) will be chosen but deleted functions cannot be referenced.</span>
  <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
There are some rules defining how each <code>special member function</code> should be <code>defaulted</code> by the compiler. When a <code>special member function</code> is defaulted by the compiler violates the rules of the language, the compiler <code>deletes</code> the function it should have <code>defaulted</code> to instead of throwing a syntax error.
</p>

<p>
Cases that can cause a syntax error when the compiler tries to <code>default</code> a <code>special member function</code>:
</p>
<ul class="org-ul">
<li>If some of the <code>non-static data members</code> of a class cannot be <code>default initialized</code>.</li>
<li>If there is a call to a function that does not exist / <code>non declared</code>.</li>
<li>If there is a call to a <code>private</code> function.</li>
<li>If there is a call to a <code>deleted</code> function.</li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org2ee0a42"></a>Default constructor<br />
<div class="outline-text-5" id="text-org2ee0a42">
<p>
For a <code>constructor</code> to be the <code>default constructor</code>, it must either take no parameters or all its parameters must take default arguments. In other words, a <code>constructor</code> is the <code>default constructor</code> if it can be called without passing any arguments. The <code>default constructor</code> is one of the <code>special member functions</code>.
</p>

<p>
Example for the <code>default constructor</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Default constructor.</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C2</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C2</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> = <span style="color: #00bcff;">0</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Default constructor.</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
The <code>default constructor</code> is <code>defaulted</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">default</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The default constructor is user-declared and defaulted.</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
The <code>default constructor</code> is <code>implicitly deleted</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The default constructor is implicitly declared and deleted.</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Invalid. The default constructor is deleted and cannot be called.</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
The <code>default constructor</code> is <code>deleted</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">delete</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The default constructor is user declared and deleted.</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
<code>default constructor</code> which is <code>defaulted</code> by the compiler must be:
</p>
<ul class="org-ul">
<li><code>non-static</code></li>
<li><code>inline</code> (because it will be defined in <code>class definition</code>, meaning it is implicitly <code>inline</code>)</li>
<li><code>public</code></li>
</ul>
<p>
function of a class.
</p>

<p>
The compiler will generate code for a <code>default constructor</code> that <code>default initializes</code> all <code>non-static data members</code>. If there is an <code>explicitly declared</code> constructor (it doesn't have to be <code>default constructor</code>) the compiler will not <code>default</code> a <code>default constructor</code>.
</p>

<p>
The <code>default constructor</code> will be <code>defaulted</code> by the compiler because there is no syntax error and it is not <code>explicitly declared</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The compiler will generate something like this as a default constructor. All non-static data members are default initialized.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1() : ax(), bx(), cx()</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">{</span>
              <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The compiler can also add extra code depending on its implementation.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">}</span>
   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">ax</span>;
       <span style="color: #6ae4b9;">double</span> <span style="color: #ffffff;">bx</span>;
       <span style="color: #6ae4b9;">char</span>* <span style="color: #ffffff;">cx</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
The <code>default constructor</code> will be <code>deleted</code> because <code>const</code> objects cannot be <code>default initialized</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The default constructor will be deleted by compiler because const objects cannot be default initialized.</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Instead of throwing a syntax error the compiler deletes the default constructor.</span>
   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is a syntax error. Deleted functions cannot be referenced.</span>
       <span style="color: #b6a0ff;">return</span> <span style="color: #00bcff;">0</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
The <code>default constructor</code> will be <code>deleted</code> because the <code>non-static data member</code> does not have <code>default constructor</code> and cannot be <code>default initialized</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C2</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">There is an explicily declared constructor, meaning that this class does not have a default constructor.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The default constructor is non-declared.</span>
       <span style="color: #feacd0;">C2</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The default constructor will be deleted because c2 does not have a default constructor so cannot be default initialized.</span>
   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">C2</span> <span style="color: #ffffff;">c2</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Syntax error. Attempting to reference a deleted function.</span>
       
       <span style="color: #b6a0ff;">return</span> <span style="color: #00bcff;">0</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</li>
<li><a id="org4b609dd"></a>Copy constructor<br />
<div class="outline-text-5" id="text-org4b609dd">
<p>
The <code>copy constructor</code> is called when a <code>class object</code> instantiated by taking its value from another <code>class object</code> of the same type. The <code>copy constructor</code> has the same name as the class and takes a <code>const L-value reference</code> parameter of that class type.
</p>

<p>
<code>explicitly declared copy constructor</code> example:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">Date</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">Date</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">d</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">m</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span><span style="color: #ffffff;">)</span> : md<span style="color: #ffffff;">{</span> d <span style="color: #ffffff;">}</span>, mm<span style="color: #ffffff;">{</span> m <span style="color: #ffffff;">}</span>, my<span style="color: #ffffff;">{</span> y <span style="color: #ffffff;">}</span> <span style="color: #ffffff;">{</span> <span style="color: #ffffff;">}</span>
       <span style="color: #feacd0;">Date</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">Date</span>&amp; <span style="color: #ffffff;">other</span><span style="color: #ffffff;">)</span> : md<span style="color: #ffffff;">{</span> other.md <span style="color: #ffffff;">}</span>, mm<span style="color: #ffffff;">{</span> other.mm <span style="color: #ffffff;">}</span>, my<span style="color: #ffffff;">{</span> other.my <span style="color: #ffffff;">}</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">" &amp;other: "</span> &lt;&lt; &amp;other &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">md</span><span style="color: #ffffff;">{</span> <span style="color: #00bcff;">1</span> <span style="color: #ffffff;">}</span>, <span style="color: #ffffff;">mm</span><span style="color: #ffffff;">{</span> <span style="color: #00bcff;">1</span> <span style="color: #ffffff;">}</span>, <span style="color: #ffffff;">my</span><span style="color: #ffffff;">{</span> <span style="color: #00bcff;">1990</span> <span style="color: #ffffff;">}</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">Date</span> <span style="color: #ffffff;">dx</span><span style="color: #ffffff;">{</span> <span style="color: #00bcff;">12</span>, <span style="color: #00bcff;">8</span>, <span style="color: #00bcff;">1999</span> <span style="color: #ffffff;">}</span>;
       <span style="color: #6ae4b9;">Date</span> <span style="color: #ffffff;">dy</span> = dx;

       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"&amp;dy: "</span> &lt;&lt; &amp;dy &lt;&lt; <span style="color: #79a8ff;">" &amp;dx: "</span> &lt;&lt; &amp;dx &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
   <span style="color: #ffffff;">}</span>

   <span style="color: #989898; font-style: italic;">/*</span>
<span style="color: #989898; font-style: italic;">        'this pointer' will be address of dy and address of other will be equal to address of dx.</span>
<span style="color: #989898; font-style: italic;">        Output:</span>
<span style="color: #989898; font-style: italic;">        this: &lt;address of this&gt; &amp;other: &lt;address of other&gt;</span>
<span style="color: #989898; font-style: italic;">        dy: &lt;address of dy&gt; dx: &lt;address of dx&gt;</span>
<span style="color: #989898; font-style: italic;">   */</span>
</pre>
</div>

<p>
In some cases the compiler can make certain optimizations so that the <code>copy constructor</code> is not called, but leaving these cases aside for now, typically the <code>copy constructor</code> is called in the following scenarios.
</p>

<p>
When a <code>class object</code> is instantiated directly by another <code>class object</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
  <span style="color: #ffffff;">{</span>
      <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The copy constructor is implicitly declared and defaulted.  </span>
  <span style="color: #ffffff;">}</span>;

  <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
  <span style="color: #ffffff;">{</span>
      <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1a</span>;
      <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The copy constructor will be called for c1b. c1b will be instantiated by taking its value from c1a.</span>
      <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">When the copy constructor is called for c1b, 'this pointer' will be address of c1b and const reference parameter will be c1a.</span>
      <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1b</span><span style="color: #ffffff;">{</span> c1a <span style="color: #ffffff;">}</span>;
      <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The copy constructor will be called for c1c. c1c will be instantiated by taking its value from c1b.</span>
      <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1c</span> = c1b;
  <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
Calling a function with a value (not reference or pointer) causes the <code>copy constructor</code> to be called:
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
  <span style="color: #ffffff;">{</span>
      <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The copy constructor is implicitly declared and defaulted.  </span>
  <span style="color: #ffffff;">}</span>;

  <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">param</span><span style="color: #ffffff;">)</span>;

  <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
  <span style="color: #ffffff;">{</span>
      <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>;
      <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">When func() is called with c1, C1 param will be instantiated by calling the copy constructor.</span>
      <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span>c1<span style="color: #ffffff;">)</span>;
  <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
Returning a value from a function (not reference or pointer) causes the <code>copy constructor</code> to be called:
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
  <span style="color: #ffffff;">{</span>
      <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The copy constructor is implicitly declared and defaulted.  </span>
  <span style="color: #ffffff;">}</span>;

  <span style="color: #6ae4b9;">C1</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
  <span style="color: #ffffff;">{</span>
      <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>;
      <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">When func() is returned, the return object will be instantiated by calling the copy constructor and it will take its value from c1.</span>
      <span style="color: #b6a0ff;">return</span> c1; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">c1 will be copied to the return object and will be desctructed at the end of scope.</span>
  <span style="color: #ffffff;">}</span>

  <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
  <span style="color: #ffffff;">{</span>
      <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span> = <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
  <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
<code>copy constructor</code> which is <code>defaulted</code> by the compiler must be:
</p>
<ul class="org-ul">
<li><code>non-static</code></li>
<li><code>inline</code> (because it will be defined in <code>class definition</code>, meaning it is implicitly <code>inline</code>)</li>
<li><code>public</code></li>
</ul>
<p>
function of a class.
</p>

<p>
The compiler will generate code for a <code>copy constructor</code> that initializes all <code>non-static data members</code> by taking their value from the <code>class object</code> being copied:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The compiler will generate something like this as a copy constructor. All non-static data members are initialized by taking their value from other class object. Initilization will be in declaration order as in default constructor.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1(const C1&amp; other) : ax(other.ax), bx(other.bx), cx(other.cx)</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">{</span>
              <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The compiler can also add extra code depending on its implementation.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">}</span>
   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">ax</span>;
       <span style="color: #6ae4b9;">double</span> <span style="color: #ffffff;">bx</span>;
       <span style="color: #6ae4b9;">char</span>* <span style="color: #ffffff;">cx</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
Usually the <code>copy constructor</code> which is <code>defaulted</code> by the compiler will be sufficient for our needs, but there are some cases where the <code>copy constructor</code> needs to be <code>explicitly defined</code> to prevent logical errors that can cause memory/resource leaks. We can say that if the <code>destructor</code> is <code>explicitly defined</code> for a class, typically the <code>copy constructor</code> also needs to be <code>explicitly defined</code> because most of the time it means we have some memory/resource to manage.
</p>

<p>
If pointer or reference <code>non-static data members</code> are stored inside of a class, we might need to use <code>explicitly defined</code> <code>copy constructor</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">Logger</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The copy constructor is defaulted by compiler.</span>
       
       <span style="color: #feacd0;">Logger</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">char</span>* <span style="color: #ffffff;">file_name</span><span style="color: #ffffff;">)</span> : <span style="color: #feacd0;">m_f</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">fopen</span><span style="color: #ffffff;">(</span>file_name, <span style="color: #79a8ff;">"w"</span><span style="color: #ffffff;">))</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #feacd0;">if </span><span style="color: #ffffff;">(</span><span style="color: #ff5f59; font-weight: bold;">!</span>m_f<span style="color: #ffffff;">)</span>
           <span style="color: #ffffff;">{</span>
               <span style="color: #b6a0ff;">throw</span> <span style="color: #00bcff;">std</span>::runtime_error<span style="color: #ffffff;">{</span> <span style="color: #79a8ff;">"Cannot create the file!"</span> <span style="color: #ffffff;">}</span>;
           <span style="color: #ffffff;">}</span>
       <span style="color: #ffffff;">}</span>

       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">log</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">char</span>* <span style="color: #ffffff;">p</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">fprintf</span><span style="color: #ffffff;">(</span>m_f, <span style="color: #79a8ff;">"%s\n"</span>, p<span style="color: #ffffff;">)</span>;
       <span style="color: #ffffff;">}</span>

       ~<span style="color: #feacd0;">Logger</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #feacd0;">if </span><span style="color: #ffffff;">(</span>m_f<span style="color: #ffffff;">)</span>
           <span style="color: #ffffff;">{</span>
               <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">fclose</span><span style="color: #ffffff;">(</span>m_f<span style="color: #ffffff;">)</span>;
           <span style="color: #ffffff;">}</span>
       <span style="color: #ffffff;">}</span>

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">FILE</span>* <span style="color: #ffffff;">m_f</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">When this function is called with a Logger object, values of that Logger object will be copied to object 'y' by the defaulted copy constructor. The problem is the Logger class has a pointer data member(m_f) and it will be also copied, meaning the same pointer will be used by 2 different objects ('caller object' and 'y'). This will cause a problem when the desctructor is called for those objects.</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">Logger</span> <span style="color: #ffffff;">y</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This will also write to file 'log.txt' because file(m_f) is copied from the caller object.</span>
       y.<span style="color: #feacd0;">log</span><span style="color: #ffffff;">(</span><span style="color: #79a8ff;">"y"</span><span style="color: #ffffff;">)</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The destructor will be called here for 'y', and the file(m_f) will be closed in the desctructor.</span>
   <span style="color: #ffffff;">}</span>

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">Logger</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">{</span> <span style="color: #79a8ff;">"log.txt"</span> <span style="color: #ffffff;">}</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This will write to file 'log.txt'</span>
       x.<span style="color: #feacd0;">log</span><span style="color: #ffffff;">(</span><span style="color: #79a8ff;">"x"</span><span style="color: #ffffff;">)</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Object 'x' will be copied to object 'y' (parameter of the func()).</span>
       <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">From this point, the file pointer(m_f) inside object 'x' has become dangling pointer, and it will cause an undefined behaviour if we use it again.</span>

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The destructor will be called here for object 'x', but the file(m_f) is already closed/freed when the destructor of 'y' object was called, because the value of 'm_f' was copied to object 'y' when we called the func().</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This will cause an undefined behaviour because we double free.</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
<code>explicitly defined copy constructor</code> to make deep-copy of the pointer <code>data member</code> instead of shallow-copy:
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">String</span>
  <span style="color: #ffffff;">{</span>
  <span style="color: #b6a0ff;">public</span>:
      <span style="color: #feacd0;">String</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">default</span>;
      <span style="color: #feacd0;">String</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">char</span>* <span style="color: #ffffff;">str</span><span style="color: #ffffff;">)</span> : m_len<span style="color: #ffffff;">{</span> <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">strlen</span><span style="color: #ffffff;">(</span>str<span style="color: #ffffff;">)</span> <span style="color: #ffffff;">}</span>, m_str<span style="color: #ffffff;">{</span> <span style="color: #b6a0ff;">static_cast</span>&lt;<span style="color: #6ae4b9;">char</span>*&gt;<span style="color: #ffffff;">(</span><span style="color: #feacd0;">malloc</span><span style="color: #ffffff;">(</span>m_len + <span style="color: #00bcff;">1</span><span style="color: #ffffff;">))</span> <span style="color: #ffffff;">}</span>
      <span style="color: #ffffff;">{</span>
          <span style="color: #feacd0;">if </span><span style="color: #ffffff;">(</span><span style="color: #ff5f59; font-weight: bold;">!</span>m_str<span style="color: #ffffff;">)</span>
          <span style="color: #ffffff;">{</span>
              <span style="color: #b6a0ff;">throw</span> <span style="color: #00bcff;">std</span>::runtime_error<span style="color: #ffffff;">{</span> <span style="color: #79a8ff;">"Cannot allocate memory!"</span> <span style="color: #ffffff;">}</span>;
          <span style="color: #ffffff;">}</span>

          <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">strcpy</span><span style="color: #ffffff;">(</span>m_str, str<span style="color: #ffffff;">)</span>;
      <span style="color: #ffffff;">}</span>

      <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Explicitly defined copy construtor to make deep-copy instead of shallow-copy to prevent copying pointers.</span>
      <span style="color: #feacd0;">String</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">String</span>&amp; <span style="color: #ffffff;">other</span><span style="color: #ffffff;">)</span> : m_len<span style="color: #ffffff;">{</span> other.m_len <span style="color: #ffffff;">}</span>, m_str<span style="color: #ffffff;">{</span> <span style="color: #b6a0ff;">static_cast</span>&lt;<span style="color: #6ae4b9;">char</span>*&gt;<span style="color: #ffffff;">(</span><span style="color: #feacd0;">malloc</span><span style="color: #ffffff;">(</span>m_len + <span style="color: #00bcff;">1</span><span style="color: #ffffff;">))</span> <span style="color: #ffffff;">}</span>
      <span style="color: #ffffff;">{</span>
          <span style="color: #feacd0;">if </span><span style="color: #ffffff;">(</span><span style="color: #ff5f59; font-weight: bold;">!</span>m_str<span style="color: #ffffff;">)</span>
          <span style="color: #ffffff;">{</span>
              <span style="color: #b6a0ff;">throw</span> <span style="color: #00bcff;">std</span>::runtime_error<span style="color: #ffffff;">{</span> <span style="color: #79a8ff;">"Cannot allocate memory!"</span> <span style="color: #ffffff;">}</span>;
          <span style="color: #ffffff;">}</span>

          <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">strcpy</span><span style="color: #ffffff;">(</span>m_str, other.m_str<span style="color: #ffffff;">)</span>;
      <span style="color: #ffffff;">}</span>

      <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">print</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span>
      <span style="color: #ffffff;">{</span>
          <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">'['</span> &lt;&lt; m_str &lt;&lt; <span style="color: #79a8ff;">"]\n"</span>;
      <span style="color: #ffffff;">}</span>

      <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9;">size_t</span> <span style="color: #feacd0;">length</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span>
      <span style="color: #ffffff;">{</span>
          <span style="color: #b6a0ff;">return</span> m_len;        
      <span style="color: #ffffff;">}</span>

      ~<span style="color: #feacd0;">String</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
      <span style="color: #ffffff;">{</span>
          <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">free</span><span style="color: #ffffff;">(</span>m_str<span style="color: #ffffff;">)</span>;
      <span style="color: #ffffff;">}</span>

  <span style="color: #b6a0ff;">private</span>:
      <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9;">size_t</span> <span style="color: #ffffff;">m_len</span>;
      <span style="color: #6ae4b9;">char</span>* <span style="color: #ffffff;">m_str</span>;
  <span style="color: #ffffff;">}</span>;

  <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">String</span> <span style="color: #ffffff;">y</span><span style="color: #ffffff;">)</span>
  <span style="color: #ffffff;">{</span>
      <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"func() is called\n"</span>;
      y.<span style="color: #feacd0;">print</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

      <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The desctructor for object 'y' will be called here and the memory allocated for object 'y' will be freed.</span>
  <span style="color: #ffffff;">}</span>

  <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
  <span style="color: #ffffff;">{</span>
      <span style="color: #6ae4b9;">String</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">{</span> <span style="color: #79a8ff;">"Hello world!"</span> <span style="color: #ffffff;">}</span>;

      x.<span style="color: #feacd0;">print</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

      <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span>;

      x.<span style="color: #feacd0;">print</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
      <span style="color: #00bcff;">std</span>::cout &lt;&lt; x.<span style="color: #feacd0;">length</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

      <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The desctructor for object 'x' will be called here and the memory allocated for object 'x' will be freed.</span>
      <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">In this case there is no double free because explicitly defined copy constructor didn't copy the pointer instead it allocated new memory space for the new String object. Both of the objects will print "Hello world!" but they store it in different memory spaces.</span>
  <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</li>
<li><a id="org8d5bdcb"></a>Copy assignment operator/function<br />
<div class="outline-text-5" id="text-org8d5bdcb">
<p>
The <code>copy assignment operator</code> is called when a <code>class object</code> is assigned to another <code>L-value class object</code> of the same type. There is no instantiation when the <code>copy assignment operator</code> is called, because to assign one <code>class object</code> to another <code>class object</code>, both <code>class objects</code> must already be instantiated. The <code>copy assignment operator</code> takes a <code>const L-value reference</code> parameter of that class type and <code>returns</code> <code>L-value reference</code> of the same class type.
</p>

<p>
<code>copy assignment operator</code> which is <code>defaulted</code> by the compiler must be:
</p>
<ul class="org-ul">
<li><code>non-static</code></li>
<li><code>inline</code> (because it will be defined in <code>class definition</code>, meaning it is implicitly <code>inline</code>)</li>
<li><code>public</code></li>
</ul>
<p>
function of a class.
</p>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
        <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The compiler will generate something like this as a copy assignment operator. All non-static data members are assigned by copying their values from other class object's non-static data members. Assignments will be in declaration order.</span>
       <span style="color: #989898; font-style: italic;">//</span><span style="color: #989898; font-style: italic;">C1&amp; operator=(const C1&amp; other)</span>
       <span style="color: #989898; font-style: italic;">//</span><span style="color: #989898; font-style: italic;">{</span>
       <span style="color: #989898; font-style: italic;">//    </span><span style="color: #989898; font-style: italic;">ax = other.ax;</span>
       <span style="color: #989898; font-style: italic;">//    </span><span style="color: #989898; font-style: italic;">bx = other.bx;</span>
       <span style="color: #989898; font-style: italic;">//</span>
       <span style="color: #989898; font-style: italic;">//    </span><span style="color: #989898; font-style: italic;">return *this;</span>
       <span style="color: #989898; font-style: italic;">//</span><span style="color: #989898; font-style: italic;">}</span>

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">ax</span>;
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">bx</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
<code>explicitly declared copy assignment operator</code> example:
</p>
<div class="org-src-container">
<pre class="src src-C++">    <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">Date</span>
    <span style="color: #ffffff;">{</span>
    <span style="color: #b6a0ff;">public</span>:
        <span style="color: #feacd0;">Date</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">d</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">m</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span><span style="color: #ffffff;">)</span> : md<span style="color: #ffffff;">{</span> d <span style="color: #ffffff;">}</span>, mm<span style="color: #ffffff;">{</span> m <span style="color: #ffffff;">}</span>, my<span style="color: #ffffff;">{</span> y <span style="color: #ffffff;">}</span> <span style="color: #ffffff;">{</span> <span style="color: #ffffff;">}</span>
        <span style="color: #6ae4b9;">Date</span>&amp; <span style="color: #b6a0ff;">operator</span><span style="color: #feacd0;">=</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">Date</span>&amp; <span style="color: #ffffff;">other</span><span style="color: #ffffff;">)</span>
        <span style="color: #ffffff;">{</span>
            md = other.md;
            mm = other.mm;
            my = other.my;
            
            <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">" &amp;other: "</span> &lt;&lt; &amp;other &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;

            <span style="color: #b6a0ff;">return</span> *<span style="color: #b6a0ff;">this</span>;
        <span style="color: #ffffff;">}</span>
    <span style="color: #b6a0ff;">private</span>:
        <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">md</span><span style="color: #ffffff;">{</span> <span style="color: #00bcff;">1</span> <span style="color: #ffffff;">}</span>, <span style="color: #ffffff;">mm</span><span style="color: #ffffff;">{</span> <span style="color: #00bcff;">1</span> <span style="color: #ffffff;">}</span>, <span style="color: #ffffff;">my</span><span style="color: #ffffff;">{</span> <span style="color: #00bcff;">1990</span> <span style="color: #ffffff;">}</span>;
    <span style="color: #ffffff;">}</span>;

    <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
    <span style="color: #ffffff;">{</span>
        <span style="color: #6ae4b9;">Date</span> <span style="color: #ffffff;">dx</span><span style="color: #ffffff;">{</span> <span style="color: #00bcff;">12</span>, <span style="color: #00bcff;">8</span>, <span style="color: #00bcff;">1999</span> <span style="color: #ffffff;">}</span>;
        <span style="color: #6ae4b9;">Date</span> <span style="color: #ffffff;">dy</span><span style="color: #ffffff;">{</span> <span style="color: #00bcff;">9</span>, <span style="color: #00bcff;">8</span>, <span style="color: #00bcff;">1966</span> <span style="color: #ffffff;">}</span>;

        dy = dx;
        
        <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"&amp;dy: "</span> &lt;&lt; &amp;dy &lt;&lt; <span style="color: #79a8ff;">" &amp;dx: "</span> &lt;&lt; &amp;dx &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
    <span style="color: #ffffff;">}</span>

    <span style="color: #989898; font-style: italic;">/*</span>
<span style="color: #989898; font-style: italic;">         'this pointer' will be address of dy and address of other will be equal to address of dx.</span>
<span style="color: #989898; font-style: italic;">         Output:</span>
<span style="color: #989898; font-style: italic;">         this: &lt;address of this&gt; &amp;other: &lt;address of other&gt;</span>
<span style="color: #989898; font-style: italic;">         dy: &lt;address of dy&gt; dx: &lt;address of dx&gt;</span>
<span style="color: #989898; font-style: italic;">    */</span>
</pre>
</div>

<p>
Similar to the <code>copy constructor</code>, there are some cases where the <code>copy assignment operator</code> also needs to be <code>explicitly defined</code> to prevent logical errors which can cause memory/resource leaks. Similarly, we can say that if the <code>destructor</code> is <code>explicitly defined</code> for a class, typically the <code>copy assignment operator</code> also needs to be <code>explicitly defined</code> because most of the time it means we have some memory/resource to manage.
</p>

<p>
<code>explicitly defined copy assignment</code> to make deep-copy of the pointer <code>data member</code> instead of shallow-copy:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">String</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">String</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">default</span>;
       <span style="color: #feacd0;">String</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">char</span>* <span style="color: #ffffff;">str</span><span style="color: #ffffff;">)</span> : m_len<span style="color: #ffffff;">{</span> <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">strlen</span><span style="color: #ffffff;">(</span>str<span style="color: #ffffff;">)</span> <span style="color: #ffffff;">}</span>, m_str<span style="color: #ffffff;">{</span> <span style="color: #b6a0ff;">static_cast</span>&lt;<span style="color: #6ae4b9;">char</span>*&gt;<span style="color: #ffffff;">(</span><span style="color: #feacd0;">malloc</span><span style="color: #ffffff;">(</span>m_len + <span style="color: #00bcff;">1</span><span style="color: #ffffff;">))</span> <span style="color: #ffffff;">}</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #feacd0;">if </span><span style="color: #ffffff;">(</span><span style="color: #ff5f59; font-weight: bold;">!</span>m_str<span style="color: #ffffff;">)</span>
           <span style="color: #ffffff;">{</span>
               <span style="color: #b6a0ff;">throw</span> <span style="color: #00bcff;">std</span>::runtime_error<span style="color: #ffffff;">{</span> <span style="color: #79a8ff;">"Cannot allocate memory!"</span> <span style="color: #ffffff;">}</span>;
           <span style="color: #ffffff;">}</span>

           <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">strcpy</span><span style="color: #ffffff;">(</span>m_str, str<span style="color: #ffffff;">)</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Explicitly defined copy assignment operator to make deep-copy instead of shallow-copy to prevent copying pointers.</span>
       <span style="color: #6ae4b9;">String</span>&amp; <span style="color: #b6a0ff;">operator</span><span style="color: #feacd0;">=</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">String</span>&amp; <span style="color: #ffffff;">other</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Return directly if the object is assigned to itself.</span>
           <span style="color: #feacd0;">if </span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">this</span> == &amp;other<span style="color: #ffffff;">)</span>
           <span style="color: #ffffff;">{</span>
               <span style="color: #b6a0ff;">return</span> *<span style="color: #b6a0ff;">this</span>;
           <span style="color: #ffffff;">}</span>

           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is just for demonstration.</span>
           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">We free already existing resource and reallocate for new string.</span>
           <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">free</span><span style="color: #ffffff;">(</span>m_str<span style="color: #ffffff;">)</span>;

           m_len = other.m_len;
           m_str = <span style="color: #b6a0ff;">static_cast</span>&lt;<span style="color: #6ae4b9;">char</span>*&gt;<span style="color: #ffffff;">(</span><span style="color: #feacd0;">malloc</span><span style="color: #ffffff;">(</span>m_len + <span style="color: #00bcff;">1</span><span style="color: #ffffff;">))</span>;

           <span style="color: #feacd0;">if </span><span style="color: #ffffff;">(</span><span style="color: #ff5f59; font-weight: bold;">!</span>m_str<span style="color: #ffffff;">)</span>
           <span style="color: #ffffff;">{</span>
               <span style="color: #b6a0ff;">throw</span> <span style="color: #00bcff;">std</span>::runtime_error<span style="color: #ffffff;">{</span> <span style="color: #79a8ff;">"Cannot allocate memory!"</span> <span style="color: #ffffff;">}</span>;
           <span style="color: #ffffff;">}</span>

           <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">strcpy</span><span style="color: #ffffff;">(</span>m_str, other.m_str<span style="color: #ffffff;">)</span>;

           <span style="color: #b6a0ff;">return</span> *<span style="color: #b6a0ff;">this</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">print</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">'['</span> &lt;&lt; m_str &lt;&lt; <span style="color: #79a8ff;">"]\n"</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9;">size_t</span> <span style="color: #feacd0;">length</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #b6a0ff;">return</span> m_len;        
       <span style="color: #ffffff;">}</span>

       ~<span style="color: #feacd0;">String</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">free</span><span style="color: #ffffff;">(</span>m_str<span style="color: #ffffff;">)</span>;
       <span style="color: #ffffff;">}</span>

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9;">size_t</span> <span style="color: #ffffff;">m_len</span>;
       <span style="color: #6ae4b9;">char</span>* <span style="color: #ffffff;">m_str</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">String</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">{</span> <span style="color: #79a8ff;">"Hello world!"</span> <span style="color: #ffffff;">}</span>;
       <span style="color: #6ae4b9;">String</span> <span style="color: #ffffff;">y</span><span style="color: #ffffff;">{</span> <span style="color: #79a8ff;">"y"</span> <span style="color: #ffffff;">}</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The copy assignment will be called for object 'x'.</span>
       x = y;

       x.<span style="color: #feacd0;">print</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The desctructor for object 'x' will be called here and the memory allocated for object 'x' will be freed.</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</li>
<li><a id="org5e658f7"></a>Move constructor<br />
<div class="outline-text-5" id="text-org5e658f7">
<p>
The <code>move constructor</code> is called when a <code>class object</code> instantiated by transfering/stealing its value from another <code>class object</code> of the same type. The <code>move constructor</code> has the same name as the class and takes a <code>R-value reference</code> parameter of that class type. Unlike the <code>copy constructor</code>, the <code>move constructor</code> does not copy values but moves/transfers/steals them.
</p>

<p>
<code>move constructor</code> which is <code>defaulted</code> by the compiler must be:
</p>
<ul class="org-ul">
<li><code>non-static</code></li>
<li><code>inline</code> (because it will be defined in <code>class definition</code>, meaning it is implicitly <code>inline</code>)</li>
<li><code>public</code></li>
</ul>
<p>
function of a class.
</p>

<p>
The compiler will generate code for a <code>move constructor</code> that initializes all <code>non-static data members</code> by stealing their value from the <code>class object</code> being moved:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The compiler will generate something like this as a move constructor. All non-static data members are initialized by stealing their value from other class object. Initilization will be in declaration order as in other constructors. After the object is instantiated the move constructor sets transfered/stealed values of the other object to valid but unspecified state. Additionaly, if a non-static data member is another class object its move constructor will also be called. In this example, the move constructor of std::string (cx) object will be called. To be able to call the move constructor for cx std::move is needed because other.cx is L-value expression and it must be converted to R-value reference by using std::move to call the move constructor. If we do not convert it to R-value reference by using std::move the copy constructor would be called instead of the move constructor.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1(const C1&amp; other) : ax(other.ax), bx(other.bx), cx(std::move(other.cx))</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">{</span>
              <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">other.ax = 0;</span>
              <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">other.bx = 0;</span>
              <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The compiler can also add extra code depending on its implementation.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">}</span>
   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">ax</span>;
       <span style="color: #6ae4b9;">double</span> <span style="color: #ffffff;">bx</span>;
       <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9;">string</span> <span style="color: #ffffff;">cx</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
<code>explicitly defined move constructor</code> to move the object instead of copying:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">String</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">String</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">default</span>;
       <span style="color: #feacd0;">String</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">char</span>* <span style="color: #ffffff;">str</span><span style="color: #ffffff;">)</span> : m_len<span style="color: #ffffff;">{</span> <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">strlen</span><span style="color: #ffffff;">(</span>str<span style="color: #ffffff;">)</span> <span style="color: #ffffff;">}</span>, m_str<span style="color: #ffffff;">{</span> <span style="color: #b6a0ff;">static_cast</span>&lt;<span style="color: #6ae4b9;">char</span>*&gt;<span style="color: #ffffff;">(</span><span style="color: #feacd0;">malloc</span><span style="color: #ffffff;">(</span>m_len + <span style="color: #00bcff;">1</span><span style="color: #ffffff;">))</span> <span style="color: #ffffff;">}</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #feacd0;">if </span><span style="color: #ffffff;">(</span><span style="color: #ff5f59; font-weight: bold;">!</span>m_str<span style="color: #ffffff;">)</span>
           <span style="color: #ffffff;">{</span>
               <span style="color: #b6a0ff;">throw</span> <span style="color: #00bcff;">std</span>::runtime_error<span style="color: #ffffff;">{</span> <span style="color: #79a8ff;">"Cannot allocate memory!"</span> <span style="color: #ffffff;">}</span>;
           <span style="color: #ffffff;">}</span>

           <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">strcpy</span><span style="color: #ffffff;">(</span>m_str, str<span style="color: #ffffff;">)</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Explicitly defined move construtor to move the object instead of making deep copy. </span>
       <span style="color: #feacd0;">String</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">String</span>&amp;&amp; <span style="color: #ffffff;">other</span><span style="color: #ffffff;">)</span> : m_len<span style="color: #ffffff;">{</span> other.m_len <span style="color: #ffffff;">}</span>, m_str<span style="color: #ffffff;">{</span> other.m_str <span style="color: #ffffff;">}</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">m_str and m_len values are stealed from other.m_str and other.m_len.</span>
           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">We also set other.m_str and other.m_len to valid but unspecified state (usually 0, nullptr)</span>
           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">so the destructor will not be called for the moved object and if it is possible it can be used</span>
           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">later by assigning another object etc.</span>
           other.m_str = <span style="color: #00bcff;">nullptr</span>;
           other.m_len = <span style="color: #00bcff;">0</span>;
       <span style="color: #ffffff;">}</span>
       
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">print</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">'['</span> &lt;&lt; m_str &lt;&lt; <span style="color: #79a8ff;">"]\n"</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9;">size_t</span> <span style="color: #feacd0;">length</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #b6a0ff;">return</span> m_len;        
       <span style="color: #ffffff;">}</span>

       ~<span style="color: #feacd0;">String</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This check is needed after we implement the move constructor because if the object is moved the destructor should not be called for the object.</span>
           <span style="color: #feacd0;">if </span><span style="color: #ffffff;">(</span>m_str<span style="color: #ffffff;">)</span>
           <span style="color: #ffffff;">{</span>
               <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">free</span><span style="color: #ffffff;">(</span>m_str<span style="color: #ffffff;">)</span>;
           <span style="color: #ffffff;">}</span>
       <span style="color: #ffffff;">}</span>

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9;">size_t</span> <span style="color: #ffffff;">m_len</span>;
       <span style="color: #6ae4b9;">char</span>* <span style="color: #ffffff;">m_str</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">String</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">String</span> <span style="color: #ffffff;">str</span><span style="color: #ffffff;">{</span> <span style="color: #79a8ff;">"func"</span> <span style="color: #ffffff;">}</span>;
       <span style="color: #b6a0ff;">return</span> str;
   <span style="color: #ffffff;">}</span>

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The move constructor will be called for object 'x', because the return value of func() is R-value.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">First, the constructor will be called for str{ "func" } then its resources will be moved the</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">objext 'x' by calling x's move constructor.</span>
       <span style="color: #6ae4b9;">String</span> <span style="color: #ffffff;">x</span> = <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

       x.<span style="color: #feacd0;">print</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The desctructor for object 'x' will be called here and the memory allocated for object 'x' will be freed.</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</li>
<li><a id="org133e712"></a>Move assignment operator/function<br />
<div class="outline-text-5" id="text-org133e712">
<p>
The <code>move assignment operator</code> is called when a <code>class object</code> is assigned to another <code>R-value class object</code> of the same type. There is no instantiation when the <code>move assignment operator</code> is called, because to assign one <code>class object</code> to another <code>class object</code>, both <code>class objects</code> must already be instantiated. The <code>move assignment operator</code> takes a <code>R-value reference</code> parameter of that class type and <code>returns</code> <code>L-value reference</code> of the same class type.
</p>

<p>
<code>move assignment operator</code> which is <code>defaulted</code> by the compiler must be:
</p>
<ul class="org-ul">
<li><code>non-static</code></li>
<li><code>inline</code> (because it will be defined in <code>class definition</code>, meaning it is implicitly <code>inline</code>)</li>
<li><code>public</code></li>
</ul>
<p>
function of a class.
</p>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
        <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The compiler will generate something like this as a move assignment operator. All non-static data members are assigned by stealing their values from other class object's non-static data members. Assignments will be in declaration order.</span>
       <span style="color: #989898; font-style: italic;">//</span><span style="color: #989898; font-style: italic;">C1&amp; operator=(C1&amp;&amp; other)</span>
       <span style="color: #989898; font-style: italic;">//</span><span style="color: #989898; font-style: italic;">{</span>
       <span style="color: #989898; font-style: italic;">//    </span><span style="color: #989898; font-style: italic;">ax = other.ax;</span>
       <span style="color: #989898; font-style: italic;">//    </span><span style="color: #989898; font-style: italic;">bx = other.bx;</span>
       <span style="color: #989898; font-style: italic;">//</span>
       <span style="color: #989898; font-style: italic;">//    </span><span style="color: #989898; font-style: italic;">other.ax = 0;</span>
       <span style="color: #989898; font-style: italic;">//    </span><span style="color: #989898; font-style: italic;">other.bx = 0;</span>
       <span style="color: #989898; font-style: italic;">//</span>
       <span style="color: #989898; font-style: italic;">//    </span><span style="color: #989898; font-style: italic;">return *this;</span>
       <span style="color: #989898; font-style: italic;">//</span><span style="color: #989898; font-style: italic;">}</span>

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">ax</span>;
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">bx</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
<code>explicitly defined move assignment</code> to move the object instead of copying:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">String</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">String</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">default</span>;
       <span style="color: #feacd0;">String</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">char</span>* <span style="color: #ffffff;">str</span><span style="color: #ffffff;">)</span> : m_len<span style="color: #ffffff;">{</span> <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">strlen</span><span style="color: #ffffff;">(</span>str<span style="color: #ffffff;">)</span> <span style="color: #ffffff;">}</span>, m_str<span style="color: #ffffff;">{</span> <span style="color: #b6a0ff;">static_cast</span>&lt;<span style="color: #6ae4b9;">char</span>*&gt;<span style="color: #ffffff;">(</span><span style="color: #feacd0;">malloc</span><span style="color: #ffffff;">(</span>m_len + <span style="color: #00bcff;">1</span><span style="color: #ffffff;">))</span> <span style="color: #ffffff;">}</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #feacd0;">if </span><span style="color: #ffffff;">(</span><span style="color: #ff5f59; font-weight: bold;">!</span>m_str<span style="color: #ffffff;">)</span>
           <span style="color: #ffffff;">{</span>
               <span style="color: #b6a0ff;">throw</span> <span style="color: #00bcff;">std</span>::runtime_error<span style="color: #ffffff;">{</span> <span style="color: #79a8ff;">"Cannot allocate memory!"</span> <span style="color: #ffffff;">}</span>;
           <span style="color: #ffffff;">}</span>

           <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">strcpy</span><span style="color: #ffffff;">(</span>m_str, str<span style="color: #ffffff;">)</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Explicitly defined move assignment to move the object instead of making deep copy. </span>
       <span style="color: #6ae4b9;">String</span>&amp; <span style="color: #b6a0ff;">operator</span><span style="color: #feacd0;">=</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">String</span>&amp;&amp; <span style="color: #ffffff;">other</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Return directly if the object is assigned to itself.</span>
           <span style="color: #feacd0;">if </span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">this</span> == &amp;other<span style="color: #ffffff;">)</span>
           <span style="color: #ffffff;">{</span>
               <span style="color: #b6a0ff;">return</span> *<span style="color: #b6a0ff;">this</span>;
           <span style="color: #ffffff;">}</span>

           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Free the resource we already have first.</span>
           <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">free</span><span style="color: #ffffff;">(</span>m_str<span style="color: #ffffff;">)</span>;

           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Steals the values of other</span>
           m_str = other.m_str;
           m_len = other.m_len;
           other.m_str = <span style="color: #00bcff;">nullptr</span>;
           other.m_len = <span style="color: #00bcff;">0</span>;

           <span style="color: #b6a0ff;">return</span> *<span style="color: #b6a0ff;">this</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">print</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">'['</span> &lt;&lt; m_str &lt;&lt; <span style="color: #79a8ff;">"]\n"</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9;">size_t</span> <span style="color: #feacd0;">length</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #b6a0ff;">return</span> m_len;        
       <span style="color: #ffffff;">}</span>

       ~<span style="color: #feacd0;">String</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This check is needed after we implement the move constructor and move assignment because if the object is moved the destructor should not be called for the object.</span>
           <span style="color: #feacd0;">if </span><span style="color: #ffffff;">(</span>m_str<span style="color: #ffffff;">)</span>
           <span style="color: #ffffff;">{</span>
               <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">free</span><span style="color: #ffffff;">(</span>m_str<span style="color: #ffffff;">)</span>;
           <span style="color: #ffffff;">}</span>
       <span style="color: #ffffff;">}</span>

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9;">size_t</span> <span style="color: #ffffff;">m_len</span>;
       <span style="color: #6ae4b9;">char</span>* <span style="color: #ffffff;">m_str</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">String</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">{</span> <span style="color: #79a8ff;">"x"</span> <span style="color: #ffffff;">}</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The move assignment operator of 'x' will be called and the resources of String{ "y" } object will be transfered to 'x'.</span>
       x = String<span style="color: #ffffff;">{</span> <span style="color: #79a8ff;">"y"</span> <span style="color: #ffffff;">}</span>;

       x.<span style="color: #feacd0;">print</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The desctructor for object 'x' will be called here and the memory allocated for object 'x' will be freed.</span>
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</li>
<li><a id="org1fe40b4"></a>When special member functions are defaulted, deleted or not declared by the compiler?<br />
<div class="outline-text-5" id="text-org1fe40b4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">User declared / Implicitly declared by the compiler</th>
<th scope="col" class="org-left">Default constructor</th>
<th scope="col" class="org-left">Destructor</th>
<th scope="col" class="org-left">Copy constructor</th>
<th scope="col" class="org-left">Copy assignment</th>
<th scope="col" class="org-left">Move constructor</th>
<th scope="col" class="org-left">Move assignment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Nothing</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
</tr>

<tr>
<td class="org-left">Any constructor</td>
<td class="org-left">not declared</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
</tr>

<tr>
<td class="org-left">Default constructor</td>
<td class="org-left">user declared</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
</tr>

<tr>
<td class="org-left">Destructor</td>
<td class="org-left">defaulted</td>
<td class="org-left">user declared</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">not declared</td>
<td class="org-left">not declared</td>
</tr>

<tr>
<td class="org-left">Copy constructor</td>
<td class="org-left">not declared</td>
<td class="org-left">defaulted</td>
<td class="org-left">user declared</td>
<td class="org-left">defaulted</td>
<td class="org-left">not declared</td>
<td class="org-left">not declared</td>
</tr>

<tr>
<td class="org-left">Copy assignment</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">user declared</td>
<td class="org-left">not declared</td>
<td class="org-left">not declared</td>
</tr>

<tr>
<td class="org-left">Move constructor</td>
<td class="org-left">not declared</td>
<td class="org-left">defaulted</td>
<td class="org-left">deleted</td>
<td class="org-left">deleted</td>
<td class="org-left">user declared</td>
<td class="org-left">not declared</td>
</tr>

<tr>
<td class="org-left">Move assignment</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">deleted</td>
<td class="org-left">deleted</td>
<td class="org-left">not declared</td>
<td class="org-left">user declared</td>
</tr>
</tbody>
</table>

<p>
In summary:
</p>
<ul class="org-ul">
<li>If <code>destructor</code> is not <code>user declared</code>, it is always <code>defaulted</code>.</li>
<li>If any <code>constructor</code> (non-special or special) is <code>user declared</code>, <code>default constructor</code> is <code>not declared</code> and otherwise it is <code>defaulted</code>.</li>
<li>If one of <code>destructor</code>, <code>copy constructor</code> or <code>copy assignment operator</code> is <code>user declared</code>, <code>move members</code> are <code>not declared</code>.</li>
<li>If one of <code>move constructor</code> or <code>move assignment operator</code> is <code>user declared</code>, <code>copy members</code> are <code>deleted</code>, and other <code>move member</code> is <code>not declared</code>.</li>
</ul>

<p>
When nothing is <code>user declared</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1() = default;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">~C1() = default;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1(const C1&amp;) = default;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1&amp; operator=(const C1&amp;) = default;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1(C1&amp;&amp;) = default;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1&amp; operator=(C1&amp;&amp;) = default;</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
When the <code>default constructor</code> is <code>user declared</code>: 
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">default</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">~C1() = default;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1(const C1&amp;) = default;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1&amp; operator=(const C1&amp;) = default;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1(C1&amp;&amp;) = default;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1&amp; operator=(C1&amp;&amp;) = default;</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
When the <code>destructor</code> is <code>user declared</code>: 
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1() = default;</span>
       ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">default</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1(const C1&amp;) = default;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1&amp; operator=(const C1&amp;) = default;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Move constructor is not declared.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Move assignment operator is not declared.</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
When the <code>copy constructor</code> is <code>user declared</code>: 
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Default constructor is not declared.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">~C1() = default;</span>
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">C1</span>&amp;<span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">default</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1&amp; operator=(const C1&amp;) = default;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Move constructor is not declared.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Move assignment operator is not declared.</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
When the <code>copy assignment operator</code> is <code>user declared</code>: 
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1() = default;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">~C1() = default;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1(const C1&amp;) = default;</span>
       <span style="color: #6ae4b9;">C1</span>&amp; <span style="color: #b6a0ff;">operator</span><span style="color: #feacd0;">=</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">C1</span>&amp;<span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">default</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Move constructor is not declared.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Move assignment operator is not declared.</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
When the <code>move constructor</code> is <code>user declared</code>: 
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Default constructor is not declared.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">~C1() = default;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1(const C1&amp;) = delete;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1&amp; operator=(const C1&amp;) = delete;</span>
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">C1</span>&amp;&amp;<span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">default</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Move assignment operator is not declared.</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
When the <code>move assignment operator</code> is <code>user declared</code>: 
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1() = default;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">~C1() = default;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1(const C1&amp;) = delete;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1&amp; operator=(const C1&amp;) = delete;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Move constructor is not declared.</span>
       <span style="color: #6ae4b9;">C1</span>&amp; <span style="color: #b6a0ff;">operator</span><span style="color: #feacd0;">=</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">C1</span>&amp;&amp;<span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">default</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
It is possible to define a <code>class</code> which cannot be copied or moved:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">C1</span>&amp;<span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">delete</span>;
       <span style="color: #6ae4b9;">C1</span>&amp; <span style="color: #b6a0ff;">operator</span><span style="color: #feacd0;">=</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">C1</span>&amp;<span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">delete</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Move constructor and move assignment operator is not declared because copy members are user declared.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">~C1() = default;</span>

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This class cannot be copied or moved. Copy members are deleted by user and move members are not declared.</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1a</span>;
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1b</span> = c1a; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is a syntax error. A deleted function(the copy constructor) cannot be referenced.</span>

       <span style="color: #b6a0ff;">return</span> <span style="color: #00bcff;">0</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
It is also possible to define a <code>class</code> which cannot be copied but can be moved:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>;
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">C1</span>&amp;<span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">delete</span>;
       <span style="color: #6ae4b9;">C1</span>&amp; <span style="color: #b6a0ff;">operator</span><span style="color: #feacd0;">=</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">C1</span>&amp;<span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">delete</span>;
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">C1</span>&amp;&amp;<span style="color: #ffffff;">)</span>;
       <span style="color: #6ae4b9;">C1</span>&amp; <span style="color: #b6a0ff;">operator</span><span style="color: #feacd0;">=</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">C1</span>&amp;&amp;<span style="color: #ffffff;">)</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">~C1() = default;</span>

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This class cannot be copied but can be moved.</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1a</span>;
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1b</span> = c1a; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is a syntax error. A deleted function(the copy constructor) cannot be referenced.</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1c</span> = <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">move</span><span style="color: #ffffff;">(</span>c1a<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is valid. The object can be moved.</span>

       <span style="color: #b6a0ff;">return</span> <span style="color: #00bcff;">0</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org156f984" class="outline-4">
<h4 id="org156f984">Move Semantics</h4>
<div class="outline-text-4" id="text-org156f984">
<p>
<code>move semantics</code> allows efficient transfer of resources (memory, file handles etc.) from one object to another. It is particularly useful when dealing with expensive-to-copy objects, such as containers or objects that manage dynamic resources. <code>R-value references</code> enable <code>move semantics</code> by binding to <code>temporary objects</code> (<code>R-value expressions</code>) that are about to go out of scope. <code>move constructor</code> and <code>move assignment operator</code> are used for transfering ownership of resources from one object to another.
</p>

<p>
Resource to check: <a href="https://accu.org/conf-docs/PDFs_2014/Howard_Hinnant_Accu_2014.pdf">Everything You Ever Wanted To Know About Move Semantics</a>
</p>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">C1</span>&amp;<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Copy constructor</span>
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">C1</span>&amp;&amp;<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Move constructor</span>

       <span style="color: #6ae4b9;">C1</span>&amp; <span style="color: #b6a0ff;">operator</span><span style="color: #feacd0;">=</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">C1</span>&amp;<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Copy assignment</span>
       <span style="color: #6ae4b9;">C1</span>&amp; <span style="color: #b6a0ff;">operator</span><span style="color: #feacd0;">=</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">C1</span>&amp;&amp;<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Move assignment</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">C1</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1a</span>;
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1b</span> = c1a; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">c1a is L-value, copy constructor will be called and resources will be copied from c1a to c1b.</span>
       c1b = c1a; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">c1a is L-value, copy assignment will be called and resources will be copied from c1a to c1b.</span>

       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1c</span> = <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Return value of func() is R-value, move constructor will be called and resources will be transfered from returned object to c1c.</span>
       c1c = <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Return value of func() is R-value, move assignment will be called and resources will be transfered from returned object to c1c.</span>

       <span style="color: #b6a0ff;">return</span> <span style="color: #00bcff;">0</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
It is also possible to transfer the resources of <code>L-value expressions</code> by converting them to <code>R-value references</code>. <code>std::move</code> can be used for this:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">default</span>;

       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">C1</span>&amp;<span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"Copy constructor\n"</span>;
       <span style="color: #ffffff;">}</span>
       
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">C1</span>&amp;&amp;<span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"Move constructor\n"</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">C1</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1a</span>;
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1b</span> = c1a; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Copy constrcutor will be called.</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1c</span> = <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">move</span><span style="color: #ffffff;">(</span>c1b<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">c1b is L-value but we convert it to R-value reference, move constructor will be called and resources will be transfered from c1b to c1.</span>

       <span style="color: #b6a0ff;">return</span> <span style="color: #00bcff;">0</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
<code>move semantics</code> and <code>function overloading</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This overload will be called for L-value expressions.</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9;">string</span>&amp; <span style="color: #ffffff;">s</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9;">string</span> <span style="color: #feacd0;">str</span><span style="color: #ffffff;">(</span>s<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The copy constructor will be called for str.</span>
   <span style="color: #ffffff;">}</span>

   <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This overload will be called for R-value expressions.</span>
   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9;">string</span>&amp;&amp; <span style="color: #ffffff;">s</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">We still need std::move to call the move constructor because even the data type of</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">'s' is R-value reference, the value category of expression 's' is L-value expression.</span>
       <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9;">string</span> <span style="color: #feacd0;">str</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">move</span><span style="color: #ffffff;">(</span>s<span style="color: #ffffff;">))</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The move constructor will be called.</span>
   <span style="color: #ffffff;">}</span>

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9;">string</span> <span style="color: #feacd0;">s</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">100</span>, <span style="color: #79a8ff;">'+'</span><span style="color: #ffffff;">)</span>;

       <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span>s<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">void func(const std::string&amp; s) will be called.</span>
       <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">string</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">100</span>, <span style="color: #79a8ff;">'-'</span><span style="color: #ffffff;">))</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">void func(std::string&amp;&amp; s) will be called.</span>

       <span style="color: #b6a0ff;">return</span> <span style="color: #00bcff;">0</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
It is not possible to transfer/steal resources of a <code>const class object</code>. <code>const object</code> means the object will never change in its lifetime, so it cannot be moved:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">default</span>;

       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">C1</span>&amp;<span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"Copy constructor\n"</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">C1</span>&amp;&amp;<span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"Move constructor\n"</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">x</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">std::move will return const R-value reference type because object 'x' is const. Copy constructor will be choosen in function overload resolution  because according to rules const overload has the priority. So, object 'x' is copied to 'y' instead of being moved</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">y</span> = <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">move</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span>;

       <span style="color: #b6a0ff;">return</span> <span style="color: #00bcff;">0</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
It is more about the <code>function overload resolution</code> rules rather than <code>move semantics</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> = <span style="color: #b6a0ff;">default</span>;
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">C1</span>&amp;<span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"void func(const C1&amp;)\n"</span>;
   <span style="color: #ffffff;">}</span>

   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">C1</span>&amp;&amp;<span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"void func(C1&amp;&amp;)\n"</span>;
   <span style="color: #ffffff;">}</span>

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">x</span>;
       <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">cx</span>;

       <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">void func(const C1&amp;) will be called.</span>
       <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">move</span><span style="color: #ffffff;">(</span>x<span style="color: #ffffff;">))</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">void func(C1&amp;&amp;) will be called.</span>
       <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span>cx<span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">void func(const C1&amp;) will be called.</span>
       <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">move</span><span style="color: #ffffff;">(</span>cx<span style="color: #ffffff;">))</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">void func(const C1&amp;) will be called.</span>
       
       <span style="color: #b6a0ff;">return</span> <span style="color: #00bcff;">0</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org48dd706" class="outline-4">
<h4 id="org48dd706">Default member initializer / In-class initializer</h4>
<div class="outline-text-4" id="text-org48dd706">
<p>
<code>default member initializer</code> is a way to declare how <code>default initialization</code> should be done for <code>data members</code> of classes.
</p>

<p>
<code>default member initializer</code> will be used for <code>data members</code> which are not initialized explicitly:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">We do not initialize mx here but compiler will add mx{ 20 } here as default</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">because we declare default member initializer for mx. </span>
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> : my<span style="color: #ffffff;">{</span> <span style="color: #00bcff;">10</span> <span style="color: #ffffff;">}</span> <span style="color: #ffffff;">{}</span>
   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mx</span><span style="color: #ffffff;">{</span> <span style="color: #00bcff;">20</span> <span style="color: #ffffff;">}</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Default member initializer / In-class initializer</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">my</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">No default member initializer. If we don't initialize my explicity it will be default initialized to garbage value.</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
If a <code>data member</code> is initialized explicitly <code>default member initializer</code> will not be used:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">mx will be initialized to 30 and default member initializer will not be used, because mx is not default initialized.</span>
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> : mx <span style="color: #ffffff;">{</span> <span style="color: #00bcff;">30</span> <span style="color: #ffffff;">}</span> <span style="color: #ffffff;">{}</span>
   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mx</span><span style="color: #ffffff;">{</span> <span style="color: #00bcff;">20</span> <span style="color: #ffffff;">}</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Default member initializer / In-class initializer</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
<code>direct-initilization</code> syntax cannot be used for <code>default member initializer</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> : my <span style="color: #ffffff;">{</span> <span style="color: #00bcff;">30</span> <span style="color: #ffffff;">}</span> <span style="color: #ffffff;">{}</span>
   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">int mx(20); // Invalid. Syntax error.</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">my</span><span style="color: #ffffff;">{</span> <span style="color: #00bcff;">20</span> <span style="color: #ffffff;">}</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid.</span>
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mz</span> = <span style="color: #00bcff;">20</span> ; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Valid.</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-org43710c7" class="outline-4">
<h4 id="org43710c7">Delegating Constructor</h4>
<div class="outline-text-4" id="text-org43710c7">
<p>
Classes can have multiple <code>constructors</code> with a common code. In such cases, a <code>delegating constructor</code> can be used to gather the common code into a single <code>constructor</code>.
</p>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Delegating constructors</span>
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span> : <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span>x, <span style="color: #00bcff;">0</span>, <span style="color: #00bcff;">0</span><span style="color: #ffffff;">)</span> <span style="color: #ffffff;">{}</span>
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">char</span>* <span style="color: #ffffff;">p</span><span style="color: #ffffff;">)</span> : <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">atoi</span><span style="color: #ffffff;">(</span>p<span style="color: #ffffff;">)</span>, <span style="color: #00bcff;">0</span>, <span style="color: #00bcff;">0</span><span style="color: #ffffff;">)</span> <span style="color: #ffffff;">{}</span>

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This constructor will get called when other 2 constructor is called. It can also be called directly.</span>
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
If a <code>delegating constructor</code> is used for a <code>constructor</code>, the <code>non-static data members</code> cannot be initialized using <code>constructor initializer list</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Delegating constructor</span>
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span> : <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span>x, <span style="color: #00bcff;">0</span>, <span style="color: #00bcff;">0</span><span style="color: #ffffff;">)</span>, mx<span style="color: #ffffff;">{</span> <span style="color: #00bcff;">10</span> <span style="color: #ffffff;">}</span> <span style="color: #ffffff;">{}</span> <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is syntax error. If a constructor is a delegating constructor, constructor initializer list cannot be used for initializing non-static data members.</span>
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">char</span>* <span style="color: #ffffff;">p</span><span style="color: #ffffff;">)</span> : <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">atoi</span><span style="color: #ffffff;">(</span>p<span style="color: #ffffff;">)</span>, <span style="color: #00bcff;">0</span>, <span style="color: #00bcff;">0</span><span style="color: #ffffff;">)</span> <span style="color: #ffffff;">{}</span>

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This constructor will get called when other 2 constructors are called. It can also be called directly.</span>
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span>, <span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           
       <span style="color: #ffffff;">}</span>

   <span style="color: #b6a0ff;">private</span>:
       <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">mx</span>;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>

<p>
There can also be multiple <code>delegating constructors</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This delegating constructor is calling another delegating constructor</span>
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span><span style="color: #ffffff;">)</span> : <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span>x, <span style="color: #00bcff;">0</span><span style="color: #ffffff;">)</span> <span style="color: #ffffff;">{}</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is also delegating constructor</span>
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span><span style="color: #ffffff;">)</span> : <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span>x, y, <span style="color: #00bcff;">0</span><span style="color: #ffffff;">)</span> <span style="color: #ffffff;">{}</span>

       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">x</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">y</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">z</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgde3dbb3" class="outline-4">
<h4 id="orgde3dbb3">Temporary Objects</h4>
<div class="outline-text-4" id="text-orgde3dbb3">
<p>
In some cases, even if there is no visible variable in the code, the compiler can create an object according to the rules. Such objects are called <code>temporary objects</code> and have different lifetimes. Expressions created by <code>temporary objects</code> are <code>PR-value expressions</code>.
</p>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"Default constructor\n"</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">a</span>, <span style="color: #6ae4b9;">int</span> <span style="color: #ffffff;">b</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1(int a, int b), a = "</span> &lt;&lt; a &lt;&lt; <span style="color: #79a8ff;">" b = "</span> &lt;&lt; b &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>
       
       ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"Destructor\n"</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">C1</span>&amp;<span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"void func(const C1&amp;)\n"</span>;
   <span style="color: #ffffff;">}</span>

   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">C1</span>&amp;&amp;<span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"void func(C1&amp;&amp;)\n"</span>;
   <span style="color: #ffffff;">}</span>

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span>&amp; <span style="color: #ffffff;">r</span> = <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is a syntax error. C1() is a temporary object and a PR-value expression. PR-value expressions cannot be bound to L-value references.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">These are valid.</span>
       <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">C1</span>&amp; <span style="color: #ffffff;">cr</span> = <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
       <span style="color: #6ae4b9;">C1</span>&amp;&amp; <span style="color: #ffffff;">rr</span> = C1<span style="color: #ffffff;">{</span> <span style="color: #00bcff;">1</span>, <span style="color: #00bcff;">3</span> <span style="color: #ffffff;">}</span>;

       <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span>C1<span style="color: #ffffff;">{})</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">If func() is called with a temporary object, the C1&amp;&amp; overload will be called because temporary objects are PR-value expressions.</span>
       
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
The life of a <code>temporary object</code> ends after the <code>evaluation of the expression</code> in which that <code>temporary object expression</code> is contained:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"Default constructor, this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>

       ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"Destructor, this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"void func(), this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main() begins\n"</span>;
       C1<span style="color: #ffffff;">{}</span>.<span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The life of the C1{} (temporary object) has to end immediately in this point of the code. The destructor for C1{} will be called here (after the evaluation of the expression that contains temporary object, C1{}.func()).</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main() ends\n"</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
If we want to call a function with an object and never use that object again, we can use <code>temporary object</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9;">vector</span>&lt;<span style="color: #6ae4b9;">int</span>&gt;&amp; <span style="color: #ffffff;">vec</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       
   <span style="color: #ffffff;">}</span>

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">We don't need ivec after calling func() but it will live until the end of scope.</span>
       <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9;">vector</span>&lt;<span style="color: #6ae4b9;">int</span>&gt; <span style="color: #feacd0;">ivec</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">10</span>, <span style="color: #00bcff;">5</span><span style="color: #ffffff;">)</span>;
       <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span>ivec<span style="color: #ffffff;">)</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">We used a temporary object for calling func() and it will be destructed after this expression is evaluated. This prevents scope leakage.</span>
       <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">std</span>::vector&lt;<span style="color: #6ae4b9;">int</span>&gt;<span style="color: #ffffff;">(</span><span style="color: #00bcff;">10</span>, <span style="color: #00bcff;">5</span><span style="color: #ffffff;">))</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="org3c0c471"></a>Life extension<br />
<div class="outline-text-5" id="text-org3c0c471">
<p>
If a <code>temporary object</code> is bound to a <code>reference</code>, its lifetime gets extended to the end of the scope of that <code>reference</code>. This is called <code>life extension</code>.
</p>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"Default constructor, this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>

       ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"Destructor, this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"void func(), this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main() begins\n"</span>;

       <span style="color: #feacd0;">if </span><span style="color: #ffffff;">(</span><span style="color: #00bcff;">1</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #6ae4b9;">C1</span>&amp;&amp; <span style="color: #ffffff;">r</span> = C1<span style="color: #ffffff;">{}</span>;
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main() continues\n"</span>;
           r.<span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The temporary object C1{} is still alive here because it is bound to a reference 'r'.</span>
           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">The destructor for the temporary object will be called here.</span>
       <span style="color: #ffffff;">}</span>

       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main() ends\n"</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org8a6c8eb" class="outline-4">
<h4 id="org8a6c8eb">Reference qualifiers</h4>
<div class="outline-text-4" id="text-org8a6c8eb">
<p>
Normally the <code>non-static member functions</code> of a <code>class</code> can be called both with <code>class objects</code> whose value category is <code>L-value expression</code> and with class objects whose value category is <code>R-value expression</code>. However, in some cases, we may want to prevent the function from being called for <code>class objects</code> with the <code>R-value expression</code> category, or to create separate implementations for <code>class objects</code> with the <code>L-value expression</code> category and class objects with the <code>R-value expression</code> category. <code>Reference qualifiers</code> can be used the implement this behaviour.
</p>

<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This function can only be called with L-value expressions.</span>
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>&amp;; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">&amp; -&gt; L-value reference qualifier</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This function can only be called with R-value expressions.</span>
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>&amp;&amp;; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">&amp; -&gt; R-value reference qualifier</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is valid. c1 is a L-value expression. f1() is L-value reference qualified.</span>
       c1.<span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is valid. C1{} is a R-value expression. f2() is R-value reference qualified.</span>
       C1<span style="color: #ffffff;">{}</span>.<span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is valid. std::move(c1) is a X-value expression (R-value expression). f2() is R-value reference qualified.</span>
       <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">move</span><span style="color: #ffffff;">(</span>c1<span style="color: #ffffff;">)</span>.<span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;

        <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is a syntax error. std::move(c1) is X-value expression (R-value expression). f1() is L-value reference qualified.</span>
       <span style="color: #00bcff;">std</span>::<span style="color: #feacd0;">move</span><span style="color: #ffffff;">(</span>c1<span style="color: #ffffff;">)</span>.<span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is syntax error. C1{} is a R-value expression. f1() is L-value reference qualified.</span>
       C1<span style="color: #ffffff;">{}</span>.<span style="color: #feacd0;">f1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is syntax error. c1 is a L-value expression. f2() is R-value reference qualified.</span>
       c1.<span style="color: #feacd0;">f2</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
Functions with <code>reference qualifiers</code> can also be overloeaded:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">These are valid overloads.</span>
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> &amp;
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"void func() &amp;\n"</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> <span style="color: #b6a0ff;">const</span> &amp;
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"void func() const &amp;\n"</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> &amp;&amp;
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"void func() &amp;&amp;\n"</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>; 
       <span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">cc1</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">func() with L-value reference qualified will be called.</span>
       c1.<span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">func() with const L-value reference qualified will be called.</span>
       cc1.<span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">func() with R-value reference qualified will be called.</span>
       C1<span style="color: #ffffff;">{}</span>.<span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
<code>Temporary objects</code> are assignable even it is not useful:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>

   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>; 

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is valid and can be prevented by making the class's operator= function L-value reference qualified.</span>
       C1<span style="color: #ffffff;">{}</span> = c1;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
Making <code>temporary objects</code> of a class unassignable:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is valid after C++20. Before C++20, reference qualified special member functions cannot be defaulted by the compiler.</span>
       <span style="color: #6ae4b9;">C1</span>&amp; <span style="color: #b6a0ff;">operator</span><span style="color: #feacd0;">=</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">C1</span>&amp;<span style="color: #ffffff;">)</span> &amp; = <span style="color: #b6a0ff;">default</span>;

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Before C++20, reference qualified special functions must be defined explicitly.</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">C1&amp; operator=(const C1&amp; other) &amp;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">{</span>
       <span style="color: #989898; font-style: italic;">//     </span><span style="color: #989898; font-style: italic;">// ...</span>

       <span style="color: #989898; font-style: italic;">//     </span><span style="color: #989898; font-style: italic;">return *this;</span>
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">}</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>; 

       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is invalid now because operator= is L-value reference qualified.</span>
       C1<span style="color: #ffffff;">{}</span> = c1;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
If one of the oveloads of a function has a <code>reference qualifier</code> all overloads must have a <code>reference qualifier</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is invalid. If an overload has a reference qualifier all of the other overloads also have to have a reference qualifier.</span>
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>;
       <span style="color: #6ae4b9;">void</span> <span style="color: #feacd0;">func</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span> &amp;;
   <span style="color: #ffffff;">}</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-org7de554d" class="outline-4">
<h4 id="org7de554d">Conversion constructor</h4>
<div class="outline-text-4" id="text-org7de554d">
<p>
<code>Conversion constructors</code> can be used for implicit or explicit <code>type conversion</code>. <code>Non-class type expressions</code> can be converted to a <code>class type</code> using <code>conversion constructors</code>.
</p>

<div class="org-src-container">
<pre class="src src-C++" id="org46ea885">   <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">C1</span>
   <span style="color: #ffffff;">{</span>
   <span style="color: #b6a0ff;">public</span>:
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 default constructor, this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>

       ~<span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 destructor, this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>
       
       <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">This is a conversion constructor.</span>
       <span style="color: #feacd0;">C1</span><span style="color: #ffffff;">(</span><span style="color: #6ae4b9;">int</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1(int) constructor, this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
       <span style="color: #ffffff;">}</span>

       <span style="color: #6ae4b9;">C1</span>&amp; <span style="color: #b6a0ff;">operator</span><span style="color: #feacd0;">=</span><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">const</span> <span style="color: #6ae4b9;">C1</span>&amp; <span style="color: #ffffff;">other</span><span style="color: #ffffff;">)</span>
       <span style="color: #ffffff;">{</span>
           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"C1 copy assignment, this: "</span> &lt;&lt; <span style="color: #b6a0ff;">this</span> &lt;&lt; <span style="color: #79a8ff;">" other: "</span> &lt;&lt; &amp;other &lt;&lt; <span style="color: #79a8ff;">'\n'</span>;
           
           <span style="color: #b6a0ff;">return</span> *<span style="color: #b6a0ff;">this</span>;
       <span style="color: #ffffff;">}</span>
   <span style="color: #ffffff;">}</span>;

   <span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">(</span><span style="color: #ffffff;">)</span>
   <span style="color: #ffffff;">{</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main() begins\n"</span>;
       <span style="color: #ffffff;">{</span>
           <span style="color: #6ae4b9;">C1</span> <span style="color: #ffffff;">c1</span>;

           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">Normally this is invalid but the conversion constructor makes it possible.</span>
           c1 = <span style="color: #00bcff;">2</span>; <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">First, C1(12) is called and a temporary object is created then the copy assignment operator of c1 is called with this temporary object. c1.operator=(C1(12));</span>
           <span style="color: #989898; font-style: italic;">// </span><span style="color: #989898; font-style: italic;">c1 = C1(12); // Similar to this.</span>

           <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main() continues\n"</span>;
       <span style="color: #ffffff;">}</span>
       <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"main() ends"</span>;
   <span style="color: #ffffff;">}</span>
</pre>
</div>

<p>
Output:
</p>
<pre class="example" id="org8bfddca">
 main() begins
 C1 default constructor, this: 0x7ffdbc9c294e
 C1(int) constructor, this: 0x7ffdbc9c294f
 C1 copy assignment, this: 0x7ffdbc9c294e other: 0x7ffdbc9c294f
 C1 destructor, this: 0x7ffdbc9c294f
 main() continues
 C1 destructor, this: 0x7ffdbc9c294e
 main() ends
</pre>

<p>
cpp013 - 02:29:00
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: nukoseer</p>
<p class="date">Created: 2024-12-02 Mon 15:44</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
