* Differences Between C and C++
 Main purpose of this section is to point out the differences between C and C++. It isn't about how code should or should not be written in C or C++. It is only about validity of the code.
** Fundemental Syntax Differences
*** Implicit int
 If a function does not have a return type:
 - In C, it is allowed and compilers assume it returns ~int~. It is also allowed in function declarations.
 - In C++, it is syntax error.
 This code is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   func(int x)
   {
       return x + 1;
   }
 #+END_SRC

*** Missing return statement in functions with non-void return type
 If a function has return type but does not return anything:
 - In C, it is allowed. Compilers can show a warning but they don't have to.
 - In C++, it is syntax error.
 This code is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   int func() {}
 #+END_SRC

*** Implicit/default function declaration
 If name lookup fails for a function:
 - In C, compilers will assume it is an external function with the default declaration: ~int func();~
 - In C++, it is syntax error.
 This code will compile in C and compiler will assume ~bar()~ function has ~int bar();~ declaration:
 #+BEGIN_SRC C++
   void foo()
   {
       bar();
   }
 #+END_SRC

*** Declaration of functions without parameter
 There are different rules for C and C++.
  #+BEGIN_SRC C++
    int foo();
    int bar(void);
  #+END_SRC
  - In C, these 2 function declarations have different meaning.
   + ~int foo();~ means, we don't have any information about parameters so we can pass what ever we want.
   + ~int bar(void);~ means, function does not take any parameters.
  - In C++, both of the declarations have the same meaning. Functions do not take any parameters.
  According to the declarations above, this code is valid in C. Invalid in C++, because ~int foo();~ does not take any parameters.
  #+BEGIN_SRC C++
    foo(1, 2);
  #+END_SRC

*** Nameless parameters in function definitions
 Caution! This is about function definitions not declarations.
  - In C, it is not allowed. (Since C20, it is also allowed in C.)
  - In C++, it is allowed.
  This code is invalid for C (before C20) and valid for C++:
  #+BEGIN_SRC C++
    void func(int) {}
  #+END_SRC

*** Scope of for-statement
 - In C, inside of the for loop has a different block scope than for-statement itself.
 - In C++, inside of the for loop and for-statement itself are in same block scope.
 Because of this difference, name shadowing inside a for loop is valid in C, but invalid in C++:
 #+BEGIN_SRC C++
   for (int i = 0; i < 10 ++i;)
   {
       int i = 99;
   }
 #+END_SRC
 We can say above code looks like this for C compiler:
 #+BEGIN_SRC C++
   for (int i = 0; i < 10 ++i;)
   {
       {
	   int i = 99;
       }
   }
 #+END_SRC
 /Note: For C and C++, name shadowing is only valid between different scopes./

** Differences About Types and Type Conversions
*** Logic data type (boolean)
 In C:
 - ~int~ is used instead of logic data type.
 - ~_Bool~ type is added in C99, but it is not widely used.
 - C doesn't have ~false~, ~true~ constants. ~stdbool.h~ defines macros for them.

 In C++:
 - ~bool~ type, ~false~ and ~true~ constants are build-in to the language. No need to include anything.
 - Implicit type conversion from arithmetic types and pointer types to ~bool~ is allowed.
 - Implicit type conversion from ~bool~ to arithmetic types is allowed.
 These are valid in C++:
 #+BEGIN_SRC C++
   // Implicit conversion from arithmetic types to bool
   int x = 45;
   bool b1 = x;

   double y = 33.11;
   bool b2 = y;

   // Implicit conversion from pointer types to bool
   int z = 100;
   int* p = &z;
   bool b3 = p;

   // Implicit conversion from bool to arithmetic types
   bool b4 = true;
   int t = b4;
 #+END_SRC

 But, this is invalid:
 #+BEGIN_SRC C++
   // No implicit conversion from bool to pointer types
   bool b5 = false;
   int* ptr = b5;
 #+END_SRC

*** User defined types
 - In C, ~struct~, ~enum~ and ~union~ tags don't represent type itself. A keyword (~struct~, ~enum~ or ~union~) must be used before a tag name to represent a type. A ~typedef~ declaration can be used too.
 - In C++, tag names directly represent type names.
 Here are some examples:
 #+BEGIN_SRC C++
   struct Data
   {
       int a, b, c;
   };

   // Invalid in C. Valid in C++. There is no need to use struct keyword or typedef declaration in C++.
   Data data0;

   // Valid in C and C++.
   struct Data data1;

   typedef struct Example
   {
       int a, b, c;
   } Example;

   // Valid in C and C++.
   Example example0;
 #+END_SRC

*** Empty structs
 - In C, empty structs are invalid.
 - In C++, empty structs are valid.
 An example:
 #+BEGIN_SRC C++
   struct Data
   {
   };
 #+END_SRC

*** Implicit conversion from arithmetic types to pointer types
 - In C, implicit conversion from arithmetic types to pointer types is  allowed. Compilers might show a warning.
 - In C++, there is no implicit conversion from arithmetic types to pointer types.
 This is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   int x = 20;
   int* p = x;

   double d = 33.11;
   char* ptr = &d;
 #+END_SRC

*** Implicit conversion from ~void*~ to ~T*~
 - In C, implicit conversion from ~void*~ to ~T*~ is allowed.
 - In C++, implicit conversion from ~void*~ to ~T*~ is not allowed.
 This code is valid in C but invalid in C++:
 #+BEGIN_SRC C++
  int* p = malloc(1000 * sizeof(int));
 #+END_SRC

*** Underlying enumeration type
 - In C, underlying enumeration type has to be ~int~.
 - In C++, it does not have to be ~int~ and can be specified with special syntax.

*** Implicit conversion from arithmetic types to enumeration types
 - In C, it is allowed.
 - In C++, it is not.
 This code is valid in C but invalid in C++:
 #+BEGIN_SRC C++
   enum Color { Red, Green, Blue };
   enum Color color;
   color = 3;
 #+END_SRC

*** Implicit conversion between different enumeration types
 - In C, it is allowed.
 - In C++, it is not.
 This code is valid in C but invalid in C++:
 #+BEGIN_SRC C++
   enum Color { Red, Green, Blue };
   enum Count { Zero, One, Two };
   enum Color color = Red;
   enum Count count = Zero;
   color = count;
 #+END_SRC

*** Implicit conversion from enumeration types to arithmetic types.
 - In C, it is allowed.
 - In C++, it is also allowed. Scoped enums can be used to prevent this.
 This code is valid in C and C++:
 #+BEGIN_SRC C++
   enum Color { Red, Green, Blue };
   enum Color color = Red;
   int x = color;
 #+END_SRC

** Differences about const keyword
*** Initialization of const objects
 - In C, ~const~ objects don't have to be initialized.
 - In C++, ~const~ objects have to be initialized.
 This is code is valid in C and invalid in C++:
 #+BEGIN_SRC C++
  const int x;
 #+END_SRC
 Might be a bit tricky to understand at first but this is also valid in C++:
 #+BEGIN_SRC C++
   // This is a pointer to const int. Object/variable itself is not const here it just points to const int
   const int* ptr;
 #+END_SRC
 But this is invalid:
 #+BEGIN_SRC C++
   // This is a const pointer to int. Object/variable itself is const
   int* const ptr;
 #+END_SRC

*** Const expressions
 - In C, expressions generated by const variables are not counted as const expressions.
 - In C++, they count as const expressions.
 This is invalid in C (assuming no VLA) but valid in C++:
 #+BEGIN_SRC C++
   const int x = 10;
   int arr[x] = { 0 };
 #+END_SRC

*** Global const objects and linkage
 - In C, global const objects are in external linkage.
 - In C++, global const objects are in internal linkage like ~static~ objects.
 ~x~ is in external linkage in C and internal linkage in C++:
 #+BEGIN_SRC C++
   // In global scope
   const int x = 10;
 #+END_SRC

*** Implicit conversion from ~const T*~ to ~T*~
 - In C, implicit conversion from ~const T*~ to ~T*~ is allowed. Compilers might show a warning.
 - In C++, there is no implicit conversion from ~const T*~ to ~T*~.
 This is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   const int x = 10;
   int* p = &x;
 #+END_SRC

