* Fundemental Differences Between C and C++
 Main purpose of this section is to point out the differences between C and C++. It isn't about how code should or should not be written in C or C++. It is only about validity of the code.
** Syntax Differences
*** Implicit int
 If a function does not have a return type:
 - In C, it is allowed and compilers assume it returns ~int~. It is also allowed in function declarations.
 - In C++, it is syntax error.
 This code is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   func(int x)
   {
       return x + 1;
   }
 #+END_SRC

*** Missing return statement in functions with non-void return type
 If a function has return type but does not return anything:
 - In C, it is allowed. Compilers can show a warning but they don't have to.
 - In C++, it is syntax error.
 This code is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   int func() {}
 #+END_SRC

*** Implicit/default function declaration
 If name lookup fails for a function:
 - In C, compilers will assume it is an external function with the default declaration: ~int func();~
 - In C++, it is syntax error.
 This code will compile in C and compiler will assume ~bar()~ function has ~int bar();~ declaration:
 #+BEGIN_SRC C++
   void foo()
   {
       bar();
   }
 #+END_SRC

*** Declaration of functions without parameter
 There are different rules for C and C++.
  #+BEGIN_SRC C++
    int foo();
    int bar(void);
  #+END_SRC
  - In C, these 2 function declarations have different meaning.
   + ~int foo();~ means, we don't have any information about parameters so we can pass what ever we want.
   + ~int bar(void);~ means, function does not take any parameters.
  - In C++, both of the declarations have the same meaning. Functions do not take any parameters.
  According to the declarations above, this code is valid in C. Invalid in C++, because ~int foo();~ does not take any parameters.
  #+BEGIN_SRC C++
    foo(1, 2);
  #+END_SRC

*** Nameless parameters in function definitions
 Caution! This is about function definitions not declarations.
  - In C, it is not allowed. (Since C20, it is also allowed in C.)
  - In C++, it is allowed.
  This code is invalid for C (before C20) and valid for C++:
  #+BEGIN_SRC C++
    void func(int) {}
  #+END_SRC

*** Scope of for-statement
 - In C, inside of the for loop has a different block scope than for-statement itself.
 - In C++, inside of the for loop and for-statement itself are in same block scope.
 Because of this difference, name shadowing inside a for loop is valid in C, but invalid in C++:
 #+BEGIN_SRC C++
   for (int i = 0; i < 10 ++i;)
   {
       int i = 99;
   }
 #+END_SRC
 We can say above code looks like this for C compiler:
 #+BEGIN_SRC C++
   for (int i = 0; i < 10 ++i;)
   {
       {
	   int i = 99;
       }
   }
 #+END_SRC
 /Note: For C and C++, name shadowing is only valid between different scopes./

** Differences About Types and Type Conversions
*** Logic data type (boolean)
 In C:
 - ~int~ is used instead of logic data type.
 - ~_Bool~ type is added in C99, but it is not widely used.
 - C doesn't have ~false~, ~true~ constants. ~stdbool.h~ defines macros for them.

 In C++:
 - ~bool~ type, ~false~ and ~true~ constants are build-in to the language. No need to include anything.
 - Implicit type conversion from arithmetic types and pointer types to ~bool~ is allowed.
 - Implicit type conversion from ~bool~ to arithmetic types is allowed.
 These are valid in C++:
 #+BEGIN_SRC C++
   // Implicit conversion from arithmetic types to bool
   int x = 45;
   bool b1 = x;

   double y = 33.11;
   bool b2 = y;

   // Implicit conversion from pointer types to bool
   int z = 100;
   int* p = &z;
   bool b3 = p;

   // Implicit conversion from bool to arithmetic types
   bool b4 = true;
   int t = b4;
 #+END_SRC

 But, this is invalid:
 #+BEGIN_SRC C++
   // No implicit conversion from bool to pointer types
   bool b5 = false;
   int* ptr = b5;
 #+END_SRC

*** User defined types
 - In C, ~struct~, ~enum~ and ~union~ tags don't represent type itself. A keyword (~struct~, ~enum~ or ~union~) must be used before a tag name to represent a type. A ~typedef~ declaration can be used too.
 - In C++, tag names directly represent type names.
 Here are some examples:
 #+BEGIN_SRC C++
   struct Data
   {
       int a, b, c;
   };

   // Invalid in C. Valid in C++. There is no need to use struct keyword or typedef declaration in C++.
   Data data0;

   // Valid in C and C++.
   struct Data data1;

   typedef struct Example
   {
       int a, b, c;
   } Example;

   // Valid in C and C++.
   Example example0;
 #+END_SRC

*** Empty structs
 - In C, empty structs are invalid.
 - In C++, empty structs are valid.
 An example:
 #+BEGIN_SRC C++
   struct Data
   {
   };
 #+END_SRC

*** Implicit conversion from arithmetic types to pointer types
 - In C, implicit conversion from arithmetic types to pointer types is allowed. Compilers might show a warning.
 - In C++, there is no implicit conversion from arithmetic types to pointer types.
 This is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   int x = 20;
   int* p = x;
 #+END_SRC

*** Implicit conversion between different pointer types.
 - In C, implicit conversion between different pointer is allowed. Compilers might show a warning.
 - In C++, there is no implicit conversion between different pointer types.
 This is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   double d = 33.11;
   char* ptr = &d;
 #+END_SRC

*** Implicit conversion from ~void*~ to ~T*~
 - In C, implicit conversion from ~void*~ to ~T*~ is allowed.
 - In C++, implicit conversion from ~void*~ to ~T*~ is not allowed.
 This code is valid in C but invalid in C++:
 #+BEGIN_SRC C++
  int* p = malloc(1000 * sizeof(int));
 #+END_SRC

*** Underlying enumeration type
 - In C, underlying enumeration type has to be ~int~.
 - In C++, it does not have to be ~int~ and can be specified with special syntax.

*** Implicit conversion from arithmetic types to enumeration types
 - In C, it is allowed.
 - In C++, it is not.
 This code is valid in C but invalid in C++:
 #+BEGIN_SRC C++
   enum Color { Red, Green, Blue };
   enum Color color;
   color = 3;
 #+END_SRC

*** Implicit conversion between different enumeration types
 - In C, it is allowed.
 - In C++, it is not.
 This code is valid in C but invalid in C++:
 #+BEGIN_SRC C++
   enum Color { Red, Green, Blue };
   enum Count { Zero, One, Two };
   enum Color color = Red;
   enum Count count = Zero;
   color = count;
 #+END_SRC

*** Implicit conversion from enumeration types to arithmetic types.
 - In C, it is allowed.
 - In C++, it is also allowed. Scoped enums can be used to prevent this.
 This code is valid in C and C++:
 #+BEGIN_SRC C++
   enum Color { Red, Green, Blue };
   enum Color color = Red;
   int x = color;
 #+END_SRC

*** Character literals
 - In C, character literals are ~int~.
 - In C++, character literals are ~char~.
 This code prints 4 in C and 1 in C++:
 #+BEGIN_SRC C++
   printf("%zu\n", sizeof('A'));
 #+END_SRC

*** String literals
 - In C, the type of string literals is ~char[n]~. When string literals are used in an expression they are converted to address of the first element (array decay - array to pointer conversion). The type after array decay is ~char*~.
 - In C++, the type of string literals is ~const char[n]~. Array decay also applies to C++ but the type after array decay is ~const char*~.
 This string literal is ~char[8]~ in C and ~const char[8]~ in C++:
 #+BEGIN_SRC C++
   "example"
 #+END_SRC
 This is valid in C but invalid in C++:
 #+BEGIN_SRC C++
   // In C++, it is decayed to const char* and there is no implicit conversion from const T* to T*.
   char* s = "example";
 #+END_SRC
 
** Differences About const Keyword
*** Initialization of const objects
 - In C, ~const~ objects don't have to be initialized.
 - In C++, ~const~ objects have to be initialized.
 This is code is valid in C and invalid in C++:
 #+BEGIN_SRC C++
  const int x;
 #+END_SRC
 Might be a bit tricky to understand at first but this is also valid in C++:
 #+BEGIN_SRC C++
   // This is a pointer to const int. Object/variable itself is not const here it just points to const int
   const int* ptr;
 #+END_SRC
 But this is invalid:
 #+BEGIN_SRC C++
   // This is a const pointer to int. Object/variable itself is const
   int* const ptr;
 #+END_SRC

*** Const expressions
 - In C, expressions generated by const variables are not counted as const expressions.
 - In C++, they count as const expressions.
 This is invalid in C (assuming no VLA) but valid in C++:
 #+BEGIN_SRC C++
   const int x = 10;
   int arr[x] = { 0 };
 #+END_SRC

*** Global const objects and linkage
 - In C, global const objects are in external linkage.
 - In C++, global const objects are in internal linkage like ~static~ objects.
 ~x~ is in external linkage in C and internal linkage in C++:
 #+BEGIN_SRC C++
   // In global scope
   const int x = 10;
 #+END_SRC

*** Implicit conversion from ~const T*~ to ~T*~
 - In C, implicit conversion from ~const T*~ to ~T*~ is allowed. Compilers might show a warning.
 - In C++, there is no implicit conversion from ~const T*~ to ~T*~.
 This is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   const int x = 10;
   int* p = &x;
 #+END_SRC

** Differences About Value Categories
*** Primary value categories
 - In C, there are 2 primary value categories.
   + L-value
   + R-value
 - In C++, there are 3 primary value categories.
   + L-value
   + PR-value (pure R-value)
   + X-value (expired value)
 The combination of the ~PR-value~ and ~X-value~ categories is called the ~R-value~ category. (~PR-value~ \cup ~X-value~ = ~R-value~). When we say an expression is ~R-value~ it means it may be an ~PR-value~ or ~X-value~ in C++.
 
 The combination of the ~L-value~ and ~X-value~ categories is called the ~GL-value~ category. (~L-value~ \cup ~X-value~ = ~GL-value~). When we say an expression is ~GL-value~ it means it may be an ~L-value~ or ~X-value~ in C++.
 
 The ~GL-value~ and ~R-value~ categories are not ~primary value categories~. They are called ~combined value categories~.
 
*** Prefix increment/decrement operator
 - In C, expressions generated by prefix increment/decrement operator are R-value expressions.
 - In C++, they are L-value expressions.
 This code is valid in C++ and invalid in C:
 #+BEGIN_SRC C++
   int x = 10;
   // These are invalid in C, because R-value expressions cannot be an operand of the address(&) operator.
   &++x;
   &--x;
 #+END_SRC

*** Assignment operator
 - In C, expressions generated by assignment operator are R-value expressions.
 - In C++, they are L-value expressions.
 This code is valid in C++ and invalid in C:
 #+BEGIN_SRC C++
   int x = 10;
   &(x = 5);
 #+END_SRC

*** Comma operator
 - In C, expressions generated by comma operator are R-value expressions.
 - In C++, they can be L-value or R-value expressions.
 This code is valid in C++ and invalid in C:
 #+BEGIN_SRC C++
   int x = 10;
   int y = 20;
   (x, y) = 30; // y = 30;
 #+END_SRC

*** Ternary operator
 - In C, expressions generated by ternary operator are R-value expressions.
 - In C++, they can be L-value or R-value expressions.
 This code is valid in C++ and invalid in C:
 #+BEGIN_SRC C++
   int x = 10;
   int y = 20;
   int z = 30;
   (x == 10 ? y : z) = 40; // y = 40;
 #+END_SRC

* C++ Topics
** Initialization
 There are very different ways to initialize objects in C++.
*** Default initialization
 Default initialized objects are created with a garbage value.
 #+BEGIN_SRC C++
   int x; // Default initialization.
 #+END_SRC

*** Zero initialization
 Compilers zero initialize objects in the global scope. ~Zero initialization~ is not a way to initialize objects it is more like a compiler process.
 #+BEGIN_SRC C++
   // Global scope
   int x;  // x = 0;
   bool b; // b = false;
   int* p; // p = nullptr;
 #+END_SRC

*** Copy initialization
 If objects are initialized like in the C language, it is called ~copy initialization~.
 #+BEGIN_SRC C++
   int x = 10; // Copy initialization.
 #+END_SRC

*** Direct initialization
 If objects are initialized by using paranthesis, it is called ~direct initialization~.
 #+BEGIN_SRC C++
   int x(98); // Direct initialization.
 #+END_SRC

*** Direct-list / brace initialization (uniform initialization)
 If objects are initialized by using braces, it is called ~direct-list initialization~. ~direct-list/brace initialization~ is added to the language to have a uniform way to initialize objects. This is why it is also called ~uniform initialization~. It can be used to initialize any object.
 #+BEGIN_SRC C++
  int x{ 10 }; // Direct-list initialization.
 #+END_SRC

 Unlike other initialization methods, if an implicit narrowing conversion occurs during ~direct-list initialization~, it is a syntax error.
 #+BEGIN_SRC C++
   double dval = 5.6;

   // Implicit narrowing conversion does not cause any error but compilers might show a warning.
   int i1 = dval;
   int i2(dval);

   // Invalid. Implicit narrowing conversion causes a syntax error. Explicit cast is needed.
   int i3{dval};
 #+END_SRC

 In C++, there are such declarations that can be interpreted as both ~object instantiation~ and ~function declaration~ at the same time. In such cases, ~function declaration~ has the priority. This is called ~most vexing parse~ and sometimes it leads to problems.
 Example:
 #+BEGIN_SRC C++
   struct A
   {
   };

   struct B
   {
       B(A);
   };

   // Here, we wanted to create a bx object from class B type by calling its constructor with a temporary object with class A type.
   // C++ understands this as a function declaration. It is a function named bx and it has a return type of class B,
   // and takes a function pointer as a parameter. Sigh..
   B bx(A());

   // This can be prevented by using direct-list initialization.
   B by{A()};
   B bz(A{});
 #+END_SRC

*** Value initialization
 If objects are initialized by using braces but inside of the braces are empty, it is called ~value initialization~. Value initialized objects are first initialized to zero, if any additional initialization steps are required, this is done after ~zero initialization~.
 #+BEGIN_SRC C++
   int x{}; // Value initialization.
 #+END_SRC

** nullptr
 In C++, there is a keyword that represents a null pointer, and it is called ~nullptr~. It is not a macro like in C. It is a keyword, a constant and its type is ~nullptr_t~.

 You can assign ~nullptr~ to other pointer types but there is no implicit conversion from ~nullptr_t~ type to arithmetic types.
 #+BEGIN_SRC C++
   // Invalid
   int x = nullptr;

   // Valid
   int* y = nullptr;
   double* z = nullptr;
 #+END_SRC

** Reference Semantics
 There is an alternative way to represent pointers in C++, which is called ~reference~, but this is only an alternative at the language layer, the underlying representation does not change once the code is compiled. Everything works with the pointers in assembly level.

 There are 3 different reference categories:
  - L-value reference
  - R-value reference (move semantics, perfect forwarding (generic prog.))
  - Forwarding/universal reference
  An example:
  #+BEGIN_SRC C++
    int x = 10;
    // L-value reference
    int& y = x;
    // R-value reference
    int&& z = 10;
    // Forwarding/universal reference
    auto&& t = 10;
  #+END_SRC

*** L-value references
  L-value references are similar to ~top-level const pointer objects~:
  #+BEGIN_SRC C++
    int x = 10;

    // We cannot change the value of the ptr because it is a const pointer. It will always point to the same object
    // which is x in this case. Whenever *ptr is used, it means x.
    int* const ptr = &x;
    int y = *ptr; // int y = x;
  #+END_SRC

  L-value references represent their underlying object directly, there is no need for dereferencing like pointers. They cannot be default initialized, cannot be initialized with R-value objects and cannot be reassigned/rebound(like ~top-level const pointer~).
  #+BEGIN_SRC C++
       int x = 10;

       // Reference r directly represents x
       int& r = x;
       // No need to dereference like a pointer
       int y = r; // int y = x;

       int& r1; // Syntax error. References cannot be default initialized.
       int& r2 = 10; // Syntax error. References cannot be initialized with R-value objects.

       int z = 10;
       int t = 20;
       int& r3 = z;

       // This is valid but equals to z = t. r3 still represents z, what we did is changing value of z.
       // References cannot be reassigned.
       r3 = t; 
  #+END_SRC

 We can say that when we define a L-value reference we bind it to underlying object and they will stay bound until the end of scope.
  #+BEGIN_SRC C++
    int x = 10;
    // All r1, r2 and r3 bound to x
    int& r1 = x;
    int& r2 = r1;
    int& r3 = r2;

    ++r1;
    ++r2;
    ++r3;
    // x is 13 here

  #+END_SRC

 L-value rereferences can also be bound to arrays and array decay rules do not change:
  #+BEGIN_SRC C++
    int a[] = { 1, 3, 5, 7, 9 };
    // r is bound to a
    int (&ra)[] = a; // Normally, we do not have to write the type directly. we can use type deduction.

    for (int i = 0; i < 5; ++i)
    {
       // ra[i] equals to a[i]
    }

    // Same rules apply for array decay
    int* p1 = a;
    int* p2 = ra;
  #+END_SRC

  L-value references often used to pass the object to the function (~call by reference~) and also to return the object itself from the function.
  #+BEGIN_SRC C++
    int& foo(int& r)
    {
	++r;
	return r;
    }

    int x = 10;

    // Value of x will be 11 after foo() is called
    // r represents x
    int& r = foo(x);
  #+END_SRC 
   
*** L-value references and const semantics
 We said that L-value references are like ~top-level const pointer~ by default but they can also be used like ~low-level const pointer~.
 Pointer parameters can be used as a mutator or accessor. L-value references also can be used in a similar way:
  #+BEGIN_SRC C++
    void f1(int* p); // Mutator
    void f2(const int* p); // Accessor

    void f3(int& r); // Mutator
    void f4(const int& r); // Accessor
  #+END_SRC 

  ~const~ objects can only be bound by ~const~ L-value references similar to pointers:
  #+BEGIN_SRC C++
    const int x = 10;
    int* p = &x; // Invalid. int* p cannot point to const int x.
    int& r = x; // Also invalid. int& r cannot bind to const int x.

    const int& cr = x; // Valid.
  #+END_SRC 

 Normally, initializing an L-value reference with a different/mismatching object type is syntax error:
  #+BEGIN_SRC C++
    int x = 10;
    double& r = x; // Syntax error. double& r cannot bind to int object.
  #+END_SRC

  But, if we try to initialize a ~const~ L-value reference with a different/mismatching object type and there is an implicit conversion from that object type to the type represented by the ~const~ L-value reference, the compiler creates a temporary object and the ~const~ L-value reference is bound to that temporary object:
  #+BEGIN_SRC C++
    int x = 10;
    // This is valid. Normally, double and int types do not match but implicit conversion is allowed from int to double.
    // So, compiler creates a temporary double object and assign x to it, then cr binds to that temporary object.
    const double& cr = x; 

    // We can think that compiler generates something like this for above code.
    // double temporary_object = x;
    // const double& cr = temporary_object;
  #+END_SRC

 This also applies, when we try to initialize ~const~ L-value references with R-value objects:
  #+BEGIN_SRC C++
     // This is syntax error. L-value references cannot be initialized with R-value objects.
    int& r = 10;

    // This is valid when we use const L-value reference, because compiler creates a temporary object like the example above.
    const int& cr = 10;

    // Compiler might generate something like this for above code.
    // int temporary_object = 10;
    // const int& cr = temporary_object;
  #+END_SRC

  This becomes even more important when we call functions that take L-value reference parameters, for example:
   #+BEGIN_SRC C++
     // We can only pass an L-value objects to f1(). If we try to pass a R-value object it will be syntax error.
     void f1(int& x);
     int x = 10;
     f1(x); // Valid.
     f2(10); // Invalid, syntax error.

     // It is not the same for f2() however. We can pass L-value objects to f2() but if we try to pass a R-value object, it will not cause
     // any syntax error because of the rules above. The temporary object will be passed to f2() instead of R-value object itself. (Assuming there is no type problem)
     void f2(const int& x);
     int y = 10;
     f2(y); // Valid.
     f2(10); // Also valid.
   #+END_SRC

*** Differences between pointers and L-value references
| Pointers                       | References                                                           |
|--------------------------------+----------------------------------------------------------------------|
| don't have to be initialized   | have to be initialized                                               |
| pointer to pointer exists      | reference to reference doesn't exist (ignoring reference collapsing) |
| arrays can store pointers      | arrays cannot store references                                       |
| pointers can be null (nullptr) | references cannot be null                                            |
| pointers can be reassigned     | references cannot be reassigned                                      |

*** R-value references
 R-value references are mostly about move semantics and perfect forwarding. Details will be discussed in the future. We will just briefly explain the syntax for now.
 R-value references cannot be default-initialized like L-value references, and can be initialized only with R-value objects.
  #+BEGIN_SRC C++
    int&& r = 10; // Valid, R-value reference.

    int x = 10;
    int&& rr = x; // Invalid. R-value references cannot be initialized with L-value objects.
  #+END_SRC

  ...
  
** Type Deduction
 In C++, we don't need to write the type explicitly in some contexts. We can use one of the type deduction mechanisms to have the compiler determine the type for us by looking at the code.
 There are several different mechanisms for type deduction:
  - auto
  - decltype
  - decltyoe(auto)
  - template

*** auto type deduction
 The ~auto~ keyword can be used to determine the type of the variable during initialization. A very important point is that the type deduction is made for ~auto~ keyword not for the variable itself.
 #+BEGIN_SRC C++
   auto x = 10; // int x = 10;

   int y = 45;
   auto z = y; // int z = y;

   auto t = 0U; // unsigned int t = 0U;
   auto k = 0.; // double k = 0.;

   char c = 'a';
   auto a = c; // char a = c;
   auto b = +c; // int b = +c;

   auto d = 10 > 5; // bool d = 10 > 5;
 #+END_SRC

 We cannot ~default initialize~ an object with ~auto~ because in this case the compiler cannot determine its type:
 #+BEGIN_SRC C++
   auto x; // Invalid.
 #+END_SRC

 If an object is ~auto~ initialized with a ~const~ object and does not have any declarator (such as *, &), ~const~ qualifier drops:
 #+BEGIN_SRC C++
   const int cx = 6;
   // This equals to int y = cx;. const qualifier drops.
   auto y = cx;

   int* const ptr = 0;
   // ptr is const pointer to int. If the object itself is const, const qualifier drops.
   auto p = ptr; // int* p = ptr;

   const int* ptr1 = 0;
   // ptr1 is pointer to const int. The object itself is not const, const qualifier does not drop in this case.
   auto p1 = ptr1; // const int* p1 = ptr1;
 #+END_SRC

 If an object is ~auto~ initialized with a ~reference~ and does not have any declarator (such as *, &), ~reference~ qualifier drops:
 #+BEGIN_SRC C++
   int x = 10;
   int& r = x;
   // This equals to int y = r;. reference qualifier drops.
   auto y = r;

   const int& cr = x;
   // This equals to int z = cr;. const and reference qualifiers drop.
   auto z = cr;
 #+END_SRC

 Array decay rules are still valid: 
 #+BEGIN_SRC C++
   int a[] = { 1, 3, 6, 7 };
   auto p = a; // int* p = a;

   const int ca[] = { 1, 3, 6, 7 };
   // Here const qualifier does not drop. The object itself 'ca' is not const.
   // It is a pointer to const int after array decay.
   auto cp = ca; // const int* cp = ca;

   // The type of the "test" is const char[5], it decays to const char*.
   auto str = "test"; // const char* str = "test";
 #+END_SRC

 ~auto~ initialization with functions:
 #+BEGIN_SRC C++
   int foo(int);
   // Normally, type of the foo is int(int) but it decays to int (*)(int).
   auto fp = foo; // int (*fp)(int) = foo;
 #+END_SRC

 If declarators and ~auto~ are used together, rules are a bit different:
 In this example there is no difference:
 #+BEGIN_SRC C++
   int x = 10;
   auto& r = x; // int& r = x;
 #+END_SRC

 But when we use a ~const~ object:
 #+BEGIN_SRC C++
   const int x = 10;
   // const qualifier does not drop here.
   auto& r = x; // const int& r = x;
 #+END_SRC

 Array and function rules are also different:
 #+BEGIN_SRC C++
   int a[3] = { 1, 2, 3 };
   // Array decay does not occur here.
   auto& x = a; // int (&x)[3] = a;
   auto& str = "test"; // const char (&str)[5] = "test";

   int foo(int);
   // There is no decay here. Type deduction will be int(int) type for auto.
   auto& f1 = foo; // int (&f1)(int) = foo;   
 #+END_SRC

 If double reference (&&) declarator (forwarding-reference) is used with ~auto~, the rules change significantly. If ~auto&&~ is used, the type deduction for the ~auto~ keyword depends on the value category of the object used for initialization. Different rules are applied for L-value expressions and R-value expressions (PR-value or X-value).

 If value of category of the initializer is PR-value, the type deduction for ~auto~ will be the type of the expression:
 #+BEGIN_SRC C++
   // Type deduction for auto will be int because type of 20 is int.
   auto&& p = 20; // int&& p = 20;
 #+END_SRC

 If value of category of the initializer is L-value, the type deduction for ~auto~ will be L-value reference:
 #+BEGIN_SRC C++
   int x;
   // Type deduction for auto will be int& but there is no int&&&, so reference collapsing rules apply here.
   auto&& p = x; // After reference collapsing this equals to int& p = x;
 #+END_SRC

 Reference collapsing rules:
| reference type | binding reference type | result after reference collapsing |
|----------------+------------------------+-----------------------------------|
| T&             | T&&                    | T&                                |
| T&&            | T&                     | T&                                |
| T&             | T&                     | T&                                |
| T&&            | T&&                    | T&&                               |

