* Fundemental Differences Between C and C++
 Main purpose of this section is to point out the differences between C and C++. It isn't about how code should or should not be written in C or C++. It is only about validity of the code.
** Syntax Differences
*** Implicit int
 If a function does not have a return type:
 - In C, it is allowed and compilers assume it returns ~int~. It is also allowed in function declarations.
 - In C++, it is syntax error.
 This code is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   func(int x)
   {
       return x + 1;
   }
 #+END_SRC

*** Missing return statement in functions with non-void return type
 If a function has return type but does not return anything:
 - In C, it is allowed. Compilers can show a warning but they don't have to.
 - In C++, it is syntax error.
 This code is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   int func() {}
 #+END_SRC

*** Implicit/default function declaration
 If name lookup fails for a function:
 - In C, compilers will assume it is an external function with the default declaration: ~int func();~
 - In C++, it is syntax error.
 This code will compile in C and compiler will assume ~bar()~ function has ~int bar();~ declaration:
 #+BEGIN_SRC C++
   void foo()
   {
       bar();
   }
 #+END_SRC

*** Declaration of functions without parameter
 There are different rules for C and C++.
  #+BEGIN_SRC C++
    int foo();
    int bar(void);
  #+END_SRC
  - In C, these 2 function declarations have different meaning.
   + ~int foo();~ means, we don't have any information about parameters so we can pass what ever we want.
   + ~int bar(void);~ means, function does not take any parameters.
  - In C++, both of the declarations have the same meaning. Functions do not take any parameters.
  According to the declarations above, this code is valid in C. Invalid in C++, because ~int foo();~ does not take any parameters.
  #+BEGIN_SRC C++
    foo(1, 2);
  #+END_SRC

*** Nameless parameters in function definitions
 Caution! This is about function definitions not declarations.
  - In C, it is not allowed. (Since C20, it is also allowed in C.)
  - In C++, it is allowed.
  This code is invalid for C (before C20) and valid for C++:
  #+BEGIN_SRC C++
    void func(int) {}
  #+END_SRC

*** Scope of for-statement
 - In C, inside of the for loop has a different block scope than for-statement itself.
 - In C++, inside of the for loop and for-statement itself are in same block scope.
 Because of this difference, name shadowing inside a for loop is valid in C, but invalid in C++:
 #+BEGIN_SRC C++
   for (int i = 0; i < 10 ++i;)
   {
       int i = 99;
   }
 #+END_SRC
 We can say above code looks like this for C compiler:
 #+BEGIN_SRC C++
   for (int i = 0; i < 10 ++i;)
   {
       {
	   int i = 99;
       }
   }
 #+END_SRC
 /Note: For C and C++, name shadowing is only valid between different scopes./

** Differences About Types and Type Conversions
*** Logic data type (boolean)
 In C:
 - ~int~ is used instead of logic data type.
 - ~_Bool~ type is added in C99, but it is not widely used.
 - C doesn't have ~false~, ~true~ constants. ~stdbool.h~ defines macros for them.

 In C++:
 - ~bool~ type, ~false~ and ~true~ constants are build-in to the language. No need to include anything.
 - Implicit type conversion from arithmetic types and pointer types to ~bool~ is allowed.
 - Implicit type conversion from ~bool~ to arithmetic types is allowed.
 These are valid in C++:
 #+BEGIN_SRC C++
   // Implicit conversion from arithmetic types to bool
   int x = 45;
   bool b1 = x;

   double y = 33.11;
   bool b2 = y;

   // Implicit conversion from pointer types to bool
   int z = 100;
   int* p = &z;
   bool b3 = p;

   // Implicit conversion from bool to arithmetic types
   bool b4 = true;
   int t = b4;
 #+END_SRC

 But, this is invalid:
 #+BEGIN_SRC C++
   // No implicit conversion from bool to pointer types
   bool b5 = false;
   int* ptr = b5;
 #+END_SRC

*** User defined types
 - In C, ~struct~, ~enum~ and ~union~ tags don't represent type itself. A keyword (~struct~, ~enum~ or ~union~) must be used before a tag name to represent a type. A ~typedef~ declaration can be used too.
 - In C++, tag names directly represent type names.
 Here are some examples:
 #+BEGIN_SRC C++
   struct Data
   {
       int a, b, c;
   };

   // Invalid in C. Valid in C++. There is no need to use struct keyword or typedef declaration in C++.
   Data data0;

   // Valid in C and C++.
   struct Data data1;

   typedef struct Example
   {
       int a, b, c;
   } Example;

   // Valid in C and C++.
   Example example0;
 #+END_SRC

*** Empty structs
 - In C, empty structs are invalid.
 - In C++, empty structs are valid.
 An example:
 #+BEGIN_SRC C++
   struct Data
   {
   };
 #+END_SRC

*** Implicit conversion from arithmetic types to pointer types
 - In C, implicit conversion from arithmetic types to pointer types is allowed. Compilers might show a warning.
 - In C++, there is no implicit conversion from arithmetic types to pointer types.
 This is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   int x = 20;
   int* p = x;
 #+END_SRC

*** Implicit conversion between different pointer types.
 - In C, implicit conversion between different pointer is allowed. Compilers might show a warning.
 - In C++, there is no implicit conversion between different pointer types.
 This is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   double d = 33.11;
   char* ptr = &d;
 #+END_SRC

*** Implicit conversion from ~void*~ to ~T*~
 - In C, implicit conversion from ~void*~ to ~T*~ is allowed.
 - In C++, implicit conversion from ~void*~ to ~T*~ is not allowed.
 This code is valid in C but invalid in C++:
 #+BEGIN_SRC C++
  int* p = malloc(1000 * sizeof(int));
 #+END_SRC

*** Underlying enumeration type
 - In C, underlying enumeration type has to be ~int~.
 - In C++, it does not have to be ~int~ and can be specified with special syntax.

*** Implicit conversion from arithmetic types to enumeration types
 - In C, it is allowed.
 - In C++, it is not.
 This code is valid in C but invalid in C++:
 #+BEGIN_SRC C++
   enum Color { Red, Green, Blue };
   enum Color color;
   color = 3;
 #+END_SRC

*** Implicit conversion between different enumeration types
 - In C, it is allowed.
 - In C++, it is not.
 This code is valid in C but invalid in C++:
 #+BEGIN_SRC C++
   enum Color { Red, Green, Blue };
   enum Count { Zero, One, Two };
   enum Color color = Red;
   enum Count count = Zero;
   color = count;
 #+END_SRC

*** Implicit conversion from enumeration types to arithmetic types.
 - In C, it is allowed.
 - In C++, it is also allowed. Scoped enums can be used to prevent this.
 This code is valid in C and C++:
 #+BEGIN_SRC C++
   enum Color { Red, Green, Blue };
   enum Color color = Red;
   int x = color;
 #+END_SRC

*** Character literals
 - In C, character literals are ~int~.
 - In C++, character literals are ~char~.
 This code prints 4 in C and 1 in C++:
 #+BEGIN_SRC C++
   printf("%zu\n", sizeof('A'));
 #+END_SRC

*** String literals
 - In C, the type of string literals is ~char[n]~. When string literals are used in an expression they are converted to address of the first element (array decay - array to pointer conversion). The type after array decay is ~char*~.
 - In C++, the type of string literals is ~const char[n]~. Array decay also applies to C++ but the type after array decay is ~const char*~.
 This string literal is ~char[8]~ in C and ~const char[8]~ in C++:
 #+BEGIN_SRC C++
   "example"
 #+END_SRC
 This is valid in C but invalid in C++:
 #+BEGIN_SRC C++
   // In C++, it is decayed to const char* and there is no implicit conversion from const T* to T*.
   char* s = "example";
 #+END_SRC
 
** Differences About const Keyword
*** Initialization of const objects
 - In C, ~const~ objects don't have to be initialized.
 - In C++, ~const~ objects have to be initialized.
 This is code is valid in C and invalid in C++:
 #+BEGIN_SRC C++
  const int x;
 #+END_SRC
 Might be a bit tricky to understand at first but this is also valid in C++:
 #+BEGIN_SRC C++
   // This is a pointer to const int. Object/variable itself is not const here it just points to const int
   const int* ptr;
 #+END_SRC
 But this is invalid:
 #+BEGIN_SRC C++
   // This is a const pointer to int. Object/variable itself is const
   int* const ptr;
 #+END_SRC

*** Const expressions
 - In C, expressions generated by const variables are not counted as const expressions.
 - In C++, they count as const expressions.
 This is invalid in C (assuming no VLA) but valid in C++:
 #+BEGIN_SRC C++
   const int x = 10;
   int arr[x] = { 0 };
 #+END_SRC

*** Global const objects and linkage
 - In C, global const objects are in external linkage.
 - In C++, global const objects are in internal linkage like ~static~ objects.
 ~x~ is in external linkage in C and internal linkage in C++:
 #+BEGIN_SRC C++
   // In global scope
   const int x = 10;
 #+END_SRC

*** Implicit conversion from ~const T*~ to ~T*~
 - In C, implicit conversion from ~const T*~ to ~T*~ is allowed. Compilers might show a warning.
 - In C++, there is no implicit conversion from ~const T*~ to ~T*~.
 This is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   const int x = 10;
   int* p = &x;
 #+END_SRC

** Differences About Value Categories
*** Primary value categories
 - In C, there are 2 primary value categories.
   + L-value
   + R-value
 - In C++, there are 3 primary value categories.
   + L-value
   + PR-value (pure R-value)
   + X-value (expired value)
 The combination of the ~PR-value~ and ~X-value~ categories is called the ~R-value~ category. (~PR-value~ \cup ~X-value~ = ~R-value~). When we say an expression is ~R-value~ it means it may be an ~PR-value~ or ~X-value~ in C++.
 
 The combination of the ~L-value~ and ~X-value~ categories is called the ~GL-value~ category. (~L-value~ \cup ~X-value~ = ~GL-value~). When we say an expression is ~GL-value~ it means it may be an ~L-value~ or ~X-value~ in C++.
 
 The ~GL-value~ and ~R-value~ categories are not ~primary value categories~. They are called ~combined value categories~.
 
*** Prefix increment/decrement operator
 - In C, expressions generated by prefix increment/decrement operator are R-value expressions.
 - In C++, they are L-value expressions.
 This code is valid in C++ and invalid in C:
 #+BEGIN_SRC C++
   int x = 10;
   // These are invalid in C, because R-value expressions cannot be an operand of the address(&) operator.
   &++x;
   &--x;
 #+END_SRC

*** Assignment operator
 - In C, expressions generated by assignment operator are R-value expressions.
 - In C++, they are L-value expressions.
 This code is valid in C++ and invalid in C:
 #+BEGIN_SRC C++
   int x = 10;
   &(x = 5);
 #+END_SRC

*** Comma operator
 - In C, expressions generated by comma operator are R-value expressions.
 - In C++, they can be L-value or R-value expressions.
 This code is valid in C++ and invalid in C:
 #+BEGIN_SRC C++
   int x = 10;
   int y = 20;
   (x, y) = 30; // y = 30;
 #+END_SRC

*** Ternary operator
 - In C, expressions generated by ternary operator are R-value expressions.
 - In C++, they can be L-value or R-value expressions.
 This code is valid in C++ and invalid in C:
 #+BEGIN_SRC C++
   int x = 10;
   int y = 20;
   int z = 30;
   (x == 10 ? y : z) = 40; // y = 40;
 #+END_SRC

* C++ Topics
** Initialization
 There are very different ways to initialize objects in C++.
*** Default initialization
 Default initialized objects are created with a garbage value.
 #+BEGIN_SRC C++
   int x; // Default initialization.
 #+END_SRC

*** Zero initialization
 Compilers zero initialize objects in the global scope. ~Zero initialization~ is not a way to initialize objects it is more like a compiler process.
 #+BEGIN_SRC C++
   // Global scope
   int x;  // x = 0;
   bool b; // b = false;
   int* p; // p = nullptr;
 #+END_SRC

*** Copy initialization
 If objects are initialized like in the C language, it is called ~copy initialization~.
 #+BEGIN_SRC C++
   int x = 10; // Copy initialization.
 #+END_SRC

*** Direct initialization
 If objects are initialized by using paranthesis, it is called ~direct initialization~.
 #+BEGIN_SRC C++
   int x(98); // Direct initialization.
 #+END_SRC

*** Direct-list / brace initialization (uniform initialization)
 If objects are initialized by using braces, it is called ~direct-list initialization~. ~direct-list/brace initialization~ is added to the language to have a uniform way to initialize objects. This is why it is also called ~uniform initialization~. It can be used to initialize any object.
 #+BEGIN_SRC C++
  int x{ 10 }; // Direct-list initialization.
 #+END_SRC

 Unlike other initialization methods, if an implicit narrowing conversion occurs during ~direct-list initialization~, it is a syntax error.
 #+BEGIN_SRC C++
   double dval = 5.6;

   // Implicit narrowing conversion does not cause any error but compilers might show a warning.
   int i1 = dval;
   int i2(dval);

   // Invalid. Implicit narrowing conversion causes a syntax error. Explicit cast is needed.
   int i3{dval};
 #+END_SRC

 In C++, there are such declarations that can be interpreted as both ~object instantiation~ and ~function declaration~ at the same time. In such cases, ~function declaration~ has the priority. This is called ~most vexing parse~ and sometimes it leads to problems.
 Example:
 #+BEGIN_SRC C++
   struct A
   {
   };

   struct B
   {
       B(A);
   };

   // Here, we wanted to create a bx object from class B type by calling its constructor with a temporary object with class A type.
   // C++ understands this as a function declaration. It is a function named bx and it has a return type of class B,
   // and takes a function pointer as a parameter. Sigh..
   B bx(A());

   // This can be prevented by using direct-list initialization.
   B by{A()};
   B bz(A{});
 #+END_SRC

*** Value initialization
 If objects are initialized by using braces but inside of the braces are empty, it is called ~value initialization~. Value initialized objects are first initialized to zero, if any additional initialization steps are required, this is done after ~zero initialization~.
 #+BEGIN_SRC C++
   int x{}; // Value initialization.
 #+END_SRC

** nullptr
 In C++, there is a keyword that represents a null pointer, and it is called ~nullptr~. It is not a macro like in C. It is a keyword, a constant and its type is ~nullptr_t~.

 You can assign ~nullptr~ to other pointer types but there is no implicit conversion from ~nullptr_t~ type to arithmetic types.
 #+BEGIN_SRC C++
   // Invalid
   int x = nullptr;

   // Valid
   int* y = nullptr;
   double* z = nullptr;
 #+END_SRC

** Reference Semantics
 There is an alternative way to represent pointers in C++, which is called ~reference~,, but this is only an alternative at the language layer, the underlying representation does not change once the code is compiled. Everything works with the pointers in assembly level.

 There are 3 different reference categories:
  - L-value reference
  - R-value reference
  - Forwarding/universal reference
  An example:
  #+BEGIN_SRC C++
    int x = 10;
    // L-value reference
    int& y = x;
    // R-value reference
    int&& z = 10;
    // Forwarding/universal reference
    auto&& t = 10;
  #+END_SRC

