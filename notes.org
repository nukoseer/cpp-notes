* Fundemental Differences Between C and C++
 Main purpose of this section is to point out the differences between C and C++. It isn't about how code should or should not be written in C or C++. It is only about validity of the code.
** Syntax Differences
*** Implicit int
 If a function does not have a return type:
 - In C, it is allowed and compilers assume it returns ~int~. It is also allowed in function declarations.
 - In C++, it is syntax error.
 This code is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   func(int x)
   {
       return x + 1;
   }
 #+END_SRC

*** Missing return statement in functions with non-void return type
 If a function has return type but does not return anything:
 - In C, it is allowed. Compilers can show a warning but they don't have to.
 - In C++, it is syntax error.
 This code is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   int func() {}
 #+END_SRC

*** Implicit/default function declaration
 If name lookup fails for a function:
 - In C, compilers will assume it is an external function with the default declaration: ~int func();~
 - In C++, it is syntax error.
 This code will compile in C and compiler will assume ~bar()~ function has ~int bar();~ declaration:
 #+BEGIN_SRC C++
   void foo()
   {
       bar();
   }
 #+END_SRC

*** Declaration of functions without parameter
 There are different rules for C and C++.
  #+BEGIN_SRC C++
    int foo();
    int bar(void);
  #+END_SRC
  - In C, these 2 function declarations have different meaning.
   + ~int foo();~ means, we don't have any information about parameters so we can pass what ever we want.
   + ~int bar(void);~ means, function does not take any parameters.
  - In C++, both of the declarations have the same meaning. Functions do not take any parameters.
  According to the declarations above, this code is valid in C. Invalid in C++, because ~int foo();~ does not take any parameters.
  #+BEGIN_SRC C++
    foo(1, 2);
  #+END_SRC

*** Nameless parameters in function definitions
 This is about function definitions not declarations.
  - In C, it is not allowed. (Since C20, it is also allowed in C.)
  - In C++, it is allowed.
  This code is invalid for C (before C20) and valid for C++:
  #+BEGIN_SRC C++
    void func(int) {}
  #+END_SRC

*** Scope of for-statement
 - In C, inside of the for loop has a different block scope than for-statement itself.
 - In C++, inside of the for loop and for-statement itself are in same block scope.
 Because of this difference, name shadowing inside a for loop is valid in C, but invalid in C++:
 #+BEGIN_SRC C++
   for (int i = 0; i < 10; ++i)
   {
       int i = 99;
   }
 #+END_SRC
 We can say above code looks like this for C compiler:
 #+BEGIN_SRC C++
   for (int i = 0; i < 10; ++i)
   {
       {
	   int i = 99;
       }
   }
 #+END_SRC
 /Note: For C and C++, name shadowing is only valid between different scopes./

** Differences About Types and Type Conversions
*** Logic data type (boolean)
 In C:
 - ~int~ is used instead of logic data type.
 - ~_Bool~ type is added in C99, but it is not widely used.
 - C doesn't have ~false~, ~true~ constants. ~stdbool.h~ defines macros for them.

 In C++:
 - ~bool~ type, ~false~ and ~true~ constants are build-in to the language. No need to include anything.
 - Implicit type conversion from arithmetic types and pointer types to ~bool~ is allowed.
 - Implicit type conversion from ~bool~ to arithmetic types is allowed.
 These are valid in C++:
 #+BEGIN_SRC C++
   // Implicit conversion from arithmetic types to bool
   int x = 45;
   bool b1 = x;

   double y = 33.11;
   bool b2 = y;

   // Implicit conversion from pointer types to bool
   int z = 100;
   int* p = &z;
   bool b3 = p;

   // Implicit conversion from bool to arithmetic types
   bool b4 = true;
   int t = b4;
 #+END_SRC

 But, this is invalid:
 #+BEGIN_SRC C++
   // No implicit conversion from bool to pointer types
   bool b5 = false;
   int* ptr = b5;
 #+END_SRC

*** User defined types
 - In C, ~struct~, ~enum~ and ~union~ tags don't represent type itself. A keyword (~struct~, ~enum~ or ~union~) must be used before a tag name to represent a type. A ~typedef~ declaration can be used too.
 - In C++, tag names directly represent type names.
 Here are some examples:
 #+BEGIN_SRC C++
   struct Data
   {
       int a, b, c;
   };

   // Invalid in C. Valid in C++. There is no need to use struct keyword or typedef declaration in C++.
   Data data0;

   // Valid in C and C++.
   struct Data data1;

   typedef struct Example
   {
       int a, b, c;
   } Example;

   // Valid in C and C++.
   Example example0;
 #+END_SRC

*** Empty structs
 - In C, empty structs are invalid.
 - In C++, empty structs are valid.
 An example:
 #+BEGIN_SRC C++
   struct Data
   {
   };
 #+END_SRC

*** Implicit conversion from arithmetic types to pointer types
 - In C, implicit conversion from arithmetic types to pointer types is allowed. Compilers might show a warning.
 - In C++, there is no implicit conversion from arithmetic types to pointer types.
 This is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   int x = 20;
   int* p = x;
 #+END_SRC

*** Implicit conversion between different pointer types.
 - In C, implicit conversion between different pointer is allowed. Compilers might show a warning.
 - In C++, there is no implicit conversion between different pointer types.
 This is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   double d = 33.11;
   char* ptr = &d;
 #+END_SRC

*** Implicit conversion from ~void*~ to ~T*~
 - In C, implicit conversion from ~void*~ to ~T*~ is allowed.
 - In C++, implicit conversion from ~void*~ to ~T*~ is not allowed.
 This code is valid in C but invalid in C++:
 #+BEGIN_SRC C++
  int* p = malloc(1000 * sizeof(int));
 #+END_SRC

*** Underlying enumeration type
 - In C, underlying enumeration type has to be ~int~.
 - In C++, it does not have to be ~int~ and can be specified with special syntax.

*** Implicit conversion from arithmetic types to enumeration types
 - In C, it is allowed.
 - In C++, it is not.
 This code is valid in C but invalid in C++:
 #+BEGIN_SRC C++
   enum Color { Red, Green, Blue };
   enum Color color;
   color = 3;
 #+END_SRC

*** Implicit conversion between different enumeration types
 - In C, it is allowed.
 - In C++, it is not.
 This code is valid in C but invalid in C++:
 #+BEGIN_SRC C++
   enum Color { Red, Green, Blue };
   enum Count { Zero, One, Two };
   enum Color color = Red;
   enum Count count = Zero;
   color = count;
 #+END_SRC

*** Implicit conversion from enumeration types to arithmetic types.
 - In C, it is allowed.
 - In C++, it is also allowed. Scoped enums can be used to prevent this.
 This code is valid in C and C++:
 #+BEGIN_SRC C++
   enum Color { Red, Green, Blue };
   enum Color color = Red;
   int x = color;
 #+END_SRC

*** Character literals
 - In C, character literals are ~int~.
 - In C++, character literals are ~char~.
 This code prints 4 in C and 1 in C++:
 #+BEGIN_SRC C++
   printf("%zu\n", sizeof('A'));
 #+END_SRC

*** String literals
 - In C, the type of string literals is ~char[n]~. When string literals are used in an expression they are converted to address of the first element (array decay - array to pointer conversion). The type after array decay is ~char*~.
 - In C++, the type of string literals is ~const char[n]~. Array decay also applies to C++ but the type after array decay is ~const char*~.
 This string literal is ~char[8]~ in C and ~const char[8]~ in C++:
 #+BEGIN_SRC C++
   "example"
 #+END_SRC
 This is valid in C but invalid in C++:
 #+BEGIN_SRC C++
   // In C++, it is decayed to const char* and there is no implicit conversion from const T* to T*.
   char* s = "example";
 #+END_SRC
 
** Differences About const Keyword
*** Initialization of const objects
 - In C, ~const~ objects don't have to be initialized.
 - In C++, ~const~ objects have to be initialized.
 This is code is valid in C and invalid in C++:
 #+BEGIN_SRC C++
  const int x;
 #+END_SRC
 Might be a bit tricky to understand at first but this is also valid in C++:
 #+BEGIN_SRC C++
   // This is a pointer to const int. Object/variable itself is not const here it just points to const int
   const int* ptr;
 #+END_SRC
 But this is invalid:
 #+BEGIN_SRC C++
   // This is a const pointer to int. Object/variable itself is const
   int* const ptr;
 #+END_SRC

*** Const expressions
 - In C, expressions generated by const variables are not counted as const expressions.
 - In C++, they count as const expressions.
 This is invalid in C (assuming no VLA) but valid in C++:
 #+BEGIN_SRC C++
   const int x = 10;
   int arr[x] = { 0 };
 #+END_SRC

*** Global const objects and linkage
 - In C, global const objects are in external linkage.
 - In C++, global const objects are in internal linkage like ~static~ objects.
 ~x~ is in external linkage in C and internal linkage in C++:
 #+BEGIN_SRC C++
   // In global scope
   const int x = 10;
 #+END_SRC

*** Implicit conversion from ~const T*~ to ~T*~
 - In C, implicit conversion from ~const T*~ to ~T*~ is allowed. Compilers might show a warning.
 - In C++, there is no implicit conversion from ~const T*~ to ~T*~.
 This is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   const int x = 10;
   int* p = &x;
 #+END_SRC

** Differences About Value Categories
*** Primary value categories
 - In C, there are 2 primary value categories.
   + L-value
   + R-value
 - In C++, there are 3 primary value categories.
   + L-value
   + PR-value (pure R-value)
   + X-value (expired value)
 The combination of the ~PR-value~ and ~X-value~ categories is called the ~R-value~ category. (~PR-value~ \cup ~X-value~ = ~R-value~). When we say an expression is ~R-value~ it means it may be an ~PR-value~ or ~X-value~ in C++.
 
 The combination of the ~L-value~ and ~X-value~ categories is called the ~GL-value~ category. (~L-value~ \cup ~X-value~ = ~GL-value~). When we say an expression is ~GL-value~ it means it may be an ~L-value~ or ~X-value~ in C++.
 
 The ~GL-value~ and ~R-value~ categories are not ~primary value categories~. They are called ~combined value categories~.
 
*** Prefix increment/decrement operator
 - In C, expressions generated by prefix increment/decrement operator are R-value expressions.
 - In C++, they are L-value expressions.
 This code is valid in C++ and invalid in C:
 #+BEGIN_SRC C++
   int x = 10;
   // These are invalid in C, because R-value expressions cannot be an operand of the address(&) operator.
   &++x;
   &--x;
 #+END_SRC

*** Assignment operator
 - In C, expressions generated by assignment operator are R-value expressions.
 - In C++, they are L-value expressions.
 This code is valid in C++ and invalid in C:
 #+BEGIN_SRC C++
   int x = 10;
   &(x = 5);
 #+END_SRC

*** Comma operator
 - In C, expressions generated by comma operator are R-value expressions.
 - In C++, they can be L-value or R-value expressions.
 This code is valid in C++ and invalid in C:
 #+BEGIN_SRC C++
   int x = 10;
   int y = 20;
   (x, y) = 30; // y = 30;
 #+END_SRC

*** Ternary operator
 - In C, expressions generated by ternary operator are R-value expressions.
 - In C++, they can be L-value or R-value expressions.
 This code is valid in C++ and invalid in C:
 #+BEGIN_SRC C++
   int x = 10;
   int y = 20;
   int z = 30;
   (x == 10 ? y : z) = 40; // y = 40;
 #+END_SRC

* C++ Topics
** Initialization
 There are very different ways to initialize objects in C++.
*** Default initialization
 Default initialized objects are created with a garbage value.
 #+BEGIN_SRC C++
   int x; // Default initialization.
 #+END_SRC

*** Zero initialization
 Compilers zero initialize objects in the global scope. ~Zero initialization~ is not a way to initialize objects it is more like a compiler process.
 #+BEGIN_SRC C++
   // Global scope
   int x;  // x = 0;
   bool b; // b = false;
   int* p; // p = nullptr;
 #+END_SRC

*** Copy initialization
 If objects are initialized like in the C language, it is called ~copy initialization~.
 #+BEGIN_SRC C++
   int x = 10; // Copy initialization.
 #+END_SRC

*** Direct initialization
 If objects are initialized by using paranthesis, it is called ~direct initialization~.
 #+BEGIN_SRC C++
   int x(98); // Direct initialization.
 #+END_SRC

*** Direct-list / brace initialization (uniform initialization)
 If objects are initialized by using braces, it is called ~direct-list initialization~. ~direct-list/brace initialization~ is added to the language to have a uniform way to initialize objects. This is why it is also called ~uniform initialization~. It can be used to initialize any object.
 #+BEGIN_SRC C++
  int x{ 10 }; // Direct-list initialization.
 #+END_SRC

 Unlike other initialization methods, if an implicit narrowing conversion occurs during ~direct-list initialization~, it is a syntax error.
 #+BEGIN_SRC C++
   double dval = 5.6;

   // Implicit narrowing conversion does not cause any error but compilers might show a warning.
   int i1 = dval;
   int i2(dval);

   // Invalid. Implicit narrowing conversion causes a syntax error. Explicit cast is needed.
   int i3{dval};
 #+END_SRC

 In C++, there are such declarations that can be interpreted as both ~object instantiation~ and ~function declaration~ at the same time. In such cases, ~function declaration~ has the priority. This is called ~most vexing parse~ and sometimes it leads to problems.
 Example:
 #+BEGIN_SRC C++
   struct A
   {
   };

   struct B
   {
       B(A);
   };

   // Here, we wanted to create a bx object from class B type by calling its constructor with a temporary object with class A type.
   // C++ understands this as a function declaration. It is a function named bx and it has a return type of class B,
   // and takes a function pointer as a parameter. Sigh..
   B bx(A());

   // This can be prevented by using direct-list initialization.
   B by{A()};
   B bz(A{});
 #+END_SRC

*** Value initialization
 If objects are initialized by using braces but inside of the braces are empty, it is called ~value initialization~. Value initialized objects are first initialized to zero, if any additional initialization steps are required, this is done after ~zero initialization~.
 #+BEGIN_SRC C++
   int x{}; // Value initialization.
 #+END_SRC

** nullptr
 In C++, there is a keyword that represents a null pointer, and it is called ~nullptr~. It is not a macro like in C. It is a keyword, a constant and its type is ~nullptr_t~.

 You can assign ~nullptr~ to other pointer types but there is no implicit conversion from ~nullptr_t~ type to arithmetic types.
 #+BEGIN_SRC C++
   // Invalid
   int x = nullptr;

   // Valid
   int* y = nullptr;
   double* z = nullptr;
 #+END_SRC

** Reference Semantics
 There is an alternative way to represent pointers in C++, which is called ~reference~, but this is only an alternative at the language layer, the underlying representation does not change once the code is compiled. Everything works with the pointers in assembly level.

 There are 3 different reference categories:
  - L-value reference
  - R-value reference (move semantics, perfect forwarding (generic prog.))
  - Forwarding/universal reference
  An example:
  #+BEGIN_SRC C++
    int x = 10;
    // L-value reference
    int& y = x;
    // R-value reference
    int&& z = 10;
    // Forwarding/universal reference
    auto&& t = 10;
  #+END_SRC

*** L-value references
  L-value references are similar to ~top-level const pointer objects~:
  #+BEGIN_SRC C++
    int x = 10;

    // We cannot change the value of the ptr because it is a const pointer. It will always point to the same object
    // which is x in this case. Whenever *ptr is used, it means x.
    int* const ptr = &x;
    int y = *ptr; // int y = x;
  #+END_SRC

  L-value references represent their underlying object directly, there is no need for dereferencing like pointers. They cannot be default initialized, cannot be initialized with R-value objects and cannot be reassigned/rebound(like ~top-level const pointer~).
  #+BEGIN_SRC C++
       int x = 10;

       // Reference r directly represents x
       int& r = x;
       // No need to dereference like a pointer
       int y = r; // int y = x;

       int& r1; // Syntax error. References cannot be default initialized.
       int& r2 = 10; // Syntax error. References cannot be initialized with R-value objects.

       int z = 10;
       int t = 20;
       int& r3 = z;

       // This is valid but equals to z = t. r3 still represents z, what we did is changing value of z.
       // References cannot be reassigned.
       r3 = t; 
  #+END_SRC

 We can say that when we define a L-value reference we bind it to underlying object and they will stay bound until the end of scope.
  #+BEGIN_SRC C++
    int x = 10;
    // All r1, r2 and r3 bound to x
    int& r1 = x;
    int& r2 = r1;
    int& r3 = r2;

    ++r1;
    ++r2;
    ++r3;
    // x is 13 here

  #+END_SRC

 L-value rereferences can also be bound to arrays and array decay rules do not change:
  #+BEGIN_SRC C++
    int a[] = { 1, 3, 5, 7, 9 };
    // r is bound to a
    int (&ra)[] = a; // Normally, we do not have to write the type directly. we can use type deduction.

    for (int i = 0; i < 5; ++i)
    {
       // ra[i] equals to a[i]
    }

    // Same rules apply for array decay
    int* p1 = a;
    int* p2 = ra;
  #+END_SRC

  L-value references often used to pass the object to the function (~call by reference~) and also to return the object itself from the function.
  #+BEGIN_SRC C++
    int& foo(int& r)
    {
	++r;
	return r;
    }

    int x = 10;

    // Value of x will be 11 after foo() is called
    // r represents x
    int& r = foo(x);
  #+END_SRC 
   
*** L-value references and const semantics
 We said that L-value references are like ~top-level const pointer~ by default but they can also be used like ~low-level const pointer~.
 Pointer parameters can be used as a mutator or accessor. L-value references also can be used in a similar way:
  #+BEGIN_SRC C++
    void f1(int* p); // Mutator
    void f2(const int* p); // Accessor

    void f3(int& r); // Mutator
    void f4(const int& r); // Accessor
  #+END_SRC 

  ~const~ objects can only be bound by ~const~ L-value references similar to pointers:
  #+BEGIN_SRC C++
    const int x = 10;
    int* p = &x; // Invalid. int* p cannot point to const int x.
    int& r = x; // Also invalid. int& r cannot bind to const int x.

    const int& cr = x; // Valid.
  #+END_SRC 

 Normally, initializing an L-value reference with a different/mismatching object type is syntax error:
  #+BEGIN_SRC C++
    int x = 10;
    double& r = x; // Syntax error. double& r cannot bind to int object.
  #+END_SRC

  But, if we try to initialize a ~const~ L-value reference with a different/mismatching object type and there is an implicit conversion from that object type to the type represented by the ~const~ L-value reference, the compiler creates a temporary object and the ~const~ L-value reference is bound to that temporary object:
  #+BEGIN_SRC C++
    int x = 10;
    // This is valid. Normally, double and int types do not match but implicit conversion is allowed from int to double.
    // So, compiler creates a temporary double object and assign x to it, then cr binds to that temporary object.
    const double& cr = x; 

    // We can think that compiler generates something like this for above code.
    // double temporary_object = x;
    // const double& cr = temporary_object;
  #+END_SRC

 This also applies, when we try to initialize ~const~ L-value references with R-value objects:
  #+BEGIN_SRC C++
     // This is syntax error. L-value references cannot be initialized with R-value objects.
    int& r = 10;

    // This is valid when we use const L-value reference, because compiler creates a temporary object like the example above.
    const int& cr = 10;

    // Compiler might generate something like this for above code.
    // int temporary_object = 10;
    // const int& cr = temporary_object;
  #+END_SRC

  This becomes even more important when we call functions that take L-value reference parameters, for example:
   #+BEGIN_SRC C++
     // We can only pass an L-value objects to f1(). If we try to pass a R-value object it will be syntax error.
     void f1(int& x);
     int x = 10;
     f1(x); // Valid.
     f2(10); // Invalid, syntax error.

     // It is not the same for f2() however. We can pass L-value objects to f2() but if we try to pass a R-value object, it will not cause
     // any syntax error because of the rules above. The temporary object will be passed to f2() instead of R-value object itself. (Assuming there is no type problem)
     void f2(const int& x);
     int y = 10;
     f2(y); // Valid.
     f2(10); // Also valid.
   #+END_SRC

*** Differences between pointers and L-value references
| Pointers                       | References                                                           |
|--------------------------------+----------------------------------------------------------------------|
| don't have to be initialized   | have to be initialized                                               |
| pointer to pointer exists      | reference to reference doesn't exist (ignoring reference collapsing) |
| arrays can store pointers      | arrays cannot store references                                       |
| pointers can be null (nullptr) | references cannot be null                                            |
| pointers can be reassigned     | references cannot be reassigned                                      |

*** R-value references
 R-value references are mostly about move semantics and perfect forwarding. Details will be discussed in the future. We will just briefly explain the syntax for now.
 R-value references cannot be default-initialized like L-value references, and can be initialized only with R-value objects.
  #+BEGIN_SRC C++
    int&& r = 10; // Valid, R-value reference.

    int x = 10;
    int&& rr = x; // Invalid. R-value references cannot be initialized with L-value objects.
  #+END_SRC

  ...
  
** Type Deduction
 In C++, we don't need to write the type explicitly in some contexts. We can use one of the type deduction mechanisms to have the compiler determine the type for us by looking at the code.
 There are several different mechanisms for type deduction:
  - auto
  - decltype
  - decltyoe(auto)
  - template

*** auto type deduction
 The ~auto~ keyword can be used to determine the type of the variable during initialization. A very important point is that the type deduction is made for ~auto~ keyword not for the variable itself.
 #+BEGIN_SRC C++
   auto x = 10; // int x = 10;

   int y = 45;
   auto z = y; // int z = y;

   auto t = 0U; // unsigned int t = 0U;
   auto k = 0.; // double k = 0.;

   char c = 'a';
   auto a = c; // char a = c;
   auto b = +c; // int b = +c;

   auto d = 10 > 5; // bool d = 10 > 5;
 #+END_SRC

 We cannot ~default initialize~ an object with ~auto~ because in this case the compiler cannot determine its type:
 #+BEGIN_SRC C++
   auto x; // Invalid.
 #+END_SRC

 If an object is ~auto~ initialized with a ~const~ object and does not have any declarator (such as *, &), ~const~ qualifier drops:
 #+BEGIN_SRC C++
   const int cx = 6;
   // This equals to int y = cx;. const qualifier drops.
   auto y = cx;

   int* const ptr = 0;
   // ptr is const pointer to int. If the object itself is const, const qualifier drops.
   auto p = ptr; // int* p = ptr;

   const int* ptr1 = 0;
   // ptr1 is pointer to const int. The object itself is not const, const qualifier does not drop in this case.
   auto p1 = ptr1; // const int* p1 = ptr1;
 #+END_SRC

 If an object is ~auto~ initialized with a ~reference~ and does not have any declarator (such as *, &), ~reference~ qualifier drops:
 #+BEGIN_SRC C++
   int x = 10;
   int& r = x;
   // This equals to int y = r;. reference qualifier drops.
   auto y = r;

   const int& cr = x;
   // This equals to int z = cr;. const and reference qualifiers drop.
   auto z = cr;
 #+END_SRC

 Array decay rules are still valid: 
 #+BEGIN_SRC C++
   int a[] = { 1, 3, 6, 7 };
   auto p = a; // int* p = a;

   const int ca[] = { 1, 3, 6, 7 };
   // Here const qualifier does not drop. The object itself 'ca' is not const.
   // It is a pointer to const int after array decay.
   auto cp = ca; // const int* cp = ca;

   // The type of the "test" is const char[5], it decays to const char*.
   auto str = "test"; // const char* str = "test";
 #+END_SRC

 ~auto~ initialization with functions:
 #+BEGIN_SRC C++
   int foo(int);
   // Normally, type of the foo is int(int) but it decays to int (*)(int).
   auto fp = foo; // int (*fp)(int) = foo;
 #+END_SRC

 ~auto~ initialization and ~std::initializer_list~:
 #+BEGIN_SRC C++
   auto x = { 3 }; // std::initializer_list x = { 3 };
   auto y{ 3 }; // int y{ 3 }; This rule was different before. It was also meaning std::initializer_list y{ 3 };
 #+END_SRC

 Type deduction is made for ~auto~ keyword not for variable itself:
 #+BEGIN_SRC C++
   int x = 10;
   auto p1 = &x; // int* p1 = &x; auto -> int*
   auto* p2 = &x; // int* p2 = &x; auto -> int

   int* ptr = &x;
   auto p1 = &ptr; // int** p1 = &ptr; auto -> int**
   auto* p2 = &ptr; // int** p2 = &ptr; auto -> int*
   auto** p3 = &ptr; // int** p3 = &ptr; auto -> int
 #+END_SRC
 
 If declarators and ~auto~ are used together, rules are a bit different:
 In this example there is no difference:
 #+BEGIN_SRC C++
   int x = 10;
   auto& r = x; // int& r = x;
 #+END_SRC

 But when we use a ~const~ object:
 #+BEGIN_SRC C++
   const int x = 10;
   // const qualifier does not drop here.
   auto& r = x; // const int& r = x;
 #+END_SRC

 Array and function rules are also different:
 #+BEGIN_SRC C++
   int a[3] = { 1, 2, 3 };
   // Array decay does not occur here.
   auto& x = a; // int (&x)[3] = a;
   auto& str = "test"; // const char (&str)[5] = "test";

   int foo(int);
   // There is no decay here. Type deduction will be int(int) type for auto.
   auto& f1 = foo; // int (&f1)(int) = foo;   
 #+END_SRC

 If double reference (&&) declarator (forwarding-reference) is used with ~auto~, the rules change significantly. If ~auto&&~ is used, the type deduction for the ~auto~ keyword depends on the value category of the object used for initialization. Different rules are applied for L-value expressions and R-value expressions (PR-value or X-value).

 If value of category of the initializer is PR-value, the type deduction for ~auto~ will be the type of the expression:
 #+BEGIN_SRC C++
   // Type deduction for auto will be int because type of 20 is int.
   auto&& p = 20; // int&& p = 20;
 #+END_SRC

 If value of category of the initializer is L-value, the type deduction for ~auto~ will be L-value reference:
 #+BEGIN_SRC C++
   int x;
   // Type deduction for auto will be int& but there is no int&&&, so reference collapsing rules apply here.
   auto&& p = x; // After reference collapsing this equals to int& p = x;
 #+END_SRC

 Reference collapsing rules:
| reference type | binding reference type | result after reference collapsing |
|----------------+------------------------+-----------------------------------|
| T&             | T&&                    | T&                                |
| T&&            | T&                     | T&                                |
| T&             | T&                     | T&                                |
| T&&            | T&&                    | T&&                               |

*** decltype type deduction
 ~auto~ type deduction can be used for initialization but ~decltype~ type deduction does not have this limitation. It can be used in any context intead of types. ~decltype~ is also ~unevaluated context~ like ~sizeof~.

 ~decltype~ has quite complex rules. Using paranthesis is necessary while using ~decltype~. There are 2 different rulesets for ~decltype~:

 Rulesets:
  - If the operand of the ~decltype~ is an ~identifier~, different rules are applied.
  - If the operand of the ~decltype~ is an ~expression~, different rules are applied.

 Example for rulesets:
 #+BEGIN_SRC C++
   struct Data { int a, b, c; };
   
   Data my_data{};
   int x = 10;   
   
   // Identifier rules applied here.
   decltype(my_data);
   decltype(my_data.a);
   decltype(x);
   
   // But here expression rules are applied.
   decltype((x));
   decltype(+x);
 #+END_SRC

 ~decltype~ can be used in a lot of contexts:
 #+BEGIN_SRC C++
   int x = 10;

   decltype(x) foo(); // Function declaration. int foo();
   using my_type = decltype(x); // using my_type = int;

   const int y = 5;
   decltype(x) z = 0; // const int z = 0;
 #+END_SRC

 ~decltype~ and references:
  #+BEGIN_SRC C++
    int x{};
    auto& r{ x };

    decltype(r) r2 = x; // int& r2 = x;

    int y{};
    const auto& r3 = y;
    decltype(r3) r4 = y; // const int& r4 = y;
  #+END_SRC

 When the operand of the ~decltype~ is an expression. The type will be determined by the ~primary value category~ of the expression.
 If the expression is:
  - L-value deduction will be ~T&~
  - PR-value deduction will be ~T~
  - X-value deduction will be ~T&&~

 PR-value expression:
 #+BEGIN_SRC C++
   decltype(10); // PR-Value. int
 #+END_SRC
 
 L-value expression:
 #+BEGIN_SRC C++
   int x = 10;
   int* ptr = &x;
   decltype(*ptr) r = x; // L-value. int& r = x;
 
   int y = 5;
   decltype((y)) z = y; // L-value. int& z = y;
 
   int t = 10;
   decltype(t++); // int
   decltype(++t); // int&
 #+END_SRC
 
 ~decltype~ and arrays:
 #+BEGIN_SRC C++
   int a[5]{};
 
   // a is an identifier
   decltype(a) b; // int b[5]; No array decay.
   // a[0] is an expression
   decltype(a[0]) c = a[1]; // int& c = a[1];
 #+END_SRC

 X-value expression:
 #+BEGIN_SRC C++
  int f1();
  int& f2();
  int&& f3();

  decltype(f1()) x = 5; // PR-value. int x = 5;
  decltype(f2()) y = x; // L-value. int& y = x;
  decltype(f3()) z = 5; // X-value. int&& z = 5;
 #+END_SRC

 Other type deduction mechanisms will be discussed later.
 
 ... 
 
** Default Function Arguments
 Unlike C, C++ supports default function arguments. If a function mostly takes the same value for an argument, default function arguments are very helpful.
 When the ~default function argument~ is used, we do not need to pass a value to that argument when calling the function. The compiler will insert the value that we specified:
 #+BEGIN_SRC C++
   void func(int, int, int = 10);

   int x = 1;
   int y = 2;
   int z = 3;

   func(x, y, z); // func(x, y, z);
   func(x, y); // func(x, y, 10); The compiler will insert 10 for the 3rd argument because we did not send any argument for the 3rd parameter.
 #+END_SRC

 If a parameter of a function takes a ~default argument~, all parameters to the right of it must also take a ~default argument~. This essentially means that the ~default arguments~ are valid for the last function parameters:
 #+BEGIN_SRC C++
   void f1(int x, int y = 5, int z); // Invalid.
   void f2(int x, int y = 5, int z = 7); // Valid.
   void f3(int x = 3, int y = 5, int z = 7); // Valid.

   f3(); // f3(3, 5, 7);
   f3(40); // f3(40, 5, 7);
   f3(40, 50); // f3(40, 50, 7);
   f3(40, 50, 60); // f3(40, 50, 60);
 #+END_SRC

 Variables also can be used for ~default function arguments~:
 #+BEGIN_SRC C++
   int x{ 5 };
   void func(int = x); // Valid.

   func(); // func(x);

   int f1(int x = 0);
   void f2(int y = f1());

   f2(); // f2(f1(0));

   int y{ 5 };
   int foo(int n = y++)
   {
       return n;
   }

   // y = 5;
   foo(); // foo(y++); returns 5;
   foo(); // foo(y++); returns 6;
   foo(); // foo(y++); returns 7;
   // y = 8;
 #+END_SRC

 If ~the default function arguments~ are defined both in the function definition and in the declaration, this is a syntax error:
 #+BEGIN_SRC C++
   // Invalid.
   void f2(int x = 10);
   void f2(int x = 10)
   {
       //
   }

   // Valid.
   void f3(int x = 10);
   void f3(int x)
   {
       //
   }
 #+END_SRC
 
 If a function parameter does not take a ~default argument~, we can redeclare the function so that it takes a ~default argument~. This can, for example, allow us to pass ~default arguments~ to functions coming from external header files:
 #+BEGIN_SRC C++
   // external.h
   void func(int, int, int); // Function without any default arguments.

   // #include "external.h"
   void func(int, int, int = 10); // Valid.

   func(1, 5); // func(1, 5, 10);
 #+END_SRC
 
 The compiler takes the ~default arguments~ cumulatively:
 #+BEGIN_SRC C++
  // Invalid, because there are multiple definitions for the same parameter's default argument.
  void f1(int x = 10);
  void f1(int x = 10);

  // f2 does not take any default arguments. 
  void f2(int, int, int);
  // f2 takes a default argument for the 3rd parameter.
  void f2(int, int, int = 10);
  // f2 takes default arguments for the 2nd and 3rd parameters. This equals to void f2(int, int = 5, int = 10);
  // because the compiler takes the default arguments cumulatively.
  void f2(int, int = 5, int);

  f2(1) // f2(1, 5, 10);

  // f3 does not take any default arguments. 
  void f3(int, int, int);
  // Invalid. This is a different case, only last parameters can take default arguments.
  void f3(int, int = 5, int); 
 #+END_SRC

** Scoped enum / Enum class
 In addition to the ~traditional enum type~, C++ has a new enum type called ~scoped enum~ / ~enum class~. ~Scoped enum~ were introduced to overcome the disadvantages of the ~traditional enum type~.

*** Disadvantages of the traditional enum type
- ~Underlying type~ depends to the compiler. The compiler chooses ~int~ as default type but if ~int~ isn't big enough to store the ~enumeration constants~, the type choosen is compiler dependent. This is why ~traditional enum types~ cannot be used as ~incomplete types~. The compiler cannot know the size when used as an ~incomplete type~, because it may be larger than ~int~.
  #+BEGIN_SRC C++
    enum Color { Red, Green, Blue }; // Underlying type is int.
    enum MyEnum { Aa, Bb, Cc, Dd = 13024325325 }; // Underlying type is compiler dependent.
  #+END_SRC
- Implicit type conversion from ~traditional enum types~ to ~arithmetic types~ is allowed. Unfortunately, this can also lead to many problems.
  #+BEGIN_SRC C++
    enum Color { Red, Green, Blue };
    int x = Red; // Valid.
  #+END_SRC
- ~Enumeration constants~ don't have separate scope. This can cause name conflicts, especially with names from external header files.
  #+BEGIN_SRC C++
    // traffic.h
    enum TrafficLight { Red, Yellow, Green };
    // screen.h
    enum ScreenColor { Gray, White, Red };
  #+END_SRC

*** Advantages of the scoped enum type
 - The ~underlying type~ can be specified. If not specified ~int~ is default.
   #+BEGIN_SRC C++
     enum class Color : unsigned char { White, Black, Gray };
     enum Count : unsigned char { Zero, One, Two, Three }; // C++ also extended the traditional enum types, so that specifying underlying types is possible.
   #+END_SRC
 - No implicit type conversion from ~scoped enum types~ to ~arithmetic types~.
   #+BEGIN_SRC C++
     enum class Color : unsigned char { White, Black, Gray };
     Color color{ Color::Black };
     int x = color; // Invalid.
   #+END_SRC
 - ~Enumeration constants~ are no longer in the same scope with the ~enumeration type~. As the name indicates, they have a separate scope. This eliminates the name conflict problems.
   #+BEGIN_SRC C++
     enum class Color : unsigned char { White, Black, Gray };
     Color color1 = White; // Invalid.
     Color color2 = Color::White; // Valid.

     enum class TrafficLight { Red, Yellow, Green };
     enum class ScreenColor { Gray, White, Red };
     auto sc = ScreenColor::Red;
     auto tl = TrafficLight::Red;
   #+END_SRC

 In C++20, ~using enum declaration~ was added to the language. If we are sure that there is no name conflict, we can use ~using enum declaration~ to use ~enumeration constants~ without specifying them with a namespace.
 #+BEGIN_SRC C++
   enum class Color : unsigned char { White, Black, Gray };
   enum class Count : unsigned char { Zero, One, Two };

   void func()
   {
       // C++20, using enum declaration
       using enum Color;
       using enum Count::Zero;

       auto color1 = White; // Valid.
       auto color2 = Black; // Valid.

       auto count1 = Zero; // Valid.
       auto count2 = One; // Invalid.
   }
 #+END_SRC

** Type Cast Operators
 In C++, there 2 different type conversions: ~implicit type conversion~ and ~explicit type conversion~. In some cases the compiler is free to do ~implicit type conversion~ depending on the rules of the language, but if we want to explicity convert a type, we have to do ~explicit type conversion~ by using ~type cast operators~.

 There are 4-different type cast operators in C++ (excluding ~C-style cast~):
  - ~static_cast<target_type>(operand)~
     + Mostly used casting between different arithmetic and enumeration types, also can be used to cast from ~void*~ to another pointer type.
  - ~const_cast<target_type>(operand)~
     + Used for casting ~const T*~ to ~T*~.
  - ~reinterpret_cast<target_type>(operand)~
     + Used for casting between different pointer and reference types. Ex. ~int*~ to ~char*~.
  - ~dynamic_cast<target_type>(operand)~
     + This cast is about runtime polymorphism, can be used to cast from ~base class~ to ~derived class~.

 Example for ~static_cast~:
 #+BEGIN_SRC C++
   int x = 10;
   int y = 3;

   double dval = static_cast<double>(x) / y;
   int ival = static_cast<int>(dval);

   enum class Pos { off, on, hold };
   Pos pos = Pos::off;
   ival = static_cast<int>(pos);
 #+END_SRC

 Example for ~const_cast~:
 #+BEGIN_SRC C++
   char* mystrchr(const char* p, int c)
   {
       while (*p)
       {
	   if (*p == c)
	   {
	       return const_cast<char*>(p);
	   }
	   ++p;
       }

       if (c == '\0')
	   return const_cast<char*>(p);

       return nullptr;
   }
 #+END_SRC

 Example for ~reinterpret_cast~:
 #+BEGIN_SRC C++
   double dval = 451.2356;
   char* p = reinterpret_cast<char*>(&dval);

   for (std::size_t i{}; i < sizeof(double); ++i)
   {
       std::cout << p[i] << '\n';
   }
 #+END_SRC

Example for ~dynamic_cast~:
 Will be explained later.
 ...

*** Why C-style type cast is not enough?
 Different ~explicit type conversions~ can have different intentions and meanings. There can be many different reasons for converting one type to another type:
 - ~Explicit type conversion~ can be used to indicate that there will be data loss and that this is not a problem.
 - ~Explicit type conversion~ can be used to convert ~const T*~ to ~T*~, if we know the actual object is not a ~const~ object.
 - ~Explicit type conversion~ can be used to convert ~T*~ to ~char*~, to use the actual object as a char array.

 The list can be extended with different examples, but the point is that not every ~explicit type conversion~ has the same intention/meaning. The syntax of ~C-style type cast~ is very simple, but it is not sufficient to explain the intention of the conversion.

** Function Overloading
 In C++, multiple functions can have the same name but with different parameters. These functions can perform different tasks based on the parameters passed to them. The compiler differentiates between the overloaded functions by their number of parameters, types of parameters, and the order of parameters. When the compiler encounters a call to an overloaded function, it uses the argument types and number of arguments to determine which version of the overloaded function to invoke. This process, called ~static/early binding~ or ~compile-time polymorphism~, happens at compile-time, meaning the function to be executed is determined before the program runs. Function overloading is all about compile-time, it has no run-time overhead. For function overloading, there are 2 different and important points for the compiler to decide. Is there a function overloading for the particular function and if so, which function to choose. The process by the compiler to decide which function to choose is called ~function overload resolution~.

 To talk about function overloading, there are 3 different things to consider:
  - Function names have to be the same.
  - Function signatures have to be different.
  - Functions have to be in the same scope.
    + namespace scope
    + class scope
    + block scope

If one function is in ~namespace scope~ and the other is in ~block scope~, even if they have the same name, it will not cause function overloading. It causes ~name shadowing~ instead:
 #+BEGIN_SRC C++
   int foo(int);

   int main()
   {
       int foo(double);

       foo(5); // There is no funcion overloading. foo(double) will be called due to name shadowing.
   }
 #+END_SRC

 In order to do function overloading, functions must have different signatures. ~return~ type is not part of the signature:
 #+BEGIN_SRC C++
   int foo(int);
   double foo(int); // This is invalid, syntax error.
 #+END_SRC

 This is valid function overloading. Same function names, in the same scope and different signatures.
 #+BEGIN_SRC C++
   int foo(int);
   int foo(int, int);
 #+END_SRC

 ~Default function arguments~ do not effect ~function signature~. These functions still have different signatures and this is valid ~function overloading~. We don't talk about what happens when we call the function ~foo()~ with only one argument. It is about ~function overload resolution~.
 #+BEGIN_SRC C++
   int foo(int);
   int foo(int, int = 0);
 #+END_SRC

 If the parameter itself is ~const~ (~top-level const~) it doesn't effect ~function signature~. No ~function overloading~ here, it is ~function redeclaration~;
 #+BEGIN_SRC C++
   int foo(int);
   int foo(const int); // Valid, no overload. Function redeclaration.

   int func(double* const p);
   int func(double* p); // Valid, no overload. Function redeclaration
 #+END_SRC

 ~const T*~ is a different type than ~T*~. ~Low-level const~ changes ~function signature~. This is valid ~function overloading~ and mostly called ~const overload~:
 #+BEGIN_SRC C++
   int foo(int*);
   int foo(const int*);
 #+END_SRC

 ~const T&~ is a different type than ~T&~. This is valid ~function overloading~ and it is commonly used:
 #+BEGIN_SRC C++
   int foo(int&);
   int foo(const int&);
 #+END_SRC

 A Type alias doesn't mean a different type than the underlying type. No ~function oveloading~ here:
 #+BEGIN_SRC C++
   typedef double flt_type;

   void foo(double);
   void foo(flt_type); // Valid, no overload. Function redeclaration.
 #+END_SRC

 ~char~, ~unsigned char~ and ~signed char~ are 3 different distinct types. There are 3 ~function overload~ here:
 #+BEGIN_SRC C++
   void foo(char);
   void foo(signed char);
   void foo(unsigned char);
 #+END_SRC

 There are 3 ~function overloads~ here:
 #+BEGIN_SRC C++
   void foo(int*);
   void foo(int**);
   void foo(int***);
 #+END_SRC

 L-value reference and R-value reference. This is valid ~function overloading~:
 #+BEGIN_SRC C++
   void foo(int&);
   void foo(int&&);
 #+END_SRC

 There are 3 overloads:
 #+BEGIN_SRC C++
   void foo(int&);
   void foo(const int&);
   void foo(int&&);
 #+END_SRC

 We can't say there is ~function overload~ or not. This is ~implementation defined~, ~std::int32_t~ is not a distinct type but a type alias and underlying type is dependent to the compiler:
 #+BEGIN_SRC C++
   void foo(int);
   // If std::int32_t is alias to int. This is function redeclaration.
   // If std::int32_t is alias to long. This is valid function overload.
   void foo(std::int32_t);

   // This is valid function overload. std::int32_t and std::int16_t cannot be alias of the same type.
   void func(std::int32_t);
   void func(std::int16_t);
 #+END_SRC

 If array notation used in function declaration, array decay happens. There is no ~function overloading~ here:
 #+BEGIN_SRC C++
   void foo(int p[]); // Decays to foo(int*);
   void foo(int p[20]); // Decays to foo(int*); Function redeclaration.
   void foo(int* p); // foo(int*); Function redeclaration.
 #+END_SRC
 
 If a function takes function as a parameter. It decays to function pointer. No ~function overloading~ here:
 #+BEGIN_SRC C++
   void foo(int(int)); // Decays to foo(int (*)(int));
   void foo(int(*)(int)); // Function redeclaration.
 #+END_SRC

 There are 4 different ~function overloads~ here:
 #+BEGIN_SRC C++
   void foo(int (*)[5]); // int(*)[5]; a pointer to int[5]
   void foo(int (*)[6]); // int(*)[6]; a pointer to int[6]
   void foo(int (*)[7]); // int(*)[7]; a pointer to int[7]
   void foo(int (*)[8]); // int(*)[8]; a pointer to int[8]
 #+END_SRC
 
*** Function overload resolution
 ~Function overload resolution~ is handled by the compiler as a 3 step process. Actually, 3 steps is the maximum, it may take fewer steps:
 - Choosing ~candidate functions~.
   + In this step, the compiler doesn't check function arguments but marks the visible functions in the same scope which has the same name.
 - Choosing ~viable functions~.
   + The compiler checks each ~candidate function~ too see if it can be called with the arguments we passed it without syntax errors. If there are no syntax errors, the compiler marks that function. These marked functions are called ~viable functions~. After this step, all functions that are not suitable for calling are eliminated and only those functions that can be called legally remain.
   + In this step, the compiler determines the ~viable functions~ depending on passed arguments. The number of arguments, the types of arguments, the default function arguments and the implicit conversion rules between types all are very important in this step.
   + More than one function overload does not guarantee that a call with this name is valid. None of the function overloads may be ~viable functions~, this is called ~no match~. 
 - Choosing the ~best viable function~.
   + If there are more than one ~viable function~, the compiler will decide which one is the ~best match~ based on the rules of the language.
   + There may be more than one ~viable function~ among which the compiler cannot decide which one to choose, because there are no selection criteria in terms of the rules of the language, this is called ~ambiguity~.

 Rules for choosing the ~best viable function~ / ~best match~:
  - ~variadic conversion~ always loses if there are any other alternatives.
  - ~user-defined conversion~ always loses except when the alternative is ~variadic conversion~.
    + If there are more than one ~viable function~ with ~user-defined conversion~, this might cause an ~ambiguity~ error, if there is no better alternative (~standard converion~).
  - ~standard/implicit conversion~ always wins except when the other alternatives are also ~standart conversion~. There are different rules for this case.
    + ~exact match~ always wins over ~promotion~.
      * When the function parameters and the arguments are the same.
      * ~implicit conversion~ from ~T*~ to ~const T*~.
      * ~array to pointer conversion~ / ~Array decay~.
      * ~function to pointer conversion~.
    + ~promotion~ always wins over ~conversion~.
      * ~integral promotion~ (types which have lower rank than ~int~ are promoted to ~int~),
      * ~float to double promotion~
    + ~conversion~ always wins over ~user-defined conversion~.
      * ~conversion~ between different types which is not ~promotion~. (~char~ to ~double~, ~double~ to ~int~ etc.)

 Functions with multiple parameters can also be overloaded. In this case, one of the ~function overloads~ must be win over to the others in at least one parameter and must be at least equal (shouldn't be weaker) in the other parameters.

 From weaker ~viable function~ to stronger:
  ~variadic conversion~ < ~user-defined conversion~ < ~standard conversion~ < ~standard promotion~ < ~exact match~

 #+BEGIN_SRC C++
   void f(int);
   void f(double);
   void f(long);

   f(3.4); // f(double) will be called, exact match.
   f(12); // f(int) will be called, exact match.
   f(12u); // unsigned int can be converted to int, double and long. Three different standard conversion causes ambiguity.
   f(true); // f(int) will be called, bool to int is integral promotion and promotion wins over conversion.
   f(2.3L); // long double can be converted to int, double and long. Three different standard conversion causes ambiguity.
   f(2.3f); // f(double) will be called, float to double promotion.
   f('A'); // f(int) will be called, integral promotion from char to int.
 #+END_SRC

 If one of the ~viable functions~ takes ~T*~ and the other one takes ~const T*~, this is called ~const overloading~ and means both of them are ~exact match~. If the argument type is ~const T*~, ~const T*~ will be called, otherwise ~T*~ will be called. This is also valid for references.
 #+BEGIN_SRC C++
   void f1(int*);
   void f1(const int*);
   void f2(int&);
   void f2(const int&);

   const int cx = 5;
   int x = 5;

   f1(&cx); // f1(const int*) will be called.
   f1(&x); // f1(int*) will be called.

   f2(&cx); // f2(const int&) will be called.
   f2(&x); // f2(int&) will be called.
 #+END_SRC

 Default function arguments can cause ~ambiguity~:
 #+BEGIN_SRC C++
   void func(int x, int y = 0);
   void func(int x);

   func(12); // There are 2 valid oveloads of func but the compiler cannot decide between them. Ambiguity error.
 #+END_SRC

 Having 2 different ~function overloads~ for ~call by value~ and ~call by reference~ can cause ~ambiguity~:
 #+BEGIN_SRC C++
   void f1(int& x);
   void f1(int x);

   void f2(const int& x);
   void f2(int x);

   int x = 10;

   f1(x); // Invalid, ambigious call.
   f1(10); // Valid, func(x) will be called.
   f2(x); // Invalid, ambigious call.
   f2(10); // Invalid, ambigious call.
 #+END_SRC

 Using C-style null pointer can cause ~ambiguity~:
 #+BEGIN_SRC C++
   void func(double*);
   void func(int);

   // Let's say the intention was to call func(double*) with null pointer and then we added a new overload func(int). This code will not give any error and call to func(int), because it will be exact match. If we really want to call func(double*) with null pointer we should use nullptr.
   func(0); // Valid, func(int) will be called.
   func(nullptr); // Valid, func(double*) will be called.
 #+END_SRC

 We can choose the overload we want to call by using ~explicit cast~. We can also use ~name shadowing~ to call the function we want by ~redeclaring~ it in the current scope.
 #+BEGIN_SRC C++
   void func(int);
   void func(double);
   void func(long);

   int main()
   {
       int x = 10;

       func(static_cast<double>(x)); // func(double) will be called.

	// This function redeclaration causes name shadowing. From this point on, every call to func in this scope will be call to func(long).
       void func(long);

       func(x); // func(long) will be called.
       func(2.3); // func(long) will be called.
   }
 #+END_SRC

 When one of the overloads is ~bool~ and the other is ~void*~, this should normally cause ~ambiguity~ when called with pointer types, but this is an exception and the ~void*~ one will be called:
 #+BEGIN_SRC C++
   void func(bool);
   void func(void*);

   int x{};

   // Implicit conversion from int* to bool and from int* to void* exist. Normally, this should cause ambiguity but this is a special case and func(void*) will be called.
   func(&x);
 #+END_SRC

 We can call ~L-value reference~ overloads with ~L-value expressions~, and ~R-value reference~ overloads with ~R-value expressions~. Normally, ~const L-value reference~ and ~R-value reference~ both can be called with ~R-value expressions~ but this doesn't cause ~ambiguity~. The function which takes an ~R-value reference~ will be called in this case:
 #+BEGIN_SRC C++
     void f1(int&);
     void f1(int&&);

     void f2(const int&);
     void f2(int&&);

     int x{};

     f1(10); // Valid, 10 is R-value expression, f1(int&&) will be called.
     f1(x); // Valid, x is L-value expression, f1(int&) will be called.

     f2(x); // Valid, x is L-value expression, f2(const int&) will be called.
     // Valid, 10 is R-value expression, normally f2(const int&) and f2(int&&) both
     // can be called with a R-value expression but this does not cause ambiguity. f2(int&&) will be called.
     f2(10);
 #+END_SRC

 ~Data type~ (~declaration type~) and ~value category~ are not the same thing. Variables/declarations don't have a ~value category~ but ~data type~, we need to have an ~expression~ to talk about ~value category~. We can observe it in this example:
 #+BEGIN_SRC C++
   #include <iostream>

   void bar(int& x)
   {
       std::cout << 3;
   }

   void bar(int&& x)
   {
       std::cout << 4;
   }

   void func(int& x)
   {
       std::cout << 1;
       bar(x);
   }

   void func(int&& x)
   {
       std::cout << 2;
       // The data/declaration type of x is int&& but the value category of x when used in an expression is L-value
       // so bar(int&) will be called.
       bar(x);
   }

   int main()
   {
       int x = 10;

       func(x); // Output: 13
       func(10); // Output: 23
   }
 #+END_SRC

 We were always using one paramater for ~function oveloads~, but functions with multiple parameters can also be overloaded. In this case, one of the ~function overloads~ must win over to the others in at least one parameter and must be at least equal in the other parameters.
 #+BEGIN_SRC C++
   void f1(int, double, long); // 1
   void f1(char, int, double); // 2
   void f1(long, unsigned int, float); // 3

   // Function 1 will be chosen. The 1st parameter of function 1 wins over the 1st parameter of function 2 and 3, because it is exact match. 2nd and 3rd parameter is equal for functions 1, 2 and 3, because all of them are standart conversion.
   f(12, 4L, 1);
   // Function 2 will be chosen. The 2nd parameter of function 2 wins over the 2nd parameter of function 1 and 3, because it is standard promotion. 1st and 3rd parameter is equal for functions 1, 2 and 3, because all of them are standart conversion.
   f(2.3, true, 12);
   // Function 3 will be chosen. The 1st parameter of function 3 wins over the 1st parameter of function 1 and 2, because it is exact match. 2nd and 3rd parameter is equal for functions 1, 2 and 3, because all of them are standart conversion.
   f(34L, 3.5L, 12);
   // This causes ambiguity. The 1st parameter of function 1 has exact match, but the 2nd parameter of the function 2 also has exact match. The 3rd parameters have standard conversion. There are 2 exact matches for different function overloads, in this case the compiler cannot decide. One of the overloads must win over others at least on one parameter, and at least be equal on the other parameters.
   f(12, 12, 12);
 #+END_SRC

** Name Mangling
 ~Name mangling~ is a process used by C++ compilers to generate unique names for functions, variables, and other entities to support features like ~function overloading~, ~namespaces~, and ~template instantiation~. Since C++ allows multiple functions with the same name (through ~function overloading~), the compiler needs a way to differentiate between these functions at the binary level. ~Name mangling~ achieves this by encoding additional information, such as the function's ~parameter types~, ~return type~, and the ~namespace~ or ~class~ it belongs to, into the function's name. 

 ~Name mangling~ can cause some problems when we call a C function from a C++ source. An example of a problem caused by ~name mangling~:
 #+BEGIN_SRC C++
   // test.h
   int func(int);

   // test.c
   int func(int x)
   {
       return x + 1;
   }

   // main.cpp
   #include "test.h"

   int main()
   {
       // This code will be built successfully but will not be linked. The
       // linker program will not find func(int) because the C++ compiler
       // will produce a mangled/decorated name for func(int), but it is a
       // C function. The name produced by the C compiler will not match
       // the name produced by the C++ compiler, because there is no name
       // mangling in C.
       auto x = func(20);
   }
 #+END_SRC

 To solve this kind of problems we typically use ~extern "C"~ declaration with ~conditional compiling~. By doing this we can use the same ~header file~ for both C and C++.

 #+BEGIN_SRC C++
   // test.h
   #ifdef __cplusplus
   extern "C" { // open extern "C" block.
   #endif

   int func(int);

   #ifdef __cplusplus
   } // close extern "C" block.
   #endif

   // test.c
   int func(int x)
   {
       return x + 1;
   }

   // main.cpp
   #include "test.h"

   int main()
   {
       // This code will be built and linked successfully. The
       // compiler won't generate mangled names for func(int)
       // because its declaration is inside of an extern "C" block.
       auto x = func(20);
   }
 #+END_SRC

** One Definition Rule (ODR)
 Objects (variables, functions, templates, classes etc.) in C++ can have multiple declarations but only one definition across the project. This is called ~one definition rule~. If a program has more than one definition of a particular object, the program is ~ill-formed~ and the compiler isn't required to give any diagnostics. The linker program may give some diagnostics but it is also not guaranteed. If the same object has multiple definitions in the same source file, it is a syntax error and diagnostic is required.

 Some examples:
 #+BEGIN_SRC C++
   // test.h
   int x = 10;

   // If test.h is to be included from multiple source files, this is against the ODR because variable x will have multiple definitions.
 #+END_SRC

#+BEGIN_SRC C++
  // test.h
  void func()
  {
  }
  // If test.h is to be included from multiple source files, this is against the ODR because func() will have multiple definitions.
 #+END_SRC

 When an ~inline function~ in a ~header file~ is included from multiple source files, this isn't against the ~ODR~ and but every source file will have its own definition for that particular function.
 #+BEGIN_SRC C++
  // test.h
  static void func()
  {
  }
  // If test.h is to be included from multiple source files, this is not against the ODR because func() will be in internal linkage. Every source file will have its own func().
 #+END_SRC

 There are such objects that can have more than one definition in different source files but do not violate the ~ODR~, but their definitions must be the same ~token-by-token~. This is very important because in practice it means that the definitions of these objects can be in ~header files~.
 Definitions that can coexist in different source files without violating ODR:
  - ~class definitions~
  - ~inline function definitions~
  - ~inline variable definitions~ (C++17)
  - ~constexpr functions~
  - ~constexpr variables~
  - ~class templates~
  - ~function templates~

** Inline functions
 Functions defined with the ~inline~ keyword are called ~inline functions~, meaning that they will not violate the ~ODR~. This means we can define ~inline functions~ in ~header files~. ~inline functions~ are not directly related with the ~inline expansion~. ~inline expansion~ is an old and effective optimization method often used by compilers. In a nutshell, this means that instead of calling a function, the compiler embeds the code for that function directly into the source code, depending on the different parameters. The main purpose of defining an ~inline function~ using the ~inline~ keyword is not to allow the compiler to do ~inline expansion~ but to avoid violating ~ODR~. Unless a special compiler flag is used, it is up to the compiler to decide whether to do ~inline expansion~ or not.

 When an ~inline function~ in a ~header file~ is included from multiple source files, this is not against the ~ODR~ and there will be only one definition from the compiler perspective even it is included in multiple source files unlike ~static~ functions.
 
 #+BEGIN_SRC C++
  // test.h
  inline void func()
  {
  }
  // If test.h is to be included from multiple source files, this is not against the ODR. There will be only one func() even it is included in multiple source files.
 #+END_SRC

** Inline variables 
 Variables defined with the ~inline~ keyword are called ~inline variables~, meaning that they will not violate the ~ODR~ similar to ~inline functions~. ~Inline variables~ were added in C++17. When an ~inline variable~ in a ~header file~ is included from multiple source files, this is not against the ~ODR~ and there will be only one definition from the compiler perspective even it is included in multiple source files.

 #+BEGIN_SRC C++
   // test.h
   inline int x = 10;
   // If test.h is to be included from multiple source files, this is not against the ODR. There will be only one x even it is included in multiple source files.
 #+END_SRC

** constexpr

cpp009 - where we left - 00:49:00
