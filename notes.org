#+TITLE: C++ Notes
#+AUTHOR: nukoseer
#+OPTIONS: num:nil
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+HTML_HEAD_EXTRA: <style> pre.src { background-color: black; color: white; font-size: 14px; }</style>

* Fundemental Differences Between C and C++
 Main purpose of this section is to point out the differences between C and C++. It isn't about how code should or should not be written in C or C++. It is only about validity of the code.
** Syntax Differences
*** Implicit int
 If a function does not have a return type:
 - In C, it is allowed and compilers assume it returns ~int~. It is also allowed in function declarations.
 - In C++, it is syntax error.
 This code is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   func(int x)
   {
       return x + 1;
   }
 #+END_SRC

*** Missing return statement in functions with non-void return type
 If a function has return type but does not return anything:
 - In C, it is allowed. Compilers can show a warning but they don't have to.
 - In C++, it is syntax error.
 This code is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   int func() {}
 #+END_SRC

*** Implicit/default function declaration
 If name lookup fails for a function:
 - In C, compilers will assume it is an external function with the default declaration: ~int func();~
 - In C++, it is syntax error.
 This code will compile in C and compiler will assume ~bar()~ function has ~int bar();~ declaration:
 #+BEGIN_SRC C++
   void foo()
   {
       bar();
   }
 #+END_SRC

*** Declaration of functions without parameter
 There are different rules for C and C++.
  #+BEGIN_SRC C++
    int foo();
    int bar(void);
  #+END_SRC
  - In C, these 2 function declarations have different meaning.
   + ~int foo();~ means, we don't have any information about parameters so we can pass what ever we want.
   + ~int bar(void);~ means, function does not take any parameters.
  - In C++, both of the declarations have the same meaning. Functions do not take any parameters.
  According to the declarations above, this code is valid in C. Invalid in C++, because ~int foo();~ does not take any parameters.
  #+BEGIN_SRC C++
    foo(1, 2);
  #+END_SRC

*** Nameless parameters in function definitions
 This is about function definitions not declarations.
  - In C, it is not allowed. (Since C20, it is also allowed in C.)
  - In C++, it is allowed.
  This code is invalid for C (before C20) and valid for C++:
  #+BEGIN_SRC C++
    void func(int) {}
  #+END_SRC

*** Scope of for-statement
 - In C, inside of the for loop has a different block scope than for-statement itself.
 - In C++, inside of the for loop and for-statement itself are in same block scope.
 Because of this difference, name shadowing inside a for loop is valid in C, but invalid in C++:
 #+BEGIN_SRC C++
   for (int i = 0; i < 10; ++i)
   {
       int i = 99;
   }
 #+END_SRC
 We can say above code looks like this for C compiler:
 #+BEGIN_SRC C++
   for (int i = 0; i < 10; ++i)
   {
       {
	   int i = 99;
       }
   }
 #+END_SRC
 /Note: For C and C++, name shadowing is only valid between different scopes./

** Differences About Types and Type Conversions
*** Logic data type (boolean)
 In C:
 - ~int~ is used instead of logic data type.
 - ~_Bool~ type is added in C99, but it is not widely used.
 - C doesn't have ~false~, ~true~ constants. ~stdbool.h~ defines macros for them.

 In C++:
 - ~bool~ type, ~false~ and ~true~ constants are build-in to the language. No need to include anything.
 - Implicit type conversion from arithmetic types and pointer types to ~bool~ is allowed.
 - Implicit type conversion from ~bool~ to arithmetic types is allowed.
 These are valid in C++:
 #+BEGIN_SRC C++
   // Implicit conversion from arithmetic types to bool
   int x = 45;
   bool b1 = x;

   double y = 33.11;
   bool b2 = y;

   // Implicit conversion from pointer types to bool
   int z = 100;
   int* p = &z;
   bool b3 = p;

   // Implicit conversion from bool to arithmetic types
   bool b4 = true;
   int t = b4;
 #+END_SRC

 But, this is invalid:
 #+BEGIN_SRC C++
   // No implicit conversion from bool to pointer types
   bool b5 = false;
   int* ptr = b5;
 #+END_SRC

*** User defined types
 - In C, ~struct~, ~enum~ and ~union~ tags don't represent type itself. A keyword (~struct~, ~enum~ or ~union~) must be used before a tag name to represent a type. A ~typedef~ declaration can be used too.
 - In C++, tag names directly represent type names.
 Here are some examples:
 #+BEGIN_SRC C++
   struct Data
   {
       int a, b, c;
   };

   // Invalid in C. Valid in C++. There is no need to use struct keyword or typedef declaration in C++.
   Data data0;

   // Valid in C and C++.
   struct Data data1;

   typedef struct Example
   {
       int a, b, c;
   } Example;

   // Valid in C and C++.
   Example example0;
 #+END_SRC

*** Empty structs
 - In C, empty structs are invalid.
 - In C++, empty structs are valid.
 An example:
 #+BEGIN_SRC C++
   struct Data
   {
   };
 #+END_SRC

*** Implicit conversion from arithmetic types to pointer types
 - In C, implicit conversion from arithmetic types to pointer types is allowed. Compilers might show a warning.
 - In C++, there is no implicit conversion from arithmetic types to pointer types.
 This is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   int x = 20;
   int* p = x;
 #+END_SRC

*** Implicit conversion between different pointer types.
 - In C, implicit conversion between different pointer is allowed. Compilers might show a warning.
 - In C++, there is no implicit conversion between different pointer types.
 This is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   double d = 33.11;
   char* ptr = &d;
 #+END_SRC

*** Implicit conversion from ~void*~ to ~T*~
 - In C, implicit conversion from ~void*~ to ~T*~ is allowed.
 - In C++, implicit conversion from ~void*~ to ~T*~ is not allowed.
 This code is valid in C but invalid in C++:
 #+BEGIN_SRC C++
  int* p = malloc(1000 * sizeof(int));
 #+END_SRC

*** Underlying enumeration type
 - In C, underlying enumeration type has to be ~int~.
 - In C++, it does not have to be ~int~ and can be specified with special syntax.

*** Implicit conversion from arithmetic types to enumeration types
 - In C, it is allowed.
 - In C++, it is not.
 This code is valid in C but invalid in C++:
 #+BEGIN_SRC C++
   enum Color { Red, Green, Blue };
   enum Color color;
   color = 3;
 #+END_SRC

*** Implicit conversion between different enumeration types
 - In C, it is allowed.
 - In C++, it is not.
 This code is valid in C but invalid in C++:
 #+BEGIN_SRC C++
   enum Color { Red, Green, Blue };
   enum Count { Zero, One, Two };
   enum Color color = Red;
   enum Count count = Zero;
   color = count;
 #+END_SRC

*** Implicit conversion from enumeration types to arithmetic types.
 - In C, it is allowed.
 - In C++, it is also allowed. Scoped enums can be used to prevent this.
 This code is valid in C and C++:
 #+BEGIN_SRC C++
   enum Color { Red, Green, Blue };
   enum Color color = Red;
   int x = color;
 #+END_SRC

*** Character literals
 - In C, character literals are ~int~.
 - In C++, character literals are ~char~.
 This code prints 4 in C and 1 in C++:
 #+BEGIN_SRC C++
   printf("%zu\n", sizeof('A'));
 #+END_SRC

*** String literals
 - In C, the type of string literals is ~char[n]~. When string literals are used in an expression they are converted to address of the first element (array decay - array to pointer conversion). The type after array decay is ~char*~.
 - In C++, the type of string literals is ~const char[n]~. Array decay also applies to C++ but the type after array decay is ~const char*~.
 This string literal is ~char[8]~ in C and ~const char[8]~ in C++:
 #+BEGIN_SRC C++
   "example"
 #+END_SRC
 This is valid in C but invalid in C++:
 #+BEGIN_SRC C++
   // In C++, it is decayed to const char* and there is no implicit conversion from const T* to T*.
   char* s = "example";
 #+END_SRC
 
** Differences About const Keyword
*** Initialization of const objects
 - In C, ~const~ objects don't have to be initialized.
 - In C++, ~const~ objects have to be initialized.
 This is code is valid in C and invalid in C++:
 #+BEGIN_SRC C++
  const int x;
 #+END_SRC
 Might be a bit tricky to understand at first but this is also valid in C++:
 #+BEGIN_SRC C++
   // This is a pointer to const int. Object/variable itself is not const here it just points to const int
   const int* ptr;
 #+END_SRC
 But this is invalid:
 #+BEGIN_SRC C++
   // This is a const pointer to int. Object/variable itself is const
   int* const ptr;
 #+END_SRC

*** Const expressions
 - In C, expressions generated by const variables are not counted as const expressions.
 - In C++, they count as const expressions.
 This is invalid in C (assuming no VLA) but valid in C++:
 #+BEGIN_SRC C++
   const int x = 10;
   int arr[x] = { 0 };
 #+END_SRC

*** Global const objects and linkage
 - In C, global const objects are in external linkage.
 - In C++, global const objects are in internal linkage like ~static~ objects.
 ~x~ is in external linkage in C and internal linkage in C++:
 #+BEGIN_SRC C++
   // In global scope
   const int x = 10;
 #+END_SRC

*** Implicit conversion from ~const T*~ to ~T*~
 - In C, implicit conversion from ~const T*~ to ~T*~ is allowed. Compilers might show a warning.
 - In C++, there is no implicit conversion from ~const T*~ to ~T*~.
 This is valid in C and invalid in C++:
 #+BEGIN_SRC C++
   const int x = 10;
   int* p = &x;
 #+END_SRC

** Differences About Value Categories
*** Primary value categories
 - In C, there are 2 primary value categories.
   + L-value
   + R-value
 - In C++, there are 3 primary value categories.
   + L-value
   + PR-value (pure R-value)
   + X-value (expired value)
 The combination of the ~PR-value~ and ~X-value~ categories is called the ~R-value~ category. (~PR-value~ \cup ~X-value~ = ~R-value~). When we say an expression is ~R-value~ it means it may be an ~PR-value~ or ~X-value~ in C++.
 
 The combination of the ~L-value~ and ~X-value~ categories is called the ~GL-value~ category. (~L-value~ \cup ~X-value~ = ~GL-value~). When we say an expression is ~GL-value~ it means it may be an ~L-value~ or ~X-value~ in C++.
 
 The ~GL-value~ and ~R-value~ categories are not ~primary value categories~. They are called ~combined value categories~.
 
*** Prefix increment/decrement operator
 - In C, expressions generated by prefix increment/decrement operator are R-value expressions.
 - In C++, they are L-value expressions.
 This code is valid in C++ and invalid in C:
 #+BEGIN_SRC C++
   int x = 10;
   // These are invalid in C, because R-value expressions cannot be an operand of the address(&) operator.
   &++x;
   &--x;
 #+END_SRC

*** Assignment operator
 - In C, expressions generated by assignment operator are R-value expressions.
 - In C++, they are L-value expressions.
 This code is valid in C++ and invalid in C:
 #+BEGIN_SRC C++
   int x = 10;
   &(x = 5);
 #+END_SRC

*** Comma operator
 - In C, expressions generated by comma operator are R-value expressions.
 - In C++, they can be L-value or R-value expressions.
 This code is valid in C++ and invalid in C:
 #+BEGIN_SRC C++
   int x = 10;
   int y = 20;
   (x, y) = 30; // y = 30;
 #+END_SRC

*** Ternary operator
 - In C, expressions generated by ternary operator are R-value expressions.
 - In C++, they can be L-value or R-value expressions.
 This code is valid in C++ and invalid in C:
 #+BEGIN_SRC C++
   int x = 10;
   int y = 20;
   int z = 30;
   (x == 10 ? y : z) = 40; // y = 40;
 #+END_SRC

* C++ Topics

** Initialization
 There are very different ways to initialize objects in C++.
*** Default initialization
 Default initialized objects are created with a garbage value.
 #+BEGIN_SRC C++
   int x; // Default initialization.
 #+END_SRC

*** Zero initialization
 Compilers zero initialize objects in the global scope. ~zero initialization~ is not a way to initialize objects it is more like a compiler process.
 #+BEGIN_SRC C++
   // Global scope
   int x;  // x = 0;
   bool b; // b = false;
   int* p; // p = nullptr;
 #+END_SRC

*** Copy initialization
 If objects are initialized like in the C language, it is called ~copy initialization~.
 #+BEGIN_SRC C++
   int x = 10; // Copy initialization.
 #+END_SRC

*** Direct initialization
 If objects are initialized by using paranthesis, it is called ~direct initialization~.
 #+BEGIN_SRC C++
   int x(98); // Direct initialization.
 #+END_SRC

*** Direct-list / brace initialization (uniform initialization)
 If objects are initialized by using braces, it is called ~direct-list initialization~. ~direct-list/brace initialization~ is added to the language to have a uniform way to initialize objects. This is why it is also called ~uniform initialization~. It can be used to initialize any object.
 #+BEGIN_SRC C++
  int x{ 10 }; // Direct-list initialization.
 #+END_SRC

 Unlike other initialization methods, if an implicit narrowing conversion occurs during ~direct-list initialization~, it is a syntax error.
 #+BEGIN_SRC C++
   double dval = 5.6;

   // Implicit narrowing conversion does not cause any error but compilers might show a warning.
   int i1 = dval;
   int i2(dval);

   // Invalid. Implicit narrowing conversion causes a syntax error. Explicit cast is needed.
   int i3{dval};
 #+END_SRC

 In C++, there are such declarations that can be interpreted as both ~object instantiation~ and ~function declaration~ at the same time. In such cases, ~function declaration~ has the priority. This is called ~most vexing parse~ and sometimes it leads to problems.
 Example:
 #+BEGIN_SRC C++
   struct A
   {
   };

   struct B
   {
       B(A);
   };

   // Here, we wanted to create a bx object from class B type by calling its constructor with a temporary object with class A type.
   // C++ understands this as a function declaration. It is a function named bx and it has a return type of class B,
   // and takes a function pointer as a parameter. Sigh..
   B bx(A());

   // This can be prevented by using direct-list initialization.
   B by{A()};
   B bz(A{});
 #+END_SRC

*** Value initialization
 If objects are initialized by using braces but inside of the braces are empty, it is called ~value initialization~. Value initialized objects are first initialized to zero, if any additional initialization steps are required, this is done after ~zero initialization~.
 #+BEGIN_SRC C++
   int x{}; // Value initialization.
 #+END_SRC

** nullptr
 In C++, there is a keyword that represents a null pointer, and it is called ~nullptr~. It is not a macro like in C. It is a keyword, a constant and its type is ~nullptr_t~.

 You can assign ~nullptr~ to other pointer types but there is no implicit conversion from ~nullptr_t~ type to arithmetic types.
 #+BEGIN_SRC C++
   // Invalid
   int x = nullptr;

   // Valid
   int* y = nullptr;
   double* z = nullptr;
 #+END_SRC

** Reference Semantics
 There is an alternative way to represent pointers in C++, which is called ~reference~, but this is only an alternative at the language layer, the underlying representation does not change once the code is compiled. Everything works with the pointers in assembly level.

 There are 3 different reference categories:
  - L-value reference
  - R-value reference (move semantics, perfect forwarding (generic prog.))
  - Forwarding/universal reference
  An example:
  #+BEGIN_SRC C++
    int x = 10;
    // L-value reference
    int& y = x;
    // R-value reference
    int&& z = 10;
    // Forwarding/universal reference
    auto&& t = 10;
  #+END_SRC

*** L-value references
  L-value references are similar to ~top-level const pointer objects~:
  #+BEGIN_SRC C++
    int x = 10;

    // We cannot change the value of the ptr because it is a const pointer. It will always point to the same object
    // which is x in this case. Whenever *ptr is used, it means x.
    int* const ptr = &x;
    int y = *ptr; // int y = x;
  #+END_SRC

  L-value references represent their underlying object directly, there is no need for dereferencing like pointers. They cannot be default initialized, cannot be initialized with R-value objects and cannot be reassigned/rebound(like ~top-level const pointer~).
  #+BEGIN_SRC C++
       int x = 10;

       // Reference r directly represents x
       int& r = x;
       // No need to dereference like a pointer
       int y = r; // int y = x;

       int& r1; // Syntax error. References cannot be default initialized.
       int& r2 = 10; // Syntax error. References cannot be initialized with R-value objects.

       int z = 10;
       int t = 20;
       int& r3 = z;

       // This is valid but equals to z = t. r3 still represents z, what we did is changing value of z.
       // References cannot be reassigned.
       r3 = t; 
  #+END_SRC

 We can say that when we define a L-value reference we bind it to underlying object and they will stay bound until the end of scope.
  #+BEGIN_SRC C++
    int x = 10;
    // All r1, r2 and r3 bound to x
    int& r1 = x;
    int& r2 = r1;
    int& r3 = r2;

    ++r1;
    ++r2;
    ++r3;
    // x is 13 here

  #+END_SRC

 L-value rereferences can also be bound to arrays and array decay rules do not change:
  #+BEGIN_SRC C++
    int a[] = { 1, 3, 5, 7, 9 };
    // r is bound to a
    int (&ra)[] = a; // Normally, we do not have to write the type directly. we can use type deduction.

    for (int i = 0; i < 5; ++i)
    {
       // ra[i] equals to a[i]
    }

    // Same rules apply for array decay
    int* p1 = a;
    int* p2 = ra;
  #+END_SRC

  L-value references often used to pass the object to the function (~call by reference~) and also to return the object itself from the function.
  #+BEGIN_SRC C++
    int& foo(int& r)
    {
	++r;
	return r;
    }

    int x = 10;

    // Value of x will be 11 after foo() is called
    // r represents x
    int& r = foo(x);
  #+END_SRC 
   
*** L-value references and const semantics
 We said that L-value references are like ~top-level const pointer~ by default but they can also be used like ~low-level const pointer~.
 Pointer parameters can be used as a mutator or accessor. L-value references also can be used in a similar way:
  #+BEGIN_SRC C++
    void f1(int* p); // Mutator
    void f2(const int* p); // Accessor

    void f3(int& r); // Mutator
    void f4(const int& r); // Accessor
  #+END_SRC 

  ~const~ objects can only be bound by ~const~ L-value references similar to pointers:
  #+BEGIN_SRC C++
    const int x = 10;
    int* p = &x; // Invalid. int* p cannot point to const int x.
    int& r = x; // Also invalid. int& r cannot bind to const int x.

    const int& cr = x; // Valid.
  #+END_SRC 

 Normally, initializing an L-value reference with a different/mismatching object type is syntax error:
  #+BEGIN_SRC C++
    int x = 10;
    double& r = x; // Syntax error. double& r cannot bind to int object.
  #+END_SRC

  But, if we try to initialize a ~const~ L-value reference with a different/mismatching object type and there is an implicit conversion from that object type to the type represented by the ~const~ L-value reference, the compiler creates a temporary object and the ~const~ L-value reference is bound to that temporary object:
  #+BEGIN_SRC C++
    int x = 10;
    // This is valid. Normally, double and int types do not match but implicit conversion is allowed from int to double.
    // So, compiler creates a temporary double object and assign x to it, then cr binds to that temporary object.
    const double& cr = x; 

    // We can think that compiler generates something like this for above code.
    // double temporary_object = x;
    // const double& cr = temporary_object;
  #+END_SRC

 This also applies, when we try to initialize ~const~ L-value references with R-value objects:
  #+BEGIN_SRC C++
     // This is syntax error. L-value references cannot be initialized with R-value objects.
    int& r = 10;

    // This is valid when we use const L-value reference, because compiler creates a temporary object like the example above.
    const int& cr = 10;

    // Compiler might generate something like this for above code.
    // int temporary_object = 10;
    // const int& cr = temporary_object;
  #+END_SRC

  This becomes even more important when we call functions that take L-value reference parameters, for example:
   #+BEGIN_SRC C++
     // We can only pass an L-value objects to f1(). If we try to pass a R-value object it will be syntax error.
     void f1(int& x);
     int x = 10;
     f1(x); // Valid.
     f2(10); // Invalid, syntax error.

     // It is not the same for f2() however. We can pass L-value objects to f2() but if we try to pass a R-value object, it will not cause
     // any syntax error because of the rules above. The temporary object will be passed to f2() instead of R-value object itself. (Assuming there is no type problem)
     void f2(const int& x);
     int y = 10;
     f2(y); // Valid.
     f2(10); // Also valid.
   #+END_SRC

*** Differences between pointers and L-value references
| Pointers                       | References                                                           |
|--------------------------------+----------------------------------------------------------------------|
| don't have to be initialized   | have to be initialized                                               |
| pointer to pointer exists      | reference to reference doesn't exist (ignoring reference collapsing) |
| arrays can store pointers      | arrays cannot store references                                       |
| pointers can be null (nullptr) | references cannot be null                                            |
| pointers can be reassigned     | references cannot be reassigned                                      |

*** R-value references
 R-value references are mostly about move semantics and perfect forwarding. Details will be discussed in the future. We will just briefly explain the syntax for now.
 R-value references cannot be default-initialized like L-value references, and can be initialized only with R-value objects.
  #+BEGIN_SRC C++
    int&& r = 10; // Valid, R-value reference.

    int x = 10;
    int&& rr = x; // Invalid. R-value references cannot be initialized with L-value objects.
  #+END_SRC

  ...
  
** Type Deduction
 In C++, we don't need to write the type explicitly in some contexts. We can use one of the type deduction mechanisms to have the compiler determine the type for us by looking at the code.
 There are several different mechanisms for type deduction:
  - auto
  - decltype
  - decltyoe(auto)
  - template

*** auto type deduction
 The ~auto~ keyword can be used to determine the type of the variable during initialization. A very important point is that the type deduction is made for ~auto~ keyword not for the variable itself.
 #+BEGIN_SRC C++
   auto x = 10; // int x = 10;

   int y = 45;
   auto z = y; // int z = y;

   auto t = 0U; // unsigned int t = 0U;
   auto k = 0.; // double k = 0.;

   char c = 'a';
   auto a = c; // char a = c;
   auto b = +c; // int b = +c;

   auto d = 10 > 5; // bool d = 10 > 5;
 #+END_SRC

 We cannot ~default initialize~ an object with ~auto~ because in this case the compiler cannot determine its type:
 #+BEGIN_SRC C++
   auto x; // Invalid.
 #+END_SRC

 If an object is ~auto~ initialized with a ~const~ object and does not have any declarator (such as *, &), ~const~ qualifier drops:
 #+BEGIN_SRC C++
   const int cx = 6;
   // This equals to int y = cx;. const qualifier drops.
   auto y = cx;

   int* const ptr = 0;
   // ptr is const pointer to int. If the object itself is const, const qualifier drops.
   auto p = ptr; // int* p = ptr;

   const int* ptr1 = 0;
   // ptr1 is pointer to const int. The object itself is not const, const qualifier does not drop in this case.
   auto p1 = ptr1; // const int* p1 = ptr1;
 #+END_SRC

 If an object is ~auto~ initialized with a ~reference~ and does not have any declarator (such as *, &), ~reference~ qualifier drops:
 #+BEGIN_SRC C++
   int x = 10;
   int& r = x;
   // This equals to int y = r;. reference qualifier drops.
   auto y = r;

   const int& cr = x;
   // This equals to int z = cr;. const and reference qualifiers drop.
   auto z = cr;
 #+END_SRC

 Array decay rules are still valid: 
 #+BEGIN_SRC C++
   int a[] = { 1, 3, 6, 7 };
   auto p = a; // int* p = a;

   const int ca[] = { 1, 3, 6, 7 };
   // Here const qualifier does not drop. The object itself 'ca' is not const.
   // It is a pointer to const int after array decay.
   auto cp = ca; // const int* cp = ca;

   // The type of the "test" is const char[5], it decays to const char*.
   auto str = "test"; // const char* str = "test";
 #+END_SRC

 ~auto~ initialization with functions:
 #+BEGIN_SRC C++
   int foo(int);
   // Normally, type of the foo is int(int) but it decays to int (*)(int).
   auto fp = foo; // int (*fp)(int) = foo;
 #+END_SRC

 ~auto~ initialization and ~std::initializer_list~:
 #+BEGIN_SRC C++
   auto x = { 3 }; // std::initializer_list x = { 3 };
   auto y{ 3 }; // int y{ 3 }; This rule was different before. It was also meaning std::initializer_list y{ 3 };
 #+END_SRC

 Type deduction is made for ~auto~ keyword not for variable itself:
 #+BEGIN_SRC C++
   int x = 10;
   auto p1 = &x; // int* p1 = &x; auto -> int*
   auto* p2 = &x; // int* p2 = &x; auto -> int

   int* ptr = &x;
   auto p1 = &ptr; // int** p1 = &ptr; auto -> int**
   auto* p2 = &ptr; // int** p2 = &ptr; auto -> int*
   auto** p3 = &ptr; // int** p3 = &ptr; auto -> int
 #+END_SRC
 
 If declarators and ~auto~ are used together, rules are a bit different:
 In this example there is no difference:
 #+BEGIN_SRC C++
   int x = 10;
   auto& r = x; // int& r = x;
 #+END_SRC

 But when we use a ~const~ object:
 #+BEGIN_SRC C++
   const int x = 10;
   // const qualifier does not drop here.
   auto& r = x; // const int& r = x;
 #+END_SRC

 Array and function rules are also different:
 #+BEGIN_SRC C++
   int a[3] = { 1, 2, 3 };
   // Array decay does not occur here.
   auto& x = a; // int (&x)[3] = a;
   auto& str = "test"; // const char (&str)[5] = "test";

   int foo(int);
   // There is no decay here. Type deduction will be int(int) type for auto.
   auto& f1 = foo; // int (&f1)(int) = foo;   
 #+END_SRC

 If double reference (&&) declarator (forwarding-reference) is used with ~auto~, the rules change significantly. If ~auto&&~ is used, the type deduction for the ~auto~ keyword depends on the value category of the object used for initialization. Different rules are applied for L-value expressions and R-value expressions (PR-value or X-value).

 If value of category of the initializer is PR-value, the type deduction for ~auto~ will be the type of the expression:
 #+BEGIN_SRC C++
   // Type deduction for auto will be int because type of 20 is int.
   auto&& p = 20; // int&& p = 20;
 #+END_SRC

 If value of category of the initializer is L-value, the type deduction for ~auto~ will be L-value reference:
 #+BEGIN_SRC C++
   int x;
   // Type deduction for auto will be int& but there is no int&&&, so reference collapsing rules apply here.
   auto&& p = x; // After reference collapsing this equals to int& p = x;
 #+END_SRC

 Reference collapsing rules:
| reference type | binding reference type | result after reference collapsing |
|----------------+------------------------+-----------------------------------|
| T&             | T&&                    | T&                                |
| T&&            | T&                     | T&                                |
| T&             | T&                     | T&                                |
| T&&            | T&&                    | T&&                               |

*** decltype type deduction
 ~auto~ type deduction can be used for initialization but ~decltype~ type deduction does not have this limitation. It can be used in any context intead of types. ~decltype~ is also ~unevaluated context~ like ~sizeof~.

 ~decltype~ has quite complex rules. Using paranthesis is necessary while using ~decltype~. There are 2 different rulesets for ~decltype~:

 Rulesets:
  - If the operand of the ~decltype~ is an ~identifier~, different rules are applied.
  - If the operand of the ~decltype~ is an ~expression~, different rules are applied.

 Example for rulesets:
 #+BEGIN_SRC C++
   struct Data { int a, b, c; };
   
   Data my_data{};
   int x = 10;   
   
   // Identifier rules applied here.
   decltype(my_data);
   decltype(my_data.a);
   decltype(x);
   
   // But here expression rules are applied.
   decltype((x));
   decltype(+x);
 #+END_SRC

 ~decltype~ can be used in a lot of contexts:
 #+BEGIN_SRC C++
   int x = 10;

   decltype(x) foo(); // Function declaration. int foo();
   using my_type = decltype(x); // using my_type = int;

   const int y = 5;
   decltype(x) z = 0; // const int z = 0;
 #+END_SRC

 ~decltype~ and references:
  #+BEGIN_SRC C++
    int x{};
    auto& r{ x };

    decltype(r) r2 = x; // int& r2 = x;

    int y{};
    const auto& r3 = y;
    decltype(r3) r4 = y; // const int& r4 = y;
  #+END_SRC

 When the operand of the ~decltype~ is an expression. The type will be determined by the ~primary value category~ of the expression.
 If the expression is:
  - L-value deduction will be ~T&~
  - PR-value deduction will be ~T~
  - X-value deduction will be ~T&&~

 PR-value expression:
 #+BEGIN_SRC C++
   decltype(10); // PR-Value. int
 #+END_SRC
 
 L-value expression:
 #+BEGIN_SRC C++
   int x = 10;
   int* ptr = &x;
   decltype(*ptr) r = x; // L-value. int& r = x;
 
   int y = 5;
   decltype((y)) z = y; // L-value. int& z = y;
 
   int t = 10;
   decltype(t++); // int
   decltype(++t); // int&
 #+END_SRC
 
 ~decltype~ and arrays:
 #+BEGIN_SRC C++
   int a[5]{};
 
   // a is an identifier
   decltype(a) b; // int b[5]; No array decay.
   // a[0] is an expression
   decltype(a[0]) c = a[1]; // int& c = a[1];
 #+END_SRC

 X-value expression:
 #+BEGIN_SRC C++
  int f1();
  int& f2();
  int&& f3();

  decltype(f1()) x = 5; // PR-value. int x = 5;
  decltype(f2()) y = x; // L-value. int& y = x;
  decltype(f3()) z = 5; // X-value. int&& z = 5;
 #+END_SRC

 Other type deduction mechanisms will be discussed later.
 
 ... 
 
** Default Function Arguments
 Unlike C, C++ supports default function arguments. If a function mostly takes the same value for an argument, default function arguments are very helpful.
 When the ~default function argument~ is used, we do not need to pass a value to that argument when calling the function. The compiler will insert the value that we specified:
 #+BEGIN_SRC C++
   void func(int, int, int = 10);

   int x = 1;
   int y = 2;
   int z = 3;

   func(x, y, z); // func(x, y, z);
   func(x, y); // func(x, y, 10); The compiler will insert 10 for the 3rd argument because we did not send any argument for the 3rd parameter.
 #+END_SRC

 If a parameter of a function takes a ~default argument~, all parameters to the right of it must also take a ~default argument~. This essentially means that the ~default arguments~ are valid for the last function parameters:
 #+BEGIN_SRC C++
   void f1(int x, int y = 5, int z); // Invalid.
   void f2(int x, int y = 5, int z = 7); // Valid.
   void f3(int x = 3, int y = 5, int z = 7); // Valid.

   f3(); // f3(3, 5, 7);
   f3(40); // f3(40, 5, 7);
   f3(40, 50); // f3(40, 50, 7);
   f3(40, 50, 60); // f3(40, 50, 60);
 #+END_SRC

 Variables also can be used for ~default function arguments~:
 #+BEGIN_SRC C++
   int x{ 5 };
   void func(int = x); // Valid.

   func(); // func(x);

   int f1(int x = 0);
   void f2(int y = f1());

   f2(); // f2(f1(0));

   int y{ 5 };
   int foo(int n = y++)
   {
       return n;
   }

   // y = 5;
   foo(); // foo(y++); returns 5;
   foo(); // foo(y++); returns 6;
   foo(); // foo(y++); returns 7;
   // y = 8;
 #+END_SRC

 If ~the default function arguments~ are defined both in the function definition and in the declaration, this is a syntax error:
 #+BEGIN_SRC C++
   // Invalid.
   void f2(int x = 10);
   void f2(int x = 10)
   {
       //
   }

   // Valid.
   void f3(int x = 10);
   void f3(int x)
   {
       //
   }
 #+END_SRC
 
 If a function parameter does not take a ~default argument~, we can redeclare the function so that it takes a ~default argument~. This can, for example, allow us to pass ~default arguments~ to functions coming from external header files:
 #+BEGIN_SRC C++
   // external.h
   void func(int, int, int); // Function without any default arguments.

   // #include "external.h"
   void func(int, int, int = 10); // Valid.

   func(1, 5); // func(1, 5, 10);
 #+END_SRC
 
 The compiler takes the ~default arguments~ cumulatively:
 #+BEGIN_SRC C++
  // Invalid, because there are multiple definitions for the same parameter's default argument.
  void f1(int x = 10);
  void f1(int x = 10);

  // f2 does not take any default arguments. 
  void f2(int, int, int);
  // f2 takes a default argument for the 3rd parameter.
  void f2(int, int, int = 10);
  // f2 takes default arguments for the 2nd and 3rd parameters. This equals to void f2(int, int = 5, int = 10);
  // because the compiler takes the default arguments cumulatively.
  void f2(int, int = 5, int);

  f2(1) // f2(1, 5, 10);

  // f3 does not take any default arguments. 
  void f3(int, int, int);
  // Invalid. This is a different case, only last parameters can take default arguments.
  void f3(int, int = 5, int); 
 #+END_SRC

** Scoped enum / Enum class
 In addition to the ~traditional enum type~, C++ has a new enum type called ~scoped enum~ / ~enum class~. ~Scoped enum~ were introduced to overcome the disadvantages of the ~traditional enum type~.

*** Disadvantages of the traditional enum type
- ~Underlying type~ depends to the compiler. The compiler chooses ~int~ as default type but if ~int~ isn't big enough to store the ~enumeration constants~, the type choosen is compiler dependent. This is why ~traditional enum types~ cannot be used as ~incomplete types~. The compiler cannot know the size when used as an ~incomplete type~, because it may be larger than ~int~.
  #+BEGIN_SRC C++
    enum Color { Red, Green, Blue }; // Underlying type is int.
    enum MyEnum { Aa, Bb, Cc, Dd = 13024325325 }; // Underlying type is compiler dependent.
  #+END_SRC
- Implicit type conversion from ~traditional enum types~ to ~arithmetic types~ is allowed. Unfortunately, this can also lead to many problems.
  #+BEGIN_SRC C++
    enum Color { Red, Green, Blue };
    int x = Red; // Valid.
  #+END_SRC
- ~Enumeration constants~ don't have separate scope. This can cause name conflicts, especially with names from external header files.
  #+BEGIN_SRC C++
    // traffic.h
    enum TrafficLight { Red, Yellow, Green };
    // screen.h
    enum ScreenColor { Gray, White, Red };
  #+END_SRC

*** Advantages of the scoped enum type
 - The ~underlying type~ can be specified. If not specified ~int~ is default.
   #+BEGIN_SRC C++
     enum class Color : unsigned char { White, Black, Gray };
     enum Count : unsigned char { Zero, One, Two, Three }; // C++ also extended the traditional enum types, so that specifying underlying types is possible.
   #+END_SRC
 - No implicit type conversion from ~scoped enum types~ to ~arithmetic types~.
   #+BEGIN_SRC C++
     enum class Color : unsigned char { White, Black, Gray };
     Color color{ Color::Black };
     int x = color; // Invalid.
   #+END_SRC
 - ~Enumeration constants~ are no longer in the same scope with the ~enumeration type~. As the name indicates, they have a separate scope. This eliminates the name conflict problems.
   #+BEGIN_SRC C++
     enum class Color : unsigned char { White, Black, Gray };
     Color color1 = White; // Invalid.
     Color color2 = Color::White; // Valid.

     enum class TrafficLight { Red, Yellow, Green };
     enum class ScreenColor { Gray, White, Red };
     auto sc = ScreenColor::Red;
     auto tl = TrafficLight::Red;
   #+END_SRC

 In C++20, ~using enum declaration~ was added to the language. If we are sure that there is no name conflict, we can use ~using enum declaration~ to use ~enumeration constants~ without specifying them with a namespace.
 #+BEGIN_SRC C++
   enum class Color : unsigned char { White, Black, Gray };
   enum class Count : unsigned char { Zero, One, Two };

   void func()
   {
       // C++20, using enum declaration
       using enum Color;
       using enum Count::Zero;

       auto color1 = White; // Valid.
       auto color2 = Black; // Valid.

       auto count1 = Zero; // Valid.
       auto count2 = One; // Invalid.
   }
 #+END_SRC

** Type Cast Operators
 In C++, there 2 different type conversions: ~implicit type conversion~ and ~explicit type conversion~. In some cases the compiler is free to do ~implicit type conversion~ depending on the rules of the language, but if we want to explicity convert a type, we have to do ~explicit type conversion~ by using ~type cast operators~.

 There are 4-different type cast operators in C++ (excluding ~C-style cast~):
  - ~static_cast<target_type>(operand)~
     + Mostly used casting between different arithmetic and enumeration types, also can be used to cast from ~void*~ to another pointer type.
  - ~const_cast<target_type>(operand)~
     + Used for casting ~const T*~ to ~T*~.
  - ~reinterpret_cast<target_type>(operand)~
     + Used for casting between different pointer and reference types. Ex. ~int*~ to ~char*~.
  - ~dynamic_cast<target_type>(operand)~
     + This cast is about runtime polymorphism, can be used to cast from ~base class~ to ~derived class~.

 Example for ~static_cast~:
 #+BEGIN_SRC C++
   int x = 10;
   int y = 3;

   double dval = static_cast<double>(x) / y;
   int ival = static_cast<int>(dval);

   enum class Pos { off, on, hold };
   Pos pos = Pos::off;
   ival = static_cast<int>(pos);
 #+END_SRC

 Example for ~const_cast~:
 #+BEGIN_SRC C++
   char* mystrchr(const char* p, int c)
   {
       while (*p)
       {
	   if (*p == c)
	   {
	       return const_cast<char*>(p);
	   }
	   ++p;
       }

       if (c == '\0')
	   return const_cast<char*>(p);

       return nullptr;
   }
 #+END_SRC

 Example for ~reinterpret_cast~:
 #+BEGIN_SRC C++
   double dval = 451.2356;
   char* p = reinterpret_cast<char*>(&dval);

   for (std::size_t i{}; i < sizeof(double); ++i)
   {
       std::cout << p[i] << '\n';
   }
 #+END_SRC

Example for ~dynamic_cast~:
 Will be explained later.
 ...

*** Why C-style type cast is not enough?
 Different ~explicit type conversions~ can have different intentions and meanings. There can be many different reasons for converting one type to another type:
 - ~Explicit type conversion~ can be used to indicate that there will be data loss and that this is not a problem.
 - ~Explicit type conversion~ can be used to convert ~const T*~ to ~T*~, if we know the actual object is not a ~const~ object.
 - ~Explicit type conversion~ can be used to convert ~T*~ to ~char*~, to use the actual object as a char array.

 The list can be extended with different examples, but the point is that not every ~explicit type conversion~ has the same intention/meaning. The syntax of ~C-style type cast~ is very simple, but it is not sufficient to explain the intention of the conversion.

** Function Overloading
 In C++, multiple functions can have the same name but with different parameters. These functions can perform different tasks based on the parameters passed to them. The compiler differentiates between the overloaded functions by their number of parameters, types of parameters, and the order of parameters. When the compiler encounters a call to an overloaded function, it uses the argument types and number of arguments to determine which version of the overloaded function to invoke. This process, called ~static/early binding~ or ~compile-time polymorphism~, happens at compile-time, meaning the function to be executed is determined before the program runs. Function overloading is all about compile-time, it has no run-time overhead. For function overloading, there are 2 different and important points for the compiler to decide. Is there a function overloading for the particular function and if so, which function to choose. The process by the compiler to decide which function to choose is called ~function overload resolution~.

 To talk about function overloading, there are 3 different things to consider:
  - Function names have to be the same.
  - Function signatures have to be different.
  - Functions have to be in the same scope.
    + namespace scope
    + class scope
    + block scope

If one function is in ~namespace scope~ and the other is in ~block scope~, even if they have the same name, it will not cause function overloading. It causes ~name shadowing~ instead:
 #+BEGIN_SRC C++
   int foo(int);

   int main()
   {
       int foo(double);

       foo(5); // There is no funcion overloading. foo(double) will be called due to name shadowing.
   }
 #+END_SRC

 In order to do function overloading, functions must have different signatures. ~return~ type is not part of the signature:
 #+BEGIN_SRC C++
   int foo(int);
   double foo(int); // This is invalid, syntax error.
 #+END_SRC

 This is valid function overloading. Same function names, in the same scope and different signatures.
 #+BEGIN_SRC C++
   int foo(int);
   int foo(int, int);
 #+END_SRC

 ~Default function arguments~ do not effect ~function signature~. These functions still have different signatures and this is valid ~function overloading~. We don't talk about what happens when we call the function ~foo()~ with only one argument. It is about ~function overload resolution~.
 #+BEGIN_SRC C++
   int foo(int);
   int foo(int, int = 0);
 #+END_SRC

 If the parameter itself is ~const~ (~top-level const~) it doesn't effect ~function signature~. No ~function overloading~ here, it is ~function redeclaration~;
 #+BEGIN_SRC C++
   int foo(int);
   int foo(const int); // Valid, no overload. Function redeclaration.

   int func(double* const p);
   int func(double* p); // Valid, no overload. Function redeclaration
 #+END_SRC

 ~const T*~ is a different type than ~T*~. ~Low-level const~ changes ~function signature~. This is valid ~function overloading~ and mostly called ~const overload~:
 #+BEGIN_SRC C++
   int foo(int*);
   int foo(const int*);
 #+END_SRC

 ~const T&~ is a different type than ~T&~. This is valid ~function overloading~ and it is commonly used:
 #+BEGIN_SRC C++
   int foo(int&);
   int foo(const int&);
 #+END_SRC

 A Type alias doesn't mean a different type than the underlying type. No ~function oveloading~ here:
 #+BEGIN_SRC C++
   typedef double flt_type;

   void foo(double);
   void foo(flt_type); // Valid, no overload. Function redeclaration.
 #+END_SRC

 ~char~, ~unsigned char~ and ~signed char~ are 3 different distinct types. There are 3 ~function overload~ here:
 #+BEGIN_SRC C++
   void foo(char);
   void foo(signed char);
   void foo(unsigned char);
 #+END_SRC

 There are 3 ~function overloads~ here:
 #+BEGIN_SRC C++
   void foo(int*);
   void foo(int**);
   void foo(int***);
 #+END_SRC

 L-value reference and R-value reference. This is valid ~function overloading~:
 #+BEGIN_SRC C++
   void foo(int&);
   void foo(int&&);
 #+END_SRC

 There are 3 overloads:
 #+BEGIN_SRC C++
   void foo(int&);
   void foo(const int&);
   void foo(int&&);
 #+END_SRC

 We can't say there is ~function overload~ or not. This is ~implementation defined~, ~std::int32_t~ is not a distinct type but a type alias and underlying type is dependent to the compiler:
 #+BEGIN_SRC C++
   void foo(int);
   // If std::int32_t is alias to int. This is function redeclaration.
   // If std::int32_t is alias to long. This is valid function overload.
   void foo(std::int32_t);

   // This is valid function overload. std::int32_t and std::int16_t cannot be alias of the same type.
   void func(std::int32_t);
   void func(std::int16_t);
 #+END_SRC

 If array notation used in function declaration, array decay happens. There is no ~function overloading~ here:
 #+BEGIN_SRC C++
   void foo(int p[]); // Decays to foo(int*);
   void foo(int p[20]); // Decays to foo(int*); Function redeclaration.
   void foo(int* p); // foo(int*); Function redeclaration.
 #+END_SRC
 
 If a function takes function as a parameter. It decays to function pointer. No ~function overloading~ here:
 #+BEGIN_SRC C++
   void foo(int(int)); // Decays to foo(int (*)(int));
   void foo(int(*)(int)); // Function redeclaration.
 #+END_SRC

 There are 4 different ~function overloads~ here:
 #+BEGIN_SRC C++
   void foo(int (*)[5]); // int(*)[5]; a pointer to int[5]
   void foo(int (*)[6]); // int(*)[6]; a pointer to int[6]
   void foo(int (*)[7]); // int(*)[7]; a pointer to int[7]
   void foo(int (*)[8]); // int(*)[8]; a pointer to int[8]
 #+END_SRC
 
*** Function overload resolution
 ~Function overload resolution~ is handled by the compiler as a 3 step process. Actually, 3 steps is the maximum, it may take fewer steps:
 - Choosing ~candidate functions~.
   + In this step, the compiler doesn't check function arguments but marks the visible functions in the same scope which has the same name.
 - Choosing ~viable functions~.
   + The compiler checks each ~candidate function~ too see if it can be called with the arguments we passed it without syntax errors. If there are no syntax errors, the compiler marks that function. These marked functions are called ~viable functions~. After this step, all functions that are not suitable for calling are eliminated and only those functions that can be called legally remain.
   + In this step, the compiler determines the ~viable functions~ depending on passed arguments. The number of arguments, the types of arguments, the default function arguments and the implicit conversion rules between types all are very important in this step.
   + More than one function overload does not guarantee that a call with this name is valid. None of the function overloads may be ~viable functions~, this is called ~no match~. 
 - Choosing the ~best viable function~.
   + If there are more than one ~viable function~, the compiler will decide which one is the ~best match~ based on the rules of the language.
   + There may be more than one ~viable function~ among which the compiler cannot decide which one to choose, because there are no selection criteria in terms of the rules of the language, this is called ~ambiguity~.

 Rules for choosing the ~best viable function~ / ~best match~:
  - ~variadic conversion~ always loses if there are any other alternatives.
  - ~user-defined conversion~ always loses except when the alternative is ~variadic conversion~.
    + If there are more than one ~viable function~ with ~user-defined conversion~, this might cause an ~ambiguity~ error, if there is no better alternative (~standard converion~).
  - ~standard/implicit conversion~ always wins except when the other alternatives are also ~standart conversion~. There are different rules for this case.
    + ~exact match~ always wins over ~promotion~.
      * When the function parameters and the arguments are the same.
      * ~implicit conversion~ from ~T*~ to ~const T*~.
      * ~array to pointer conversion~ / ~Array decay~.
      * ~function to pointer conversion~.
    + ~promotion~ always wins over ~conversion~.
      * ~integral promotion~ (types which have lower rank than ~int~ are promoted to ~int~),
      * ~float to double promotion~
    + ~conversion~ always wins over ~user-defined conversion~.
      * ~conversion~ between different types which is not ~promotion~. (~char~ to ~double~, ~double~ to ~int~ etc.)

 Functions with multiple parameters can also be overloaded. In this case, one of the ~function overloads~ must be win over to the others in at least one parameter and must be at least equal (shouldn't be weaker) in the other parameters.

 From weaker ~viable function~ to stronger:
  ~variadic conversion~ < ~user-defined conversion~ < ~standard conversion~ < ~standard promotion~ < ~exact match~

 #+BEGIN_SRC C++
   void f(int);
   void f(double);
   void f(long);

   f(3.4); // f(double) will be called, exact match.
   f(12); // f(int) will be called, exact match.
   f(12u); // unsigned int can be converted to int, double and long. Three different standard conversion causes ambiguity.
   f(true); // f(int) will be called, bool to int is integral promotion and promotion wins over conversion.
   f(2.3L); // long double can be converted to int, double and long. Three different standard conversion causes ambiguity.
   f(2.3f); // f(double) will be called, float to double promotion.
   f('A'); // f(int) will be called, integral promotion from char to int.
 #+END_SRC

 If one of the ~viable functions~ takes ~T*~ and the other one takes ~const T*~, this is called ~const overloading~ and means both of them are ~exact match~. If the argument type is ~const T*~, ~const T*~ will be called, otherwise ~T*~ will be called. This is also valid for references.
 #+BEGIN_SRC C++
   void f1(int*);
   void f1(const int*);
   void f2(int&);
   void f2(const int&);

   const int cx = 5;
   int x = 5;

   f1(&cx); // f1(const int*) will be called.
   f1(&x); // f1(int*) will be called.

   f2(&cx); // f2(const int&) will be called.
   f2(&x); // f2(int&) will be called.
 #+END_SRC

 Default function arguments can cause ~ambiguity~:
 #+BEGIN_SRC C++
   void func(int x, int y = 0);
   void func(int x);

   func(12); // There are 2 valid oveloads of func but the compiler cannot decide between them. Ambiguity error.
 #+END_SRC

 Having 2 different ~function overloads~ for ~call by value~ and ~call by reference~ can cause ~ambiguity~:
 #+BEGIN_SRC C++
   void f1(int& x);
   void f1(int x);

   void f2(const int& x);
   void f2(int x);

   int x = 10;

   f1(x); // Invalid, ambigious call.
   f1(10); // Valid, func(x) will be called.
   f2(x); // Invalid, ambigious call.
   f2(10); // Invalid, ambigious call.
 #+END_SRC

 Using C-style null pointer can cause ~ambiguity~:
 #+BEGIN_SRC C++
   void func(double*);
   void func(int);

   // Let's say the intention was to call func(double*) with null pointer and then we added a new overload func(int). This code will not give any error and call to func(int), because it will be exact match. If we really want to call func(double*) with null pointer we should use nullptr.
   func(0); // Valid, func(int) will be called.
   func(nullptr); // Valid, func(double*) will be called.
 #+END_SRC

 We can choose the overload we want to call by using ~explicit cast~. We can also use ~name shadowing~ to call the function we want by ~redeclaring~ it in the current scope.
 #+BEGIN_SRC C++
   void func(int);
   void func(double);
   void func(long);

   int main()
   {
       int x = 10;

       func(static_cast<double>(x)); // func(double) will be called.

	// This function redeclaration causes name shadowing. From this point on, every call to func in this scope will be call to func(long).
       void func(long);

       func(x); // func(long) will be called.
       func(2.3); // func(long) will be called.
   }
 #+END_SRC

 When one of the overloads is ~bool~ and the other is ~void*~, this should normally cause ~ambiguity~ when called with pointer types, but this is an exception and the ~void*~ one will be called:
 #+BEGIN_SRC C++
   void func(bool);
   void func(void*);

   int x{};

   // Implicit conversion from int* to bool and from int* to void* exist. Normally, this should cause ambiguity but this is a special case and func(void*) will be called.
   func(&x);
 #+END_SRC

 We can call ~L-value reference~ overloads with ~L-value expressions~, and ~R-value reference~ overloads with ~R-value expressions~. Normally, ~const L-value reference~ and ~R-value reference~ both can be called with ~R-value expressions~ but this doesn't cause ~ambiguity~. The function which takes an ~R-value reference~ will be called in this case:
 #+BEGIN_SRC C++
     void f1(int&);
     void f1(int&&);

     void f2(const int&);
     void f2(int&&);

     int x{};

     f1(10); // Valid, 10 is R-value expression, f1(int&&) will be called.
     f1(x); // Valid, x is L-value expression, f1(int&) will be called.

     f2(x); // Valid, x is L-value expression, f2(const int&) will be called.
     // Valid, 10 is R-value expression, normally f2(const int&) and f2(int&&) both
     // can be called with a R-value expression but this does not cause ambiguity. f2(int&&) will be called.
     f2(10);
 #+END_SRC

 ~Data type~ (~declaration type~) and ~value category~ are not the same thing. Variables/declarations don't have a ~value category~ but ~data type~, we need to have an ~expression~ to talk about ~value category~. We can observe it in this example:
 #+BEGIN_SRC C++
   #include <iostream>

   void bar(int& x)
   {
       std::cout << 3;
   }

   void bar(int&& x)
   {
       std::cout << 4;
   }

   void func(int& x)
   {
       std::cout << 1;
       bar(x);
   }

   void func(int&& x)
   {
       std::cout << 2;
       // The data/declaration type of x is int&& but the value category of x when used in an expression is L-value
       // so bar(int&) will be called.
       bar(x);
   }

   int main()
   {
       int x = 10;

       func(x); // Output: 13
       func(10); // Output: 23
   }
 #+END_SRC

 We were always using one paramater for ~function oveloads~, but functions with multiple parameters can also be overloaded. In this case, one of the ~function overloads~ must win over to the others in at least one parameter and must be at least equal in the other parameters.
 #+BEGIN_SRC C++
   void f1(int, double, long); // 1
   void f1(char, int, double); // 2
   void f1(long, unsigned int, float); // 3

   // Function 1 will be chosen. The 1st parameter of function 1 wins over the 1st parameter of function 2 and 3, because it is exact match. 2nd and 3rd parameter is equal for functions 1, 2 and 3, because all of them are standart conversion.
   f(12, 4L, 1);
   // Function 2 will be chosen. The 2nd parameter of function 2 wins over the 2nd parameter of function 1 and 3, because it is standard promotion. 1st and 3rd parameter is equal for functions 1, 2 and 3, because all of them are standart conversion.
   f(2.3, true, 12);
   // Function 3 will be chosen. The 1st parameter of function 3 wins over the 1st parameter of function 1 and 2, because it is exact match. 2nd and 3rd parameter is equal for functions 1, 2 and 3, because all of them are standart conversion.
   f(34L, 3.5L, 12);
   // This causes ambiguity. The 1st parameter of function 1 has exact match, but the 2nd parameter of the function 2 also has exact match. The 3rd parameters have standard conversion. There are 2 exact matches for different function overloads, in this case the compiler cannot decide. One of the overloads must win over others at least on one parameter, and at least be equal on the other parameters.
   f(12, 12, 12);
 #+END_SRC

** Name Mangling
 ~Name mangling~ is a process used by C++ compilers to generate unique names for functions, variables, and other entities to support features like ~function overloading~, ~namespaces~, and ~template instantiation~. Since C++ allows multiple functions with the same name (through ~function overloading~), the compiler needs a way to differentiate between these functions at the binary level. ~Name mangling~ achieves this by encoding additional information, such as the function's ~parameter types~, ~return type~, and the ~namespace~ or ~class~ it belongs to, into the function's name. 

 ~Name mangling~ can cause some problems when we call a C function from a C++ source. An example of a problem caused by ~name mangling~:
 #+BEGIN_SRC C++
   // test.h
   int func(int);

   // test.c
   int func(int x)
   {
       return x + 1;
   }

   // main.cpp
   #include "test.h"

   int main()
   {
       // This code will be built successfully but will not be linked. The
       // linker program will not find func(int) because the C++ compiler
       // will produce a mangled/decorated name for func(int), but it is a
       // C function. The name produced by the C compiler will not match
       // the name produced by the C++ compiler, because there is no name
       // mangling in C.
       auto x = func(20);
   }
 #+END_SRC

 To solve this kind of problems we typically use ~extern "C"~ declaration with ~conditional compiling~. By doing this we can use the same ~header file~ for both C and C++.

 #+BEGIN_SRC C++
   // test.h
   #ifdef __cplusplus
   extern "C" { // open extern "C" block.
   #endif

   int func(int);

   #ifdef __cplusplus
   } // close extern "C" block.
   #endif

   // test.c
   int func(int x)
   {
       return x + 1;
   }

   // main.cpp
   #include "test.h"

   int main()
   {
       // This code will be built and linked successfully. The
       // compiler won't generate mangled names for func(int)
       // because its declaration is inside of an extern "C" block.
       auto x = func(20);
   }
 #+END_SRC

** One Definition Rule (ODR)
 Objects (variables, functions, templates, classes etc.) in C++ can have multiple declarations but only one definition across the project. This is called ~one definition rule~. If a program has more than one definition of a particular object, the program is ~ill-formed~ and the compiler isn't required to give any diagnostics. The linker program may give some diagnostics but it is also not guaranteed. If the same object has multiple definitions in the same source file, it is a syntax error and diagnostic is required.

 Some examples:
 #+BEGIN_SRC C++
   // test.h
   int x = 10;

   // If test.h is to be included from multiple source files, this is against the ODR because variable x will have multiple definitions.
 #+END_SRC

#+BEGIN_SRC C++
  // test.h
  void func()
  {
  }
  // If test.h is to be included from multiple source files, this is against the ODR because func() will have multiple definitions.
 #+END_SRC

 When an ~inline function~ in a ~header file~ is included from multiple source files, this isn't against the ~ODR~ and but every source file will have its own definition for that particular function.
 #+BEGIN_SRC C++
  // test.h
  static void func()
  {
  }
  // If test.h is to be included from multiple source files, this is not against the ODR because func() will be in internal linkage. Every source file will have its own func().
 #+END_SRC

 There are such objects that can have more than one definition in different source files but do not violate the ~ODR~, but their definitions must be the same ~token-by-token~. This is very important because in practice it means that the definitions of these objects can be in ~header files~.
 Definitions that can coexist in different source files without violating ODR:
  - ~class definitions~
  - ~inline function definitions~
  - ~inline variable definitions~ (C++17)
  - ~constexpr functions~
  - ~constexpr variables~
  - ~class templates~
  - ~function templates~

** Inline functions
 Functions defined with the ~inline~ keyword are called ~inline functions~, meaning that they will not violate the ~ODR~. This means we can define ~inline functions~ in ~header files~. ~inline functions~ are not directly related with the ~inline expansion~. ~inline expansion~ is an old and effective optimization method often used by compilers. In a nutshell, this means that instead of calling a function, the compiler embeds the code for that function directly into the source code, depending on the different parameters. The main purpose of defining an ~inline function~ using the ~inline~ keyword is not to allow the compiler to do ~inline expansion~ but to avoid violating ~ODR~. Unless a special compiler flag is used, it is up to the compiler to decide whether to do ~inline expansion~ or not.

 When an ~inline function~ in a ~header file~ is included from multiple source files, this is not against the ~ODR~ and there will be only one definition from the compiler perspective even it is included in multiple source files unlike ~static~ functions.
 
 #+BEGIN_SRC C++
  // test.h
  inline void func()
  {
  }
  // If test.h is to be included from multiple source files, this is not against the ODR. There will be only one func() even it is included in multiple source files.
 #+END_SRC

** Inline variables 
 Variables defined with the ~inline~ keyword are called ~inline variables~, meaning that they will not violate the ~ODR~ similar to ~inline functions~. ~Inline variables~ were added in C++17. When an ~inline variable~ in a ~header file~ is included from multiple source files, this is not against the ~ODR~ and there will be only one definition from the compiler perspective even it is included in multiple source files.

 #+BEGIN_SRC C++
   // test.h
   inline int x = 10;
   // If test.h is to be included from multiple source files, this is not against the ODR. There will be only one x even it is included in multiple source files.
 #+END_SRC

** constexpr
*** constexpr variables
 In C++, variables defined with the ~const~ keyword can be initialized with const and non-const expressions:

 #+BEGIN_SRC C++
   int foo();

   // These are valid definitions, const objects can be initialized with const and non-const expressions.
   const int x = 10;
   const int y = foo();

   int arr1[x]; // This is valid because x is initialized with a const expression (10) which means expression created by x is also const expression.
   int arr2[y]; // This is invalid because y is initialized with a non-const expression (foo()) which means expression created by y is also non-const expression.
 #+END_SRC

 But, variables defined with the ~constexpr~ keyword has to be initialized with a constant expression:
 #+BEGIN_SRC C++
   int foo();

   constexpr int x = 10; // This is valid. 10 is constant expression.
   constexpr int y = foo(); // This is invalid. foo() is non-const expression.
 #+END_SRC

 Variables defined with the ~constexpr~ keyword has ~const~ declaration type:
 #+BEGIN_SRC C++
   constexpr int x = 10;

   x = 5; // This is invalid because x is const.
   decltype(x); // This equals to const int.

   int g{};

   constexpr int* p = &g;
   decltype(p); // This equals to int* const p;

   constexpr const int* t = &g;
   decltype(t); // This equals to const int* const t;
 #+END_SRC

*** constexpr functions
 ~constexpr~ functions are functions whose return value is obtained at compile time when certain conditions are met. If ~constexpr~ functions are called with non-const arguments, the return value will be calculated at runtime like normal functions.

 Some restrictions when defining ~constexpr~ functions:
   - Cannot define ~static~ local variables.
   - Cannot be a virtual function.
   - Return type cannot be ~void~.
   - Return type, types of all local variables and types of arguments must be ~literal type~.

 #+BEGIN_SRC C++
   constexpr int sum_square(int a, int b)
   {
       return a * a + b * b;
   }

   constexpr int ndigit(int x)
   {
       int digit_count = 0;

       if (x == 0)
	   return 1;

       while (x)
       {
	   ++digit_count;
	   x /= 10;
       }

      return digit_count;
   }

   int main()
   {
       const int a = 87234;
       const int b = 7624271;

       // These will be calculated at compile time and the generated return values are also constant expression. 
       constexpr auto x = sum_square(10, 20); 
       constexpr auto y = sum_square(ndigit(a) + ndigit(b));

       int j = 1515;

       // This is valid. j is not const and because of that ndigit(j) will be called at runtime.
       int k = ndigit(j);

       // This is invalid. j is not const and because of that ndigit(j) will be called at runtime. This means generated return value also will be non-const and constexpr variables cannot be initialized with non-const expressions.
       constexpr int l = ndigit(j);
   }
 #+END_SRC

** Classes
 The use of classes in C++ is not limited to object-oriented programming. Classes are the main tools for data abstraction also beyond object-oriented programming.

*** Class definition
 Classes are ~user-defined types~ that can have ~data members~, ~member functions~ and ~type member / member type / nested type~. They are defined/declared with the keywords ~class~ and ~struct~ (note that unlike C, ~struct~ is also a class).
 A class definition gives the compiler all the information about that class. It is also possible to declare a class without defining it. In this case, the compiler cannot get all the information about the class from the class declaration. All it knows is that the class is declared and that it must get all the necessary information about this class from the definition which can be in another source file. 

 Members of the classes can be taxonomically listed as follows:
 - ~class members~
   - ~data members~
     - ~non-static data members~
     - ~static data members~
   - ~member functions~
     - ~non-static member functions~
     - ~static member functions~
   - ~type member / member type / nested type~

 Defining and declaring classes:
 #+BEGIN_SRC C++
   // Class declaration / Forwarding declaration. In this point, C1 is incomplete class. The compiler doesn't know anything but just the name of it. 
   class C1;

   // Class types can be empty. If a class is empty, it is called empty class.
   class C2 // Class definition
   {

   };

   // In C++ when we say class we also mean struct because structs are also class type.
   // Note: Empty structs are invalid in C.
   struct C3 // Class definition
   {

   };
 #+END_SRC

 Classes can have different type of ~class members~ in the ~class scope~.
 #+BEGIN_SRC C++
   class C1 
   {
       // Data members
       // Member functions
       // Type member / Member type / Nested type
   };

  class C2
  {
      int mx; // Data member
      void f(); // Member function
      enum Pos{ ON, OFF }; // Member type
  };
 #+END_SRC

 If a class will be used also in other source files, the definition can be placed in a header file. It is not against the ODR.
 #+BEGIN_SRC C++
   // test.h
   class C1
   {
       int a, b;
       double d1, d2;
       void f();
   };

   // main.cpp
   // #include "test.h"
   int main()
   {
       C1 c1;

       return 0;
   }
 #+END_SRC

*** Access control
 Normally, when an identifier is used, the compiler performs a name lookup to find out what object that name represents, but in C++ (also in other languages which supports OOP style programming) there is one more step after the name lookup. The compiler must check that the code trying to access an identifier has permission to access that identifier. This is called ~access control~.

 There are 3 different access categories that apply to the members of classes and determine who can and cannot access them. These 3 categories are actually also keywords and are called ~access specifiers~:
  - ~public~
    + ~public class members~ can be accessed both within the class itself and by clients using the class, meaning there is no access control for ~public class members~.
  - ~private~
    + ~private class members~ can only be accessed within the class itself and cannot be used by external codes.
  - ~protected~
    + ~protected class members~ can be accessed within the class itself and from its derived classes. 

 ~access specifiers~ can be used to define ~access rights~ for a group of ~class members~:
 #+BEGIN_SRC C++
  class C1
  {
  public: // Each class member will have public access right from here until the compiler sees another access specifier.
      int x;
      int y;
      void f1();

  private:
      int z; // Each class member will have private access right from here until the compiler sees another access specifier.
      void f2();

  protected: // Same applies here.
      int t;
  };
 #+END_SRC
 
 If a class type is defined with the ~class~ keyword, all of its ~class members~ are ~private~ by default:
 #+BEGIN_SRC C++
   class C1
   {
       // If no access specifier is used these class members are private by default.
       int x;
       void f1();

   public:
       int a, b;
   };
 #+END_SRC
 
 If a class type is defined with the ~struct~ keyword, all of its ~class members~ are ~public~ by default: 
 #+BEGIN_SRC C++
   struct C1
   {
       // If no access specifier is used these class members are public by default.
       int x;
       void f1();

   private:
       int a, b;
   };
 #+END_SRC

 Same ~access specifier~ can be used multiple times:
 #+BEGIN_SRC C++
   class C1
   {
   public:

   private:

   public:

   private:
   };
 #+END_SRC

*** Non-static data members
 ~non-static data members~ are variables that are actually held within the object of a class, that is, they are variables of the object that is created of that class. 

 When ~non-static data members~ are added to an object, the object's storage requirement will increase depending on the added members:
 #+BEGIN_SRC C++
   class C1
   {
       int x;
   };

   class C2
   {
   };

   int main()
   {
       // This will print 4 assuming int is 4 bytes.   
       std::cout << "sizeof(C1) = " << sizeof(C1) << '\n';
       // Empty classes are 1 byte.
       std::cout << "sizeof(C2) = " << sizeof(C2) << '\n';
   }
 #+END_SRC

*** Non-static member functions
 ~non-static member functions~ are no different from normal functions at the assembly level, they are just an abstraction that exists at the language layer. ~non-static member functions~ are functions defined in the ~class definition~. They have an implicit ~this~ pointer that refers to the object on which they are called. ~this~ pointer allows them to access the object's ~non-static data members~ and other ~non-static member functions~.

 #+BEGIN_SRC C++
   class C1
   {
   public:
       void foo(int); // Non-static member functions have implicit ~this pointer~ which is the address of the caller object. The compiler sees it like void foo(C1* this, int);

   private:
       int mx; // Non-static data member
   };

   int main()
   {
       C1 c1;    

       c1.foo(12); // This is similar to foo(&c1, 12);
   }
 #+END_SRC

 There are 2 different ways to define ~non-static member functions~.

 A ~non-static member function~ can be declared in the header file and defined it in the source file. If the signatures don't match it is a syntax error:
 #+BEGIN_SRC C++
   // fighter.h
   class Fighter
   {
   public:
       void attack(Fighter&);
   };

   // fighter.cpp
   // #include "fighter.h"
   void Fighter::attack(Fighter& f)
   {

   }
 #+END_SRC

 A ~non-static member function~ can be declared and defined directly in the ~class definition~. When a ~non-static member function~ is defined like this, it is implicitly an ~inline function~, meaning including it to multiple source file isn't against the ~ODR~.
 #+BEGIN_SRC C++
   // fighter.h
   class Fighter
   {
   public:
       void attack(Fighter& f) // This equals to inline void attack(Fighter &f);. Using inline explicity doesn't matter in this case.
       {

       }
   };
 #+END_SRC

 In this case, if the ~inline~ keyword is not used explicity in the declaration or definition, it is against the ~ODR~.
 #+BEGIN_SRC C++
   // fighter.h
   class Fighter
   {
   public:
       void attack(Fighter& f); // This is not implicitly inline function because it doesn't have definition.
   };

   // This is the definition of attack function but it is also in the header file. If we include this header file
   // from multiple source file it is agains the ODR. We should use the inline keyword explicitly in the declaration or definition
   // if we want to do this.
   void Fighter::attack(Fighter& f)
   {
   }
 #+END_SRC

 ~unqualified identifiers~ in the definition of a ~non-static member function~ are searched in this order:
  - ~block scope~
  - ~enclosing block scopes~ (there can be multiple ~enclosing blocks~)
  - ~class scope~
  - ~namespace scope~

 #+BEGIN_SRC C++
   // class.h
   class C1 // 3
   {
   public:
       void foo();

   private:
       int mx, my;
       int a;
   };

   // 4

   // class.c
   void C1::foo() // 2
   {
       int a = 0;

       if (1) // 1
       {
	   // 1 - x will be searched in this if block first. From x to beginning of if block.
	   // 2 - x will be searched in the enclosing block (function block in this case) if it couldn't be found in 1. 
	   // 3 - x will be searched in the class scope if it couldn't be found in 2.
	   // 4 - x will be searched in the namespace scope if it couldn't be found in 3.
	   // If it couldn't be found in 4, name look-up will fail.
	   x;

	   // mx will be found in 3 (class scope). The compiler will change it to qualified identifier by using implicit ~this pointer~.
	   mx; // This is equal to this->mx.

           // a will be found in 2 (enclosing block). This will increase the local a inside of the function block, not the a in the class scope.
           a++;
       }
   }
 #+END_SRC

 The ~non-static data members~ accessed in ~non-static member functions~ are the data members of the object they are called on:

#+BEGIN_SRC C++
  class Counter
  {
  public:
      void print()
      {
          std::cout << m_c << '\n';
      }
      
      void set(int val)
      {
          m_c = val;
      }

  private:
      int m_c{};
  };

  int main()
  {
      Counter c1;

      c1.set(78); // Sets c1's m_c to 78.
      c1.print(); // Prints c1's m_c, which is 78.
      c1.set(99); // Sets c1's m_c to 99.
      c1.print(); // Prints 99.

      Counter c2;
      
      c2.set(3333); // Sets c2's m_c to 3333.
      c2.print(); // Prints c2's m_c, which is 3333.
  }
 #+END_SRC

*** Class scope
 ~class members~ declared in the ~class definition~ are included in the ~class scope~.
 In which cases is a identifier searched within a ~class definition~?
  - If the identifier is the right operand of ~. operator~.
    + ~object.x~, ~x~ will be searched in the ~class scope~.
  - If the identifier is the right operand of ~-> operator~.
    + ~object->x~, ~x~ will be searched in the ~class scope~.
  - If the identifier is the right operand of ~:: operator~.
    + ~class::x~, ~x~ will be searched in the ~class scope~.

 All of the ~access specifiers~ are in the same ~class scope~. ~public~, ~private~ and ~protected~ don't create new scope, they share the same ~class scope~.
      
 #+BEGIN_SRC C++
   class C1
   {
   public:
       void foo();
   private:
       int x;
   };

   int x = 3477;

   void C1::foo()
   {
       int x = 10;

       x = 56; // This x is defined in the block scope.

       C1::x = 20; // If we want access the x which is in the class scope. We can use qualified name. The compiler will search it only in the class scope.
       ::x = 22; // This x in the namespace scope.
   }
 #+END_SRC

 ~Member functions~ cannot be redeclared:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       void foo(int);
       void foo(int); // Redeclaration is invalid, syntax error.
   };

   void foo(int);
   void foo(int); // Redeclaration is valid.
 #+END_SRC

 ~Function overloading~ and ~function overload resolution~ rules also apply to ~member functions~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // This is valid function overloading, because they are in the same class scope.
       void foo(int);
       void foo(int, int);
   };
 #+END_SRC

 ~Access specifiers~ don't effect ~function overloading~ rules because they are not related with scope:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // This is valid function overloading, because they are in the same class scope.
       void foo(int);
   private:
       void foo(int, int);
   };
 #+END_SRC

 #+BEGIN_SRC C++
   class C1
   {
   public:
       void foo(int);
   private:
       void foo(double);
   };

   int main()
   {
       C1 c;
       c.func(2.3); // After function overload resolution, foo(double) will be chosen (exact match) but access control will fail because it is a private function.
   }
 #+END_SRC

*** this keyword
 ~this~ is a keyword that can only be used in ~non-static member functions~ of a class. ~this~ represents a pointer and often called ~this pointer~. ~this pointer~ holds the address of the object on which the function is called.

 The use of ~this~ keyword in ~global functions~ or in ~static member functions~ of classes is a syntax error:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       void f1(int)
       {
           this; // This is valid.
       }
       
       static void f2(int)
       {
           this; // This is invalid.
       }
   };
 #+END_SRC

~this pointer~ holds the address of the caller object:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       void foo()
       {
           std::cout << "this: " << this << '\n';
       }

       int main()
       {
           C1 c1;
           std::cout << "&c1: " << &c1 << '\n';
           c1.foo(); // The address of the c1 (&c1) and ~this pointer~ are same.

           C1 c2;
           std::cout << "&c2: " << &c2 << '\n';
           c2.foo(); // The address of the c2 (&c2) and ~this pointer~ are same.
       }
    };
 #+END_SRC

 The value category of an expression created by ~this pointer~ is ~PR-value expression~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       void foo()
       {
           &this; // This is invalid. ~this~ is a PR-value expression. Only L-value expressions can be the operand of address operator.
       }
    };
 #+END_SRC

 #+BEGIN_SRC C++
   class C1
   {
   public:
       void foo()
       {
           &this; // This is invalid. ~this~ is a PR-value expression. Only L-value expressions can be the operand of address operator.
       }
    };
 #+END_SRC

 The ~non-static data members~ can be accessed from ~non-static member functions~ with or without a ~qualifier~, but it is also possible to access them via ~this pointer~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       void foo()
       {
           // All of these are same.
           mx = 20; // Access with unqualified identifier.
           C1::mx = 20; // Access with qualified identifier.
           this->mx = 20; // Access through ~this pointer~.
       }

   private:
       int mx;
   };
 #+END_SRC

 There are situations where it is not possible to do what we want without using ~this pointer~. 

 It is not possible to call another function within a ~non-static member function~ for the caller object without ~this pointer~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       void f1();
   };

   void f2(C1*);
   void f3(C1);
   void f4(C1&);

   int C1::f1()
   {
       // There is no way to call f2, f3 and f4 with the caller object without ~this pointer~.
       f2(this);
       f3(*this);
       f4(*this);
   }
 #+END_SRC

 It is not possible to return the caller object or the address of the caller object without ~this pointer~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1 f1()
       {
	   return *this;
       }

       C1* f2()
       {
	   return this;
       }

       C1& f3()
       {
           return *this;
       }
   };
 #+END_SRC

*** Const member functions
 ~this pointer~ is a hidden parameter that all ~non-static member functions~ have, so we cannot tell whether a function is a mutator or an accessor function. To avoid this confusion, if a function is not a mutator, we can define/declare it as ~const~ to indicate this. When a ~non-static member function~ is defined as ~const~, the hidden ~this pointer~ becomes ~const~. The ~const member functions~ basically tell us that they will not change the value/state of the object.

 There are 2 different categories for ~non-static member functions~:
  - ~const member function~
  - ~non-const member function~

 #+BEGIN_SRC C++
   class C1
   {
   public:
       // Const member function / Accessor function. This equals to void get(const C1*);
       void get() const;

       // Non-const member function / Mutator function. This equals to void get(C1*);
       void set();
   };
 #+END_SRC

 The compiler performs the same checks for ~const this pointer~ as it does for other ~const objects~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       void f1() const
       {
           // This equals to this->mx = 10;
           mx = 10; // Invalid, because ~this pointer~ is const. Mutating a const object is a syntax error.
       }

   private:
       int mx;
   };
 #+END_SRC

 ~non-const member functions~ cannot be called within ~const member functions~, because there is no implicit conversion from ~const T*~ to ~T*~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       void f1()
       {
           f2(); // Valid. T* can be converted to const T* implicitly.
       }

       void f2() const
       {
           // f2() takes const ~this pointer~ and tries to call f1() which takes non-const ~this pointer~, 
           // but there is no implicit cast from const T* to T*.
           f1(); // Invalid. 
       }
  };
 #+END_SRC

 ~non-const/const member functions~ can be called with ~non-const~ class objects:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       void f1()
       {
       }

       void f2() const
       {
       }
  };

   int main()
   {
       C1 a;
       
       a.f1(); // Valid.
       a.f2(); // Valid.
    }
 #+END_SRC

 ~const~ class objects can only call ~const member functions~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       void f1()
       {
       }

       void f2() const
       {
       }
  };

   int main()
   {
       const C1 a;

       // &a is const C1* but f1() has implicit non-const ~this pointer~ and
       // there is no implicit conversion from const T* to T*.
       a.f1(); // Invalid.
       a.f2(); // Valid.
    }
 #+END_SRC

 To define ~const member functions~, the ~const~ keyword must appear in both the declaration and the definition:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       void f1() const;
   };

   void C1::f1() const
   {
   }
 #+END_SRC

 ~non-const/const member functions~ can be used for ~function overloading~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // These are valid overloads.

       void f1()
       {
	   std::cout << "C1::f1()\n";
       }

       void f1() const
       {
	   std::cout << "C1::f1() const\n";
       }
   };

   int main()
   {
       const C1 a;
       C1 b;

       a.f1(); // C1::f1() const will be called.
       b.f1(); // C1::f1() will be called.
   }
 #+END_SRC

*** mutable keyword
 Normally, the ~const member functions~ and ~const objects~ of the class cannot change the value of the object's ~non-static data members~, but the ~non-static data members~ declared with the ~mutable~ keyword can be changed by the ~const member functions~.

 If the reason for the existence of ~const member functions~ is to prevent modification of ~non-static data members~, why do we want to allow changes by using ~mutable~ keyword? Not every ~non-static data member~ of an object has to directly represent the state of the object. For example, some ~data members~ can be used for debugging and caching purposes and have no direct effect on the ~observable state~ of the object. The ~mutable~ keyword is particularly useful in these cases.

 Assume there is a ~Date~ class with some ~non-static data members~ to represent the day, month and year. If we want to know how many times the month was accessed, we can put an additional ~data member~ to count it and increment it in the month's ~getter~, but this is not directly related to the state of the object. It is just additional data that is needed for some reason. If there was no ~mutable~ keyword, we would have to change ~getter~ to ~non-const member function~ just to have some debug information. Example:
 #+BEGIN_SRC C++
   class Date
   {
   public:
       int get_month() const
       {
           // ...
           ++m_debug_month_hit_count;
           return m_month; 
       }
   private:
       int m_day, m_month, m_year;
       // This data member is not directly related with the value/state of the object. It is just a debug information.
       // It is declared as mutable so it is allowed to be changed even from const member functions.
       mutable int m_debug_month_hit_count;
   };
 #+END_SRC
 
 ~const objects~ can also change the ~mutable~ data members:
 #+BEGIN_SRC C++
   class Date
   {
   public:
       int get_month() const
       {
           return m_month; 
       }

   private:
       int m_day, m_month, m_year;

   public:   
       mutable int m_debug_cache_value;
  };

   int main()
   {
       const Date date{};
       date.m_debug_cache_value = 365;
   }
 #+END_SRC

*** Constructor and destructor of classes
 The ~constructor~ and ~destructor~ are in the category of ~non-static member functions~. The instantiation of a class object is performed by the ~constructor~ of the class, while the end of life of the object is performed by the ~destructor~ of the class.

 There is a special type of ~constructor~ called ~default constructor~ which will be discussed in ~special member functions~. In short, a ~constructor~ that can be called without taking any parameters is called a ~default constructor~.

**** Constructor
 If any class object, regardless of its type, is alive, it was brought to life by a ~constructor~. There is no exception to this rule in C++. Every object is instantiated by a call to a ~constructor~ function. After the ~constructor~ is called, the class object becomes available, which means that the memory space allocated for that class object is no longer a pile of garbage, but is now filled with values that can be used by the class. This typically means initializing the ~non-static data members~ of the class.

 ~Constructor~:
 - is ~non-static member function~ (not allowed to be ~static~). 
 - is ~non-const member functions~ (not allowed to be ~const~). 
 - has ~this pointer~.
 - cannot be ~global function~.
 - must have the same name with the class.
 - doesn't have concept of a return value.
 - can be ~overloaded~.
 - can be ~public~, ~private~ and ~protected~.  
 - cannot be called by objects using ~.~ and ~->~ operators.
 - is a ~special member function~ if it is the ~default constructor~.

 Declaration of a ~constructor~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1(); // Has to have the same name with the class.
   };
 #+END_SRC

 A class can have multiple ~constructors~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // These are valid function overloads.
       C1();
       C1(int);
   };
 #+END_SRC

 ~Constructors~ cannot be ~static~ or ~const~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       static C1(); // Invalid.
       C1(int) const; // Invalid.
   };
 #+END_SRC

 ~Constructors~ don't have to be ~public~ they can also be ~private~ or ~protected~:
 #+BEGIN_SRC C++
   class C1
   {
   // This is valid, but when we try to create an instance of the class,
   // access control will fail and we will get a syntax error.
   private:
       C1();
       C1(int);
       C1(int);
   };
 #+END_SRC

 Definition and declaration of a ~constructor~ can be in ~class definition~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1()
       {
           // These are valid.
           mx = 10;
           this->mx = 10;
           C1::mx = 10;
       }
   private:
       int mx, my;
   };
 #+END_SRC

 Definition and declaration of a ~constructor~ can also be separate:
 #+BEGIN_SRC C++
   // c1.h
   class C1
   {
   public:
       C1(int);

   private:
       int mx, my;
   };
  
   // c1.cpp
   // #include "c1.h"
   C1::C1(int x)
   {
       mx = x;
       this->mx = x;
       C1::mx = x;
   }
 #+END_SRC

 ~Constructors~ can't be called by objects using ~.~ and ~->~ operators:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1();
   };

   int main()
   {
       C1 c1;

       c1.C1(); // This is invalid.
   }
 #+END_SRC

**** Destructor
 Every class object that is instantiated has a lifespan/lifetime, and its lifetime will end at some point in the program's runtime. End-of-life class objects are deleted with a call to a ~destructor~ function. There is also no exception to this rule in C++. After the call to the ~destructor~, the object's life is completely over and all memory allocated for the object is freed.

 ~Destructor~:
 - is ~non-static member functions~ (not allowed to be ~static~). 
 - is ~non-const member functions~ (not allowed to be ~const~). 
 - has ~this pointer~.
 - cannot be ~global function~.
 - must have the same name with the class and have the prefix ~~~.
 - don't have concept of a return value.
 - cannot have parameters, so it cannot be ~overloaded~.
 - can be ~public~, ~private~ and ~protected~.  
 - can be called manually by objects using ~.~ and ~->~ operators.
 - is a ~special member function~.

 Declaration of a ~destructor~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       ~C1(); // Has to have the same name with the class prefixed by ~.
   };
 #+END_SRC
  
 A class cannot have multiple ~destructors~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       ~C1(); // Valid.
        // Invalid. Destructors cannot have parameters and cannot be overloaded.
       // This means there is no way to have more than one destructor.
       ~C1(int);
   };
 #+END_SRC

~Destructor~ cannot be ~static~ or ~const~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       static ~C1(); // Invalid.
   };

   class C2
   {
   public:
       ~C2() const; // Invalid.
   };
 #+END_SRC

 ~Destructor~ can be ~public~, ~private~ and ~protected~:
 #+BEGIN_SRC C++
   class C1
   {
   // This is valid, but access control will fail
   // when destructor is called and we will get a syntax error.
   private:
       ~C1();
   };
 #+END_SRC

Definition and declaration of a ~destructor~ can be in ~class definition~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       ~C1()
       {
           // These are valid.
           mx = 0;
           this->mx = 0;
           C1::mx = 0;
       }
   private:
       int mx, my;
   };
 #+END_SRC

 Definition and declaration of a ~destructor~ can also be separate:
 #+BEGIN_SRC C++
   // c1.h
   class C1
   {
   public:
       ~C1();

   private:
       int mx, my;
   };
  
   // c1.cpp
   // #include "c1.h"
   C1::~C1()
   {
       mx = 0;
       this->mx = 0;
       C1::mx = 0;
   }
 #+END_SRC

 ~Destructor~ can be called manually by objects using ~.~ and ~->~ operators:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1();
   };

   int main()
   {
       C1 c1;

       // This is valid, but the cases where this is needed are very rare.
       // There is almost only one case and it is about ~placement new~ operator.
       c1.~C1(); 
   }
 #+END_SRC

**** When are the constructor and the destructor called?
 For a ~global class object~:
 - The ~constructor~ is called before the ~main~ function.
 - The ~destructor~ is called after the ~main~ function.

 If there is more than one ~global class object~, the calling order of its ~constructors~ must be the same as the order of object declarations, and the order in which their ~destructors~ are called must be the reverse order of the order in which ~contructors~ are called. This is only valid in the same source file. The order of instantiation of ~global class objects~ defined in different source files is not specified. The term used for this situation is ~static initilization fiasco~.

 Example for a ~global class object~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1()
       {
           std::cout << "C1 default constructor this: " << this << '\n';
       }

       ~C1()
       {
           std::cout << "C1 destructor this: " << this << '\n';
       }
   };

   C1 c1;

   int main()
   {
       std::cout << "main begins\n";
       std::cout << "&c1: " << &c1 << '\n';
       std::cout << "main ends\n";
   }

   /*
       Output: 
       C1 default constructor this: <c1 address>
       main begins
       &c1: <c1 address>
       main ends
       C1 destructor this: <c1 address>
   */
 #+END_SRC

 Example for multiple ~global class object~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1()
       {
           std::cout << "C1 default constructor this: " << this << '\n';
       }

       ~C1()
       {
           std::cout << "C1 destructor this: " << this << '\n';
       }
   };

   C1 c1a;
   C1 c1b;

   int main()
   {
       std::cout << "main begins\n";
       std::cout << "main ends\n";
   }

   /*
       Output: 
       C1 default constructor this: <c1a address>
       C1 default constructor this: <c1b address>
       main begins
       main ends
       C1 destructor this: <c1b address>
       C1 destructor this: <c1a address>
   */
 #+END_SRC

 Example for multiple ~global class object~ in different source files:
 #+BEGIN_SRC C++
   // c1.h
   class C1
   {
   public:
       C1()
       {
           std::cout << "C1 default constructor this: " << this << '\n';
       }

       ~C1()
       {
           std::cout << "C1 destructor this: " << this << '\n';
       }
   };

   // main.cpp
   C1 c1;

   // a.cpp
   C1 c1a;

   // b.cpp
   C1 c1b;

   // In this case, we cannot say anything about initilization order.
   // There is no way to know in which order objects will be created.
 #+END_SRC
 
For a ~static local class object~:
 - The ~constructor~ is called the first time when the function containing the object is called.
 - The ~destructor~ is called after the ~main~ function.

 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1()
       {
	   std::cout << "C1 default constructor this: " << this << '\n';
       }

       ~C1()
       {
	   std::cout << "C1 destructor this: " << this << '\n';
       }
   };

   int f1()
   {
       std::cout << "f1() is called\n";
       // When the program reaches this point, the constructor will be called,
       // and this is the first call to f1(). If f1() gets called more than once,
       // the constructor will not be called again because the object has alreay been created and
       // is still alive (because it has static lifetime).
       static C1 c1;
   }

   int main()
   {
       std::cout << "main begins\n";
       f1();
       f1();
       f1();
       std::cout << "main ends\n";
   }

   /*
       Output: 
       main begins
       f1() is called
       C1 default constructor this: <c1 address>
       f1() is called
       f1() is called
       main ends
       C1 destructor this: <c1 address>
   ,*/
 #+END_SRC

For a ~local/automatic class object~:
 - The ~constructor~ is called when the the program reaches the point where the object is created.
 - The ~destructor~ is called when the scope defining the lifetime of the object ends.

 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1()
       {
           std::cout << "C1 default constructor\n";
       }

       ~C1()
       {
           std::cout << "C1 destructor\n";
       }
   };

   int main()
   {
       std::cout << "main begins\n";

       if (1)
       {
           C1 c1; // The constructor will be called when program reaches this point. c1 is alive after this point.

           std::cout << "main continues\n";

           // The destructor will be called here at the end of scope which c1 object is in.
       }
       std::cout << "main continues\n";

       std::cout << "main ends\n";
   }

   /*
       Output: 
       main begins
       C1 default constructor
       main continues
       C1 destructor
       main continues
       main ends
   */
 #+END_SRC

 Unlike ~static local class objects~, ~local/automatic class objects~ are recreated each time the program enters the ~block/scope~ they are in:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1()
       {
           std::cout << "C1 default constructor\n";
       }

       ~C1()
       {
           std::cout << "C1 destructor\n";
       }
   };

   int main()
   {
       std::cout << "main begins\n";

       for (int i = 0; i < 3; ++i)
       {
           C1 c1; // In each iteration, the constructor is called and c1 gets created.

           // Each time the scope of the for-loop ends, the destructor is called, and c1 gets destroyed.
       }

       std::cout << "main ends\n";
   }

   /*
       Output: 
       main begins
       C1 default constructor
       C1 destructor
       C1 default constructor
       C1 destructor
       C1 default constructor
       C1 destructor
       main ends
   */
 #+END_SRC

 For a ~dynamic class objects~:
 - The ~constructor~ is called when one of the ~new expressions/operators~ is used.
 - The ~destructor~ is called when one of the ~delete expressions/operators~ is used.

# TODO: Probably we need to put this explanations under a seperate title?
 The ~new expressions~ and ~delete expressions~ are not equivalents of ~malloc~ and ~free~. The ~malloc~ and ~free~ functions are used to allocate and deallocate a memory space. The ~new expressions~ and ~delete expressions~ are used to create and destroy ~class objects~ with ~dynamic lifetime~. 

 When a ~new expression~ is used (in order):
  - The function ~void* operator new(std::size_t)~ is called. The ~operator new~ function allocates a memory space (possibly using ~malloc~) for the object. It returns this address if the allocation succeeds, or throws an ~exception~ of type ~std:bad_alloc~ if it fails.
  - The address returned from ~operator new~ function is then ~casted~ from ~void*~ to the address of the ~class type~ and the ~constructor~ of the class is called for that address.
  - The allocated address is returned to the caller.

 When a ~delete expression~ is used (in order):
  - The ~destructor~ of the class is called for the object.
  - The function ~void operator delete(void*)~ is called with the address of the object (which is allocated by ~operator new~ function). The ~operator delete~ function deallocates the memory space (possibly using ~free~).

 The ~operator new~ and ~operator delete~ functions are part of the C++ standard library.

 What ~new expressions~ and ~delete expressions~ do:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1();
   };

   int main()
   {
       //  Memory is allocated for the object.
       // C1* address_obj = (C1*)operator new(sizeof(C1));
       // The constructor is called with the allocated address of the object.
       // Normally, we cannot call the constructor manually but the compiler can do it.
       // address_obj->constructor(); 
       // The allocated address is returned to the caller.
       // c1 = address_obj;
       C1* c1 = new C1;

       // The destructor is called for the object.
       // c1->~C1();
       // The operator delete function is called with the allocated address of the object.
       // operator delete(c1);
       delete c1;
   }
 #+END_SRC

 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1()
       {
           std::cout << "C1 default constructor this: " << this << '\n';
       }

       ~C1()
       {
           std::cout << "C1 destructor this: " << this << '\n';
       }

       void f1()
       {
           std::cout << "f1() is called\n";
       }
   };

   int main()
   {
       std::cout << "main begins\n";
      
       C1* c1 = new C1;
       
       c1->f1();

       delete c1;
      
       std::cout << "main ends\n";
   }

   /*
       Output: 
       main begins
       C1 default constructor this: <c1 address>
       f1() is called
       C1 destructor this: <c1 address>
       main ends
   */
 #+END_SRC

 The ~pointer~ and ~reference~ types do not cause the constructor and destructor to be called:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1()
       {
           std::cout << "C1 default constructor\n";
       }

       ~C1()
       {
           std::cout << "C1 destructor\n";
       }
   };

   int main()
   {
       // The constructor will be only called when c1 gets created in the first line.
       C1 c1;
       // c1p and c1p are just pointer/reference types, they don't directly represent the class.
       // No constructor/destructor will be called for c1p and c1r.
       C1* c1p = &c1; 
       C1& c1r = c1;

      // The destructor for c1 will be called here. Nothing will happen for c1p and c1r.
   }
 #+END_SRC

 For arrays of ~class objects~, the ~constructor~ and ~destructor~ are called separately for each ~class object:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1()
       {
           std::cout << "C1 default constructor this: " << this << '\n';
       }

       ~C1()
       {
           std::cout << "C1 destructor this: " << this << '\n';
       }

   private:
       char m_buf[16]{};
   };

   int main()
   {
       C1 c1[5];
   }

   /*
       Output: 
       C1 default constructor this: <c1 address>
       C1 default constructor this: <c1 address + 16>
       C1 default constructor this: <c1 address + 32>
       C1 default constructor this: <c1 address + 48>
       C1 default constructor this: <c1 address + 64>
       C1 destructor this: <c1 address + 64>
       C1 destructor this: <c1 address + 48>
       C1 destructor this: <c1 address + 32>
       C1 destructor this: <c1 address + 16>
       C1 destructor this: <c1 address>
   */
 #+END_SRC

**** When the default constructor is called?
 Normally, ~default initialized~ objects are created with ~garbage value~, but ~default initialized~ class objects are created with a call to the ~default constructor~. The ~non-static data members~ of the class can still have garbage value if they are not initialized in the ~default constructor~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1()
       {
           std::cout << "C1 default constructor\n";
       }

   private:
       int mx;
   };

   int main()
   {
       int x; // x is default initialized and have garbage value.
       C1 c1; // c1 is default initialized and the default constructor is called.

       c1.mx; // c1.mx still has a garbage value because it is not initialized in the default constructor.
   }
 #+END_SRC

 ~value initialized~ class objects are created with a call to the ~default constructor~. The ~non-static data members~ of the class will be also ~zero initialized~ before the ~default constructor~ is called. This means built-in types like ~int~ will be set to ~0~, and pointers will be set to ~nullptr~.
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1()
       {
           std::cout << "C1 default constructor\n";
       }

   private:
       int mx;
  };

   int main()
   {
       int x{}; // x is value initialized and set to 0. 
       C1 c1{}; // c1 is value initialized.

       c1.mx // c1.mx is also value initialized before the default constructor is called, meaning it is zero initialized.
   }
 #+END_SRC

 ~direct initialization~ without providing a value is not possible because of ~most vexing parse~. The compiler might give a warning:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1()
       {
           std::cout << "C1 default constructor\n";
       }
   };

   int main()
   {
       int x(5); // x is direct initialized and set to 5.
       // Valid but doesn't mean direct initilization.
       // Because of the most vexing parse, the compiler understand this as a function declaration.
       int x();
       // It is same for the class objects. Valid but doesn't mean direct initilization.
       // Because of the most vexing parse, the compiler understand this as a function declaration.
       // The default constructor is not called because there is no object instantiation here.
       C1 c1();
   }
 #+END_SRC

 The ~default constructor~ is also called when the elements of an array are ~class objects~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1()
       {
	   std::cout << "C1 default constructor\n";
       }
   };

   int main()
   {
       C1 c1[5]; // The default constructor is called one by one for each element of array c1.
   }
 #+END_SRC

  It is also important to understand that classes do not have to have a ~default constructor~. The ~default constructor~ may not be declared. There are different rules for cases where the ~default constructor~ is not declared, which will be discussed later.

**** How non-default constructors can be called?
 A ~non-default constructor~ is any ~constructor~ that requires one or more arguments to be passed when an object is created. These ~constructors~ differ from the ~default constructor~, which either takes no arguments or has all default values for its parameters. ~non-default constructors~ are explicitly defined by the programmer and are used to initialize objects with specific values.

 ~non-default constructors~ can be called when an object is created with ~direct initialization~, ~direct-list initialization~ and ~copy initialization~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1(int x)
       {
	   std::cout << "C1(int x) x: " << x << '\n';
       }

       C1(int x, int y)
       {
	   std::cout << "C1(int x, int y) x: " << x << " y: " << y << '\n';
       }
   };

   int main()
   {
       C1 c1(10); // c1 is direct initialized. C1(int x) constructor is called.
       C1 c1{20}; // c1 is direct-list initialized. C1(int x) constructor is called.
       C1 c1 = 30; // c1 is copy initialized. C1(int x) constructor is called.

       // C1(int x, int y) constructor is called for all of these.
       C1 c1(1, 2);
       C1 c1{3, 4};
       C1 c1 = {5, 6};
   }
 #+END_SRC

**** Constructor initializer list
 The ~constructor~ initializes the ~non-static data members~ of the class object it creates. The syntax used by ~constructors~ to initialize ~non-static data members~ is called the ~constructor initializer list~.

 Usage of the ~constructor initializer list~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // This means that when this constructor is called, mx, my, and md are initialized to 10, 20, and 8.8 respectively,
       // before the constructor's body is executed.
       C1() : mx(10), my(20), md{ 8.8 }
       {
           // mx, my and md are already initialized here.
           mx; // 10
           my; // 20
           md; // 8.8
       }

   private:
       int mx, my;
       double md;
   };
 #+END_SRC

 Not all ~non-static data members~ of the class have to be initialized with the ~constructor initializer list~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1() : mx{ 10 }
       {
           // Note that these are assignments, not initializations. 
           my = 20;
           md = 8.8;
       }

   private:
       int mx, my;
       double md;
   };
 #+END_SRC

 ~non-static data members~ are initialized in ~declaration order~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // mx will be initialized before my because mx is declared first.
       C1() : my{ 10 }, mx{ 20 }
       {

       }

   private:
       // mx is declarared before my;
       int mx, my;
   };
 #+END_SRC

 When using the constructor initializer list, the ~constructor~ block must exist even if it is empty:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1() : mx(10), mx(20); // Invalid.
       C1() : mx(10), mx(20) {} // Valid, the constructor block must exist even it is empty.

   private:
       int mx, my;
   };
 #+END_SRC

 The ~constructor initializer list~ can also be used with ~non-default constructors~:
 #+BEGIN_SRC C++
   // date.h
   class Date
   {
   public:
       Date(int day, int mon, int year);

   private:
       int m_day, m_mon, m_year;
   };

   // date.cpp
   Date::Date(int day, int mon, int year) : m_day{ day }, m_mon { mon }, m_year{ year } {}

   // main.cpp
   int main()
   {
       Date date(19, 9, 2024);
   }
 #+END_SRC

 ~reference~ and ~const~ types must be initialized with the ~constructor initializer list~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // Invalid, mr is a reference and not initialized with the constructor initializer list.
       // mx is a const variable and not initialized with the constructor initializer list.
       // Reference and const types cannot be default initialized.
       C1() : mx{ 10 }
       {

       }

   private:
       int& mr;
       const int mx;
       int mx;
   };
 #+END_SRC


*** Special member functions
 ~special member functions~ are ~member functions~ related to a very important group of functions of a class. There are 6 different ~special member functions~.

 These ~special member functions~ are:
 - ~default constructor~
 - ~destructor~
 - ~copy constructor~
 - ~move constructor~ (C++11)
 - ~copy assignment~
 - ~move assignment~  (C++11)

~special member functions~ can be in one of the following states:
 - ~not declared~
 - ~implicitly declared~
   + ~implicitly declared~ and ~defaulted~
   + ~implicitly declared~ and ~deleted~
 - ~explicitly/user declared~
   + ~explicitly/user declared~ and ~defined~
   + ~explicitly/user declared~ and ~defaulted~
   + ~explicitly/user declared~ and ~deleted~

 The definitions of these functions can be written by the compiler if certain conditions are met. These functions, which are generated automatically by the compiler are called ~defaulted functions~. Only ~special member functions~ can be ~defaulted~.

 ~special member functions~ can be ~defaulted~ in 2 different ways:
 - The compiler can declare and define the ~special member functions~ ~implicitly~ according to the rules of the language.
 - We can ~explicitly~ ask the compiler to write the code for the ~special member functions~.

 ~special member functions~ can be ~deleted~ in 2 different ways:
 - The compiler can ~delete~ the ~special member functions~ ~implicitly~ according to the rules of the language.
 - We can ~explicitly~ ask the compiler to ~delete~ the ~special member functions~.

 ~deleted function~ means that the function exists, but calling it would cause a syntax error. ~deleted functions~ are distinguished from functions that were ~not declared~. They are included in the ~function overload resolution~ process. With some exceptions, ~special member functions~, ~class member functions~ and ~global functions~ can be ~deleted~, but most of the time ~deleted functions~ are about ~special member functions~.

 Calling ~deleted functions~ is invalid:
 #+BEGIN_SRC C++
  void func(int) = delete;

  int main()
  {
      func(10); // Invalid. Deleted functions cannot be referenced.
  }
 #+END_SRC
 
 ~deleted functions~ are included in ~function overload resolution~:
 #+BEGIN_SRC C++
  void func(int) = delete;
  void func(float);

  int main()
  {
      f1(2.3); // Valid, func(float) will be called.
      f1(2); // Invalid, func(int) will be chosen but deleted functions cannot be referenced.
  }
 #+END_SRC

 There are some rules defining how each ~special member function~ should be ~defaulted~ by the compiler. When a ~special member function~ is defaulted by the compiler violates the rules of the language, the compiler ~deletes~ the function it should have ~defaulted~ to instead of throwing a syntax error.

 Cases that can cause a syntax error when the compiler tries to ~default~ a ~special member function~:
 - If some of the ~non-static data members~ of a class cannot be ~default initialized~.
 - If there is a call to a function that does not exist / ~non declared~.
 - If there is a call to a ~private~ function.
 - If there is a call to a ~deleted~ function.

**** Default constructor
 For a ~constructor~ to be the ~default constructor~, it must either take no parameters or all its parameters must take default arguments. In other words, a ~constructor~ is the ~default constructor~ if it can be called without passing any arguments. The ~default constructor~ is one of the ~special member functions~.

 Example for the ~default constructor~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1(); // Default constructor.
   };

   class C2
   {
   public:
       C2(int = 0); // Default constructor.
   };
#+END_SRC

 The ~default constructor~ is ~defaulted~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1() = default; // The default constructor is user-declared and defaulted.
   };
 #+END_SRC

 The ~default constructor~ is ~implicitly deleted~:
 #+BEGIN_SRC C++
   class C1
   {
   // The default constructor is implicitly declared and deleted.
   public:
       const int x;
   };

   int main()
   {
       C1 c1; // Invalid. The default constructor is deleted and cannot be called.
   }
 #+END_SRC

 The ~default constructor~ is ~deleted~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1() = delete; // The default constructor is user declared and deleted.
   };
 #+END_SRC

 ~default constructor~ which is ~defaulted~ by the compiler must be:
 - ~non-static~
 - ~inline~ (because it will be defined in ~class definition~, meaning it is implicitly ~inline~)
 - ~public~
 function of a class.

 The compiler will generate code for a ~default constructor~ that ~default initializes~ all ~non-static data members~. If there is an ~explicitly declared~ constructor (it doesn't have to be ~default constructor~) the compiler will not ~default~ a ~default constructor~.

 The ~default constructor~ will be ~defaulted~ by the compiler because there is no syntax error and it is not ~explicitly declared~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // The compiler will generate something like this as a default constructor. All non-static data members are default initialized.
       // C1() : ax(), bx(), cx()
       // {
              // The compiler can also add extra code depending on its implementation.
       // }
   private:
       int ax;
       double bx;
       char* cx;
   };
 #+END_SRC

 The ~default constructor~ will be ~deleted~ because ~const~ objects cannot be ~default initialized~:
 #+BEGIN_SRC C++
   class C1
   {
   // The default constructor will be deleted by compiler because const objects cannot be default initialized.
   // Instead of throwing a syntax error the compiler deletes the default constructor.
   private:
       const int x;
   };

   int main()
   {
       C1 c1; // This is a syntax error. Deleted functions cannot be referenced.
       return 0;
   }
 #+END_SRC

 The ~default constructor~ will be ~deleted~ because the ~non-static data member~ does not have ~default constructor~ and cannot be ~default initialized~:
 #+BEGIN_SRC C++
   class C2
   {
   public:
       // There is an explicily declared constructor, meaning that this class does not have a default constructor.
       // The default constructor is non-declared.
       C2(int);
   };

   class C1
   {
   // The default constructor will be deleted because c2 does not have a default constructor so cannot be default initialized.
   private:
       C2 c2;
   };

   int main()
   {
       C1 c1; // Syntax error. Attempting to reference a deleted function.
       
       return 0;
   }
 #+END_SRC

**** Copy constructor
 The ~copy constructor~ is called when a ~class object~ instantiated by taking its value from another ~class object~ of the same type. The ~copy constructor~ has the same name as the class and takes a ~const L-value reference~ parameter of that class type.
 
 ~explicitly declared copy constructor~ example:
  #+BEGIN_SRC C++ :includes <iostream>
   class Date
   {
   public:
       Date(int d, int m, int y) : md{ d }, mm{ m }, my{ y } { }
       Date(const Date& other) : md{ other.md }, mm{ other.mm }, my{ other.my }
       {
           std::cout << "this: " << this << " &other: " << &other << '\n';
       }
   private:
       int md{ 1 }, mm{ 1 }, my{ 1990 };
   };

   int main()
   {
       Date dx{ 12, 8, 1999 };
       Date dy = dx;

       std::cout << "&dy: " << &dy << " &dx: " << &dx << '\n';
   }

   /*
        'this pointer' will be address of dy and address of other will be equal to address of dx.
        Output:
        this: <address of this> &other: <address of other>
        dy: <address of dy> dx: <address of dx>
   */
 #+END_SRC

 In some cases the compiler can make certain optimizations so that the ~copy constructor~ is not called, but leaving these cases aside for now, typically the ~copy constructor~ is called in the following scenarios.
 
 When a ~class object~ is instantiated directly by another ~class object~:
#+BEGIN_SRC C++
  class C1
  {
      // The copy constructor is implicitly declared and defaulted.  
  };

  int main()
  {
      C1 c1a;
      // The copy constructor will be called for c1b. c1b will be instantiated by taking its value from c1a.
      // When the copy constructor is called for c1b, 'this pointer' will be address of c1b and const reference parameter will be c1a.
      C1 c1b{ c1a };
      // The copy constructor will be called for c1c. c1c will be instantiated by taking its value from c1b.
      C1 c1c = c1b;
  }
 #+END_SRC

 Calling a function with a value (not reference or pointer) causes the ~copy constructor~ to be called:
#+BEGIN_SRC C++
  class C1
  {
      // The copy constructor is implicitly declared and defaulted.  
  };

  void func(C1 param);

  int main()
  {
      C1 c1;
      // When func() is called with c1, C1 param will be instantiated by calling the copy constructor.
      func(c1);
  }
 #+END_SRC

 Returning a value from a function (not reference or pointer) causes the ~copy constructor~ to be called:
#+BEGIN_SRC C++
  class C1
  {
      // The copy constructor is implicitly declared and defaulted.  
  };

  C1 func()
  {
      C1 c1;
      // When func() is returned, the return object will be instantiated by calling the copy constructor and it will take its value from c1.
      return c1; // c1 will be copied to the return object and will be desctructed at the end of scope.
  }

  int main()
  {
      C1 c1 = func();
  }
 #+END_SRC

 ~copy constructor~ which is ~defaulted~ by the compiler must be:
 - ~non-static~
 - ~inline~ (because it will be defined in ~class definition~, meaning it is implicitly ~inline~)
 - ~public~
 function of a class.

 The compiler will generate code for a ~copy constructor~ that initializes all ~non-static data members~ by taking their value from the ~class object~ being copied:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // The compiler will generate something like this as a copy constructor. All non-static data members are initialized by taking their value from other class object. Initilization will be in declaration order as in default constructor.
       // C1(const C1& other) : ax(other.ax), bx(other.bx), cx(other.cx)
       // {
              // The compiler can also add extra code depending on its implementation.
       // }
   private:
       int ax;
       double bx;
       char* cx;
   };
 #+END_SRC

 Usually the ~copy constructor~ which is ~defaulted~ by the compiler will be sufficient for our needs, but there are some cases where the ~copy constructor~ needs to be ~explicitly defined~ to prevent logical errors that can cause memory/resource leaks. We can say that if the ~destructor~ is ~explicitly defined~ for a class, typically the ~copy constructor~ also needs to be ~explicitly defined~ because most of the time it means we have some memory/resource to manage.

 If pointer or reference ~non-static data members~ are stored inside of a class, we might need to use ~explicitly defined~ ~copy constructor~:
 #+BEGIN_SRC C++ :includes <cstdio> <stdexcept>
   class Logger
   {
   public:
       // The copy constructor is defaulted by compiler.
       
       Logger(const char* file_name) : m_f(std::fopen(file_name, "w"))
       {
           if (!m_f)
           {
               throw std::runtime_error{ "Cannot create the file!" };
           }
       }

       void log(const char* p)
       {
           std::fprintf(m_f, "%s\n", p);
       }

       ~Logger()
       {
           if (m_f)
           {
               std::fclose(m_f);
           }
       }

   private:
       FILE* m_f;
   };

   // When this function is called with a Logger object, values of that Logger object will be copied to object 'y' by the defaulted copy constructor. The problem is the Logger class has a pointer data member(m_f) and it will be also copied, meaning the same pointer will be used by 2 different objects ('caller object' and 'y'). This will cause a problem when the desctructor is called for those objects.
   void func(Logger y)
   {
       // This will also write to file 'log.txt' because file(m_f) is copied from the caller object.
       y.log("y");

       // The destructor will be called here for 'y', and the file(m_f) will be closed in the desctructor.
   }

   int main()
   {
       Logger x{ "log.txt" };

       // This will write to file 'log.txt'
       x.log("x");

       // Object 'x' will be copied to object 'y' (parameter of the func()).
       func(x);

       // From this point, the file pointer(m_f) inside object 'x' has become dangling pointer, and it will cause an undefined behaviour if we use it again.

       // The destructor will be called here for object 'x', but the file(m_f) is already closed/freed when the destructor of 'y' object was called, because the value of 'm_f' was copied to object 'y' when we called the func().
       // This will cause an undefined behaviour because we double free.
   }
 #+END_SRC

 ~explicitly defined copy constructor~ to make deep-copy of the pointer ~data member~ instead of shallow-copy:
#+BEGIN_SRC C++ :includes <iostream> <stdexcept> <cstdlib> <cstring>
  class String
  {
  public:
      String() = default;
      String(const char* str) : m_len{ std::strlen(str) }, m_str{ static_cast<char*>(malloc(m_len + 1)) }
      {
          if (!m_str)
          {
              throw std::runtime_error{ "Cannot allocate memory!" };
          }

          std::strcpy(m_str, str);
      }

      // Explicitly defined copy construtor to make deep-copy instead of shallow-copy to prevent copying pointers.
      String(const String& other) : m_len{ other.m_len }, m_str{ static_cast<char*>(malloc(m_len + 1)) }
      {
          if (!m_str)
          {
              throw std::runtime_error{ "Cannot allocate memory!" };
          }

          std::strcpy(m_str, other.m_str);
      }

      void print() const
      {
          std::cout << '[' << m_str << "]\n";
      }

      std::size_t length() const
      {
          return m_len;        
      }

      ~String()
      {
          std::free(m_str);
      }

  private:
      std::size_t m_len;
      char* m_str;
  };

  void func(String y)
  {
      std::cout << "func() is called\n";
      y.print();

      // The desctructor for object 'y' will be called here and the memory allocated for object 'y' will be freed.
  }

  int main()
  {
      String x{ "Hello world!" };

      x.print();

      func(x);

      x.print();
      std::cout << x.length();

      // The desctructor for object 'x' will be called here and the memory allocated for object 'x' will be freed.
      // In this case there is no double free because explicitly defined copy constructor didn't copy the pointer instead it allocated new memory space for the new String object. Both of the objects will print "Hello world!" but they store it in different memory spaces.
  }
 #+END_SRC

**** Copy assignment operator/function
The ~copy assignment operator~ is called when a ~class object~ is assigned to another ~L-value class object~ of the same type. There is no instantiation when the ~copy assignment operator~ is called, because to assign one ~class object~ to another ~class object~, both ~class objects~ must already be instantiated. The ~copy assignment operator~ takes a ~const L-value reference~ parameter of that class type and ~returns~ ~L-value reference~ of the same class type.

~copy assignment operator~ which is ~defaulted~ by the compiler must be:
 - ~non-static~
 - ~inline~ (because it will be defined in ~class definition~, meaning it is implicitly ~inline~)
 - ~public~
 function of a class.

 #+BEGIN_SRC C++
   class C1
   {
   public:
        // The compiler will generate something like this as a copy assignment operator. All non-static data members are assigned by copying their values from other class object's non-static data members. Assignments will be in declaration order.
       //C1& operator=(const C1& other)
       //{
       //    ax = other.ax;
       //    bx = other.bx;
       //
       //    return *this;
       //}

   private:
       int ax;
       int bx;
   };
 #+END_SRC

 ~explicitly declared copy assignment operator~ example:
  #+BEGIN_SRC C++ :includes <iostream>
    class Date
    {
    public:
        Date(int d, int m, int y) : md{ d }, mm{ m }, my{ y } { }
        Date& operator=(const Date& other)
        {
            md = other.md;
            mm = other.mm;
            my = other.my;
            
            std::cout << "this: " << this << " &other: " << &other << '\n';

            return *this;
        }
    private:
        int md{ 1 }, mm{ 1 }, my{ 1990 };
    };

    int main()
    {
        Date dx{ 12, 8, 1999 };
        Date dy{ 9, 8, 1966 };

        dy = dx;
        
        std::cout << "&dy: " << &dy << " &dx: " << &dx << '\n';
    }

    /*
         'this pointer' will be address of dy and address of other will be equal to address of dx.
         Output:
         this: <address of this> &other: <address of other>
         dy: <address of dy> dx: <address of dx>
    ,*/
 #+END_SRC

 Similar to the ~copy constructor~, there are some cases where the ~copy assignment operator~ also needs to be ~explicitly defined~ to prevent logical errors which can cause memory/resource leaks. Similarly, we can say that if the ~destructor~ is ~explicitly defined~ for a class, typically the ~copy assignment operator~ also needs to be ~explicitly defined~ because most of the time it means we have some memory/resource to manage.

 ~explicitly defined copy assignment~ to make deep-copy of the pointer ~data member~ instead of shallow-copy:
 #+BEGIN_SRC C++ :includes <iostream> <stdexcept> <cstdlib> <cstring>
   class String
   {
   public:
       String() = default;
       String(const char* str) : m_len{ std::strlen(str) }, m_str{ static_cast<char*>(malloc(m_len + 1)) }
       {
           if (!m_str)
           {
               throw std::runtime_error{ "Cannot allocate memory!" };
           }

           std::strcpy(m_str, str);
       }

       // Explicitly defined copy assignment operator to make deep-copy instead of shallow-copy to prevent copying pointers.
       String& operator=(const String& other)
       {
           // Return directly if the object is assigned to itself.
           if (this == &other)
           {
               return *this;
           }

           // This is just for demonstration.
           // We free already existing resource and reallocate for new string.
           std::free(m_str);

           m_len = other.m_len;
           m_str = static_cast<char*>(malloc(m_len + 1));

           if (!m_str)
           {
               throw std::runtime_error{ "Cannot allocate memory!" };
           }

           std::strcpy(m_str, other.m_str);

           return *this;
       }

       void print() const
       {
           std::cout << '[' << m_str << "]\n";
       }

       std::size_t length() const
       {
           return m_len;        
       }

       ~String()
       {
           std::free(m_str);
       }

   private:
       std::size_t m_len;
       char* m_str;
   };

   int main()
   {
       String x{ "Hello world!" };
       String y{ "y" };

       // The copy assignment will be called for object 'x'.
       x = y;

       x.print();

       // The desctructor for object 'x' will be called here and the memory allocated for object 'x' will be freed.
   }
 #+END_SRC

**** Move constructor
 The ~move constructor~ is called when a ~class object~ instantiated by transfering/stealing its value from another ~class object~ of the same type. The ~move constructor~ has the same name as the class and takes a ~R-value reference~ parameter of that class type. Unlike the ~copy constructor~, the ~move constructor~ does not copy values but moves/transfers/steals them.

 ~move constructor~ which is ~defaulted~ by the compiler must be:
 - ~non-static~
 - ~inline~ (because it will be defined in ~class definition~, meaning it is implicitly ~inline~)
 - ~public~
 function of a class.

 The compiler will generate code for a ~move constructor~ that initializes all ~non-static data members~ by stealing their value from the ~class object~ being moved:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // The compiler will generate something like this as a move constructor. All non-static data members are initialized by stealing their value from other class object. Initilization will be in declaration order as in other constructors. After the object is instantiated the move constructor sets transfered/stealed values of the other object to valid but unspecified state. Additionaly, if a non-static data member is another class object its move constructor will also be called. In this example, the move constructor of std::string (cx) object will be called. To be able to call the move constructor for cx std::move is needed because other.cx is L-value expression and it must be converted to R-value reference by using std::move to call the move constructor. If we do not convert it to R-value reference by using std::move the copy constructor would be called instead of the move constructor.
       // C1(const C1& other) : ax(other.ax), bx(other.bx), cx(std::move(other.cx))
       // {
              // other.ax = 0;
              // other.bx = 0;
              // The compiler can also add extra code depending on its implementation.
       // }
   private:
       int ax;
       double bx;
       std::string cx;
   };
 #+END_SRC

~explicitly defined move constructor~ to move the object instead of copying:
 #+BEGIN_SRC C++ :includes <iostream> <stdexcept> <cstdlib> <cstring>
   class String
   {
   public:
       String() = default;
       String(const char* str) : m_len{ std::strlen(str) }, m_str{ static_cast<char*>(malloc(m_len + 1)) }
       {
           if (!m_str)
           {
               throw std::runtime_error{ "Cannot allocate memory!" };
           }

           std::strcpy(m_str, str);
       }

       // Explicitly defined move construtor to move the object instead of making deep copy. 
       String(String&& other) : m_len{ other.m_len }, m_str{ other.m_str }
       {
           // m_str and m_len values are stealed from other.m_str and other.m_len.
           // We also set other.m_str and other.m_len to valid but unspecified state (usually 0, nullptr)
           // so the destructor will not be called for the moved object and if it is possible it can be used
           // later by assigning another object etc.
           other.m_str = nullptr;
           other.m_len = 0;
       }
       
       void print() const
       {
           std::cout << '[' << m_str << "]\n";
       }

       std::size_t length() const
       {
           return m_len;        
       }

       ~String()
       {
           // This check is needed after we implement the move constructor because if the object is moved the destructor should not be called for the object.
           if (m_str)
           {
               std::free(m_str);
           }
       }

   private:
       std::size_t m_len;
       char* m_str;
   };

   String func()
   {
       String str{ "func" };
       return str;
   }

   int main()
   {
       // The move constructor will be called for object 'x', because the return value of func() is R-value.
       // First, the constructor will be called for str{ "func" } then its resources will be moved the
       // objext 'x' by calling x's move constructor.
       String x = func();

       x.print();

       // The desctructor for object 'x' will be called here and the memory allocated for object 'x' will be freed.
   }
 #+END_SRC

**** Move assignment operator/function
The ~move assignment operator~ is called when a ~class object~ is assigned to another ~R-value class object~ of the same type. There is no instantiation when the ~move assignment operator~ is called, because to assign one ~class object~ to another ~class object~, both ~class objects~ must already be instantiated. The ~move assignment operator~ takes a ~R-value reference~ parameter of that class type and ~returns~ ~L-value reference~ of the same class type.

~move assignment operator~ which is ~defaulted~ by the compiler must be:
 - ~non-static~
 - ~inline~ (because it will be defined in ~class definition~, meaning it is implicitly ~inline~)
 - ~public~
 function of a class.

 #+BEGIN_SRC C++
   class C1
   {
   public:
        // The compiler will generate something like this as a move assignment operator. All non-static data members are assigned by stealing their values from other class object's non-static data members. Assignments will be in declaration order.
       //C1& operator=(C1&& other)
       //{
       //    ax = other.ax;
       //    bx = other.bx;
       //
       //    other.ax = 0;
       //    other.bx = 0;
       //
       //    return *this;
       //}

   private:
       int ax;
       int bx;
   };
 #+END_SRC

 ~explicitly defined move assignment~ to move the object instead of copying:
 #+BEGIN_SRC C++
   class String
   {
   public:
       String() = default;
       String(const char* str) : m_len{ std::strlen(str) }, m_str{ static_cast<char*>(malloc(m_len + 1)) }
       {
           if (!m_str)
           {
               throw std::runtime_error{ "Cannot allocate memory!" };
           }

           std::strcpy(m_str, str);
       }

       // Explicitly defined move assignment to move the object instead of making deep copy. 
       String& operator=(String&& other)
       {
           // Return directly if the object is assigned to itself.
           if (this == &other)
           {
               return *this;
           }

           // Free the resource we already have first.
           std::free(m_str);

           // Steals the values of other
           m_str = other.m_str;
           m_len = other.m_len;
           other.m_str = nullptr;
           other.m_len = 0;

           return *this;
       }

       void print() const
       {
           std::cout << '[' << m_str << "]\n";
       }

       std::size_t length() const
       {
           return m_len;        
       }

       ~String()
       {
           // This check is needed after we implement the move constructor and move assignment because if the object is moved the destructor should not be called for the object.
           if (m_str)
           {
               std::free(m_str);
           }
       }

   private:
       std::size_t m_len;
       char* m_str;
   };

   int main()
   {
       String x{ "x" };

       // The move assignment operator of 'x' will be called and the resources of String{ "y" } object will be transfered to 'x'.
       x = String{ "y" };

       x.print();

       // The desctructor for object 'x' will be called here and the memory allocated for object 'x' will be freed.
   }
 #+END_SRC

**** When special member functions are defaulted, deleted or not declared by the compiler?
| User declared / Implicitly declared by the compiler | Default constructor | Destructor    | Copy constructor | Copy assignment | Move constructor | Move assignment |
|-----------------------------------------------------+---------------------+---------------+------------------+-----------------+------------------+-----------------|
| /                                                   | <                   |               |                  |                 |                  | >               |
| Nothing                                             | defaulted           | defaulted     | defaulted        | defaulted       | defaulted        | defaulted       |
| Any constructor                                     | not declared        | defaulted     | defaulted        | defaulted       | defaulted        | defaulted       |
| Default constructor                                 | user declared       | defaulted     | defaulted        | defaulted       | defaulted        | defaulted       |
| Destructor                                          | defaulted           | user declared | defaulted        | defaulted       | not declared     | not declared    |
| Copy constructor                                    | not declared        | defaulted     | user declared    | defaulted       | not declared     | not declared    |
| Copy assignment                                     | defaulted           | defaulted     | defaulted        | user declared   | not declared     | not declared    |
| Move constructor                                    | not declared        | defaulted     | deleted          | deleted         | user declared    | not declared    |
| Move assignment                                     | defaulted           | defaulted     | deleted          | deleted         | not declared     | user declared   |

In summary:
- If ~destructor~ is not ~user declared~, it is always ~defaulted~.
- If any ~constructor~ (non-special or special) is ~user declared~, ~default constructor~ is ~not declared~ and otherwise it is ~defaulted~.
- If one of ~destructor~, ~copy constructor~ or ~copy assignment operator~ is ~user declared~, ~move members~ are ~not declared~.
- If one of ~move constructor~ or ~move assignment operator~ is ~user declared~, ~copy members~ are ~deleted~, and other ~move member~ is ~not declared~.

When nothing is ~user declared~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // C1() = default;
       // ~C1() = default;
       // C1(const C1&) = default;
       // C1& operator=(const C1&) = default;
       // C1(C1&&) = default;
       // C1& operator=(C1&&) = default;
   };
 #+END_SRC

When the ~default constructor~ is ~user declared~: 
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1() = default;
       // ~C1() = default;
       // C1(const C1&) = default;
       // C1& operator=(const C1&) = default;
       // C1(C1&&) = default;
       // C1& operator=(C1&&) = default;
   };
 #+END_SRC

When the ~destructor~ is ~user declared~: 
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // C1() = default;
       ~C1() = default;
       // C1(const C1&) = default;
       // C1& operator=(const C1&) = default;
       // Move constructor is not declared.
       // Move assignment operator is not declared.
   };
 #+END_SRC

When the ~copy constructor~ is ~user declared~: 
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // Default constructor is not declared.
       // ~C1() = default;
       C1(const C1&) = default;
       // C1& operator=(const C1&) = default;
       // Move constructor is not declared.
       // Move assignment operator is not declared.
   };
 #+END_SRC

When the ~copy assignment operator~ is ~user declared~: 
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // C1() = default;
       // ~C1() = default;
       // C1(const C1&) = default;
       C1& operator=(const C1&) = default;
       // Move constructor is not declared.
       // Move assignment operator is not declared.
   };
 #+END_SRC

When the ~move constructor~ is ~user declared~: 
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // Default constructor is not declared.
       // ~C1() = default;
       // C1(const C1&) = delete;
       // C1& operator=(const C1&) = delete;
       C1(C1&&) = default;
       // Move assignment operator is not declared.
   };
 #+END_SRC

When the ~move assignment operator~ is ~user declared~: 
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // C1() = default;
       // ~C1() = default;
       // C1(const C1&) = delete;
       // C1& operator=(const C1&) = delete;
       // Move constructor is not declared.
       C1& operator=(C1&&) = default;
   };
 #+END_SRC
 
It is possible to define a ~class~ which cannot be copied or moved:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1();
       C1(int);
       C1(const C1&) = delete;
       C1& operator=(const C1&) = delete;
       // Move constructor and move assignment operator is not declared because copy members are user declared.
       // ~C1() = default;

       // This class cannot be copied or moved. Copy members are deleted by user and move members are not declared.
   };

   int main()
   {
       C1 c1a;
       C1 c1b = c1a; // This is a syntax error. A deleted function(the copy constructor) cannot be referenced.

       return 0;
   }
 #+END_SRC

It is also possible to define a ~class~ which cannot be copied but can be moved:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1();
       C1(int);
       C1(const C1&) = delete;
       C1& operator=(const C1&) = delete;
       C1(C1&&);
       C1& operator=(C1&&);
       // ~C1() = default;

       // This class cannot be copied but can be moved.
   };

   int main()
   {
       C1 c1a;
       C1 c1b = c1a; // This is a syntax error. A deleted function(the copy constructor) cannot be referenced.
       C1 c1c = std::move(c1a); // This is valid. The object can be moved.

       return 0;
   }
 #+END_SRC
 
*** Move Semantics
 ~move semantics~ allows efficient transfer of resources (memory, file handles etc.) from one object to another. It is particularly useful when dealing with expensive-to-copy objects, such as containers or objects that manage dynamic resources. ~R-value references~ enable ~move semantics~ by binding to ~temporary objects~ (~R-value expressions~) that are about to go out of scope. ~move constructor~ and ~move assignment operator~ are used for transfering ownership of resources from one object to another.

Resource to check: [[https://accu.org/conf-docs/PDFs_2014/Howard_Hinnant_Accu_2014.pdf][Everything You Ever Wanted To Know About Move Semantics]]

 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1();

       C1(const C1&); // Copy constructor
       C1(C1&&); // Move constructor

       C1& operator=(const C1&); // Copy assignment
       C1& operator=(C1&&); // Move assignment
   };

   C1 func();

   int main()
   {
       C1 c1a;
       C1 c1b = c1a; // c1a is L-value, copy constructor will be called and resources will be copied from c1a to c1b.
       c1b = c1a; // c1a is L-value, copy assignment will be called and resources will be copied from c1a to c1b.

       C1 c1c = func(); // Return value of func() is R-value, move constructor will be called and resources will be transfered from returned object to c1c.
       c1c = func(); // Return value of func() is R-value, move assignment will be called and resources will be transfered from returned object to c1c.

       return 0;
   }
 #+END_SRC

 It is also possible to transfer the resources of ~L-value expressions~ by converting them to ~R-value references~. ~std::move~ can be used for this:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1() = default;

       C1(const C1&)
       {
           std::cout << "Copy constructor\n";
       }
       
       C1(C1&&)
       {
           std::cout << "Move constructor\n";
       }
   };

   C1 func();

   int main()
   {
       C1 c1a;
       C1 c1b = c1a; // Copy constrcutor will be called.
       C1 c1c = std::move(c1b); // c1b is L-value but we convert it to R-value reference, move constructor will be called and resources will be transfered from c1b to c1.

       return 0;
   }
 #+END_SRC

 ~move semantics~ and ~function overloading~:
 #+BEGIN_SRC C++
   // This overload will be called for L-value expressions.
   void func(const std::string& s)
   {
       std::string str(s); // The copy constructor will be called for str.
   }

   // This overload will be called for R-value expressions.
   void func(std::string&& s)
   {
       // We still need std::move to call the move constructor because even the data type of
       // 's' is R-value reference, the value category of expression 's' is L-value expression.
       std::string str(std::move(s)); // The move constructor will be called.
   }

   int main()
   {
       std::string s(100, '+');

       func(s); // void func(const std::string& s) will be called.
       func(std::string(100, '-')); // void func(std::string&& s) will be called.

       return 0;
   }
 #+END_SRC

 It is not possible to transfer/steal resources of a ~const class object~. ~const object~ means the object will never change in its lifetime, so it cannot be moved:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1() = default;

       C1(const C1&)
       {
           std::cout << "Copy constructor\n";
       }

       C1(C1&&)
       {
           std::cout << "Move constructor\n";
       }
   };

   int main()
   {
       const C1 x;
       // std::move will return const R-value reference type because object 'x' is const. Copy constructor will be choosen in function overload resolution  because according to rules const overload has the priority. So, object 'x' is copied to 'y' instead of being moved
       C1 y = std::move(x);

       return 0;
   }
 #+END_SRC

 It is more about the ~function overload resolution~ rules rather than ~move semantics~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1() = default;
   };

   void func(const C1&)
   {
       std::cout << "void func(const C1&)\n";
   }

   void func(C1&&)
   {
       
       std::cout << "void func(C1&&)\n";
   }

   int main()
   {
       C1 x;
       const C1 cx;

       func(x); // void func(const C1&) will be called.
       func(std::move(x)); // void func(C1&&) will be called.
       func(cx); // void func(const C1&) will be called.
       func(std::move(cx)); // void func(const C1&) will be called.
       
       return 0;
   }
 #+END_SRC

*** Default member initializer / In-class initializer
~default member initializer~ is a way to declare how ~default initialization~ should be done for ~data members~ of classes.

~default member initializer~ will be used for ~data members~ which are not initialized explicitly:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // We do not initialize mx here but compiler will add mx{ 20 } here as default
       // because we declare default member initializer for mx. 
       C1() : my{ 10 } {}
   private:
       int mx{ 20 }; // Default member initializer / In-class initializer
       int my; // No default member initializer. If we don't initialize my explicity it will be default initialized to garbage value.
   };
 #+END_SRC

If a ~data member~ is initialized explicitly ~default member initializer~ will not be used:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // mx will be initialized to 30 and default member initializer will not be used, because mx is not default initialized.
       C1() : mx { 30 } {}
   private:
       int mx{ 20 }; // Default member initializer / In-class initializer
   };
 #+END_SRC

 ~direct-initilization~ syntax cannot be used for ~default member initializer~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1() : my { 30 } {}
   private:
       // int mx(20); // Invalid. Syntax error.
       int my{ 20 }; // Valid.
       int mz = 20 ; // Valid.
   };
 #+END_SRC

*** Delegating Constructor
 Classes can have multiple ~constructors~ with a common code. In such cases, a ~delegating constructor~ can be used to gather the common code into a single ~constructor~.

 #+BEGIN_SRC C++
   class C1
   {
   public:
       // Delegating constructors
       C1(int x) : C1(x, 0, 0) {}
       C1(const char* p) : C1(std::atoi(p), 0, 0) {}

       // This constructor will get called when other 2 constructor is called. It can also be called directly.
       C1(int, int, int)
       {
           
       }
   };
 #+END_SRC
 
 If a ~delegating constructor~ is used for a ~constructor~, the ~non-static data members~ cannot be initialized using ~constructor initializer list~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // Delegating constructor
       C1(int x) : C1(x, 0, 0), mx{ 10 } {} // This is syntax error. If a constructor is a delegating constructor, constructor initializer list cannot be used for initializing non-static data members.
       C1(const char* p) : C1(std::atoi(p), 0, 0) {}

       // This constructor will get called when other 2 constructors are called. It can also be called directly.
       C1(int, int, int)
       {
           
       }

   private:
       int mx;
   };
 #+END_SRC

 There can also be multiple ~delegating constructors~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // This delegating constructor is calling another delegating constructor
       C1(int x) : C1(x, 0) {}
       // This is also delegating constructor
       C1(int x, int y) : C1(x, y, 0) {}

       C1(int x, int y, int z)
       {
           
       }
   };
 #+END_SRC

*** Temporary Objects
 In some cases, even if there is no visible variable in the code, the compiler can create an object according to the rules. Such objects are called ~temporary objects~ and have different lifetimes. Expressions created by ~temporary objects~ are ~PR-value expressions~.

 #+BEGIN_SRC C++ :includes iostream
   class C1
   {
   public:
       C1()
       {
           std::cout << "Default constructor\n";
       }

       C1(int a, int b)
       {
           std::cout << "C1(int a, int b), a = " << a << " b = " << b << '\n';
       }
       
       ~C1()
       {
           std::cout << "Destructor\n";
       }
   };

   void func(const C1&)
   {
       std::cout << "void func(const C1&)\n";
   }

   void func(C1&&)
   {
       std::cout << "void func(C1&&)\n";
   }

   int main()
   {
       C1& r = C1(); // This is a syntax error. C1() is a temporary object and a PR-value expression. PR-value expressions cannot be bound to L-value references.
       // These are valid.
       const C1& cr = C1();
       C1&& rr = C1{ 1, 3 };

       func(C1{}); // If func() is called with a temporary object, the C1&& overload will be called because temporary objects are PR-value expressions.
       
   }
 #+END_SRC

 The life of a ~temporary object~ ends after the ~evaluation of the expression~ in which that ~temporary object expression~ is contained:
 #+BEGIN_SRC C++ :includes iostream
   class C1
   {
   public:
       C1()
       {
           std::cout << "Default constructor, this: " << this << '\n';
       }

       ~C1()
       {
           std::cout << "Destructor, this: " << this << '\n';
       }

       void func()
       {
           std::cout << "void func(), this: " << this << '\n';
       }
   };

   int main()
   {
       std::cout << "main() begins\n";
       C1{}.func();
       // The life of the C1{} (temporary object) has to end immediately in this point of the code. The destructor for C1{} will be called here (after the evaluation of the expression that contains temporary object, C1{}.func()).
       std::cout << "main() ends\n";
   }
 #+END_SRC

 If we want to call a function with an object and never use that object again, we can use ~temporary object~:
 #+BEGIN_SRC C++ :includes iostream vector
   void func(const std::vector<int>& vec)
   {
       
   }

   int main()
   {
       // We don't need ivec after calling func() but it will live until the end of scope.
       std::vector<int> ivec(10, 5);
       func(ivec);

       // We used a temporary object for calling func() and it will be destructed after this expression is evaluated. This prevents scope leakage.
       func(std::vector<int>(10, 5));
   }
 #+END_SRC

**** Life extension
 If a ~temporary object~ is bound to a ~reference~, its lifetime gets extended to the end of the scope of that ~reference~. This is called ~life extension~.

 #+BEGIN_SRC C++ :includes iostream
   class C1
   {
   public:
       C1()
       {
           std::cout << "Default constructor, this: " << this << '\n';
       }

       ~C1()
       {
           std::cout << "Destructor, this: " << this << '\n';
       }

       void func()
       {
           std::cout << "void func(), this: " << this << '\n';
       }
   };

   int main()
   {
       std::cout << "main() begins\n";

       if (1)
       {
           C1&& r = C1{};
           std::cout << "main() continues\n";
           r.func(); // The temporary object C1{} is still alive here because it is bound to a reference 'r'.
           // The destructor for the temporary object will be called here.
       }

       std::cout << "main() ends\n";
   }
 #+END_SRC

*** Reference qualifiers
 Normally the ~non-static member functions~ of a ~class~ can be called both with ~class objects~ whose value category is ~L-value expression~ and with class objects whose value category is ~R-value expression~. However, in some cases, we may want to prevent the function from being called for ~class objects~ with the ~R-value expression~ category, or to create separate implementations for ~class objects~ with the ~L-value expression~ category and class objects with the ~R-value expression~ category. ~Reference qualifiers~ can be used the implement this behaviour.

#+BEGIN_SRC C++ :includes iostream
   class C1
   {
   public:
       // This function can only be called with L-value expressions.
       void f1()&; // & -> L-value reference qualifier
       // This function can only be called with R-value expressions.
       void f2()&&; // & -> R-value reference qualifier
   };

   int main()
   {
       C1 c1;

       // This is valid. c1 is a L-value expression. f1() is L-value reference qualified.
       c1.f1();
       // This is valid. C1{} is a R-value expression. f2() is R-value reference qualified.
       C1{}.f2();
       // This is valid. std::move(c1) is a X-value expression (R-value expression). f2() is R-value reference qualified.
       std::move(c1).f2();

        // This is a syntax error. std::move(c1) is X-value expression (R-value expression). f1() is L-value reference qualified.
       std::move(c1).f1();
       // This is syntax error. C1{} is a R-value expression. f1() is L-value reference qualified.
       C1{}.f1();
       // This is syntax error. c1 is a L-value expression. f2() is R-value reference qualified.
       c1.f2();
   }
 #+END_SRC

 Functions with ~reference qualifiers~ can also be overloeaded:
#+NAME: REFERENCE_QUALIFIER_01 
#+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
   class C1
   {
   public:
       // These are valid overloads.
       void func() &
       {
           std::cout << "void func() &\n";
       }

       void func() const &
       {
           std::cout << "void func() const &\n";
       }

       void func() &&
       {
           std::cout << "void func() &&\n";
       }
   };

   int main()
   {
       C1 c1; 
       const C1 cc1;

       // func() with L-value reference qualified will be called.
       c1.func();
       // func() with const L-value reference qualified will be called.
       cc1.func();
       // func() with R-value reference qualified will be called.
       C1{}.func();
   }
 #+END_SRC

 Output:
 #+RESULTS: REFERENCE_QUALIFIER_01
 #+begin_example
 void func() &
 void func() const &
 void func() &&
 #+end_example

 ~Temporary objects~ are assignable even it is not useful:
#+BEGIN_SRC C++
   class C1
   {

   };

   int main()
   {
       C1 c1; 

       // This is valid and can be prevented by making the class's operator= function L-value reference qualified.
       C1{} = c1;
   }
 #+END_SRC

 Making ~temporary objects~ of a class unassignable:
#+BEGIN_SRC C++
   class C1
   {
   public:
       // This is valid after C++20. Before C++20, reference qualified special member functions cannot be defaulted by the compiler.
       C1& operator=(const C1&) & = default;

       // Before C++20, reference qualified special functions must be defined explicitly.
       // C1& operator=(const C1& other) &
       // {
       //     // ...

       //     return *this;
       // }
   };

   int main()
   {
       C1 c1; 

       // This is invalid now because operator= is L-value reference qualified.
       C1{} = c1;
   }
 #+END_SRC

 If one of the oveloads of a function has a ~reference qualifier~ all overloads must have a ~reference qualifier~:
#+BEGIN_SRC C++
   class C1
   {
   public:
       // This is invalid. If an overload has a reference qualifier all of the other overloads also have to have a reference qualifier.
       void func();
       void func() &;
   };
 #+END_SRC
 
*** Conversion constructor
 ~Conversion constructors~ can be used for ~implicit or explicit type conversion~. ~Non-class type expressions~ can be converted to a ~class type~ using ~conversion constructors~. This is how ~user-defined conversion~ is done in C++.

#+NAME: CONVERSION_CONSTRUCTOR_01
#+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
   class C1
   {
   public:
       C1()
       {
           std::cout << "C1 default constructor, this: " << this << '\n';
       }

       ~C1()
       {
           std::cout << "C1 destructor, this: " << this << '\n';
       }
       
       // This is a conversion constructor.
       C1(int)
       {
           std::cout << "C1(int) constructor, this: " << this << '\n';
       }

       C1& operator=(const C1& other)
       {
           std::cout << "C1 copy assignment, this: " << this << " other: " << &other << '\n';
           
           return *this;
       }
   };

   int main()
   {
       std::cout << "main() begins\n";
       {
           C1 c1;

           // Normally this is invalid but the conversion constructor makes it possible.
           c1 = 2; // First, C1(12) is called and a temporary object is created then the copy assignment operator of c1 is called with this temporary object. c1.operator=(C1(12));
           // c1 = C1(12); // Similar to this.

           std::cout << "main() continues\n";
       }
       std::cout << "main() ends";
   }
 #+END_SRC

Output:
 #+RESULTS: CONVERSION_CONSTRUCTOR_01
 #+begin_example
 main() begins
 C1 default constructor, this: 0x7ffc58b4051e
 C1(int) constructor, this: 0x7ffc58b4051f
 C1 copy assignment, this: 0x7ffc58b4051e other: 0x7ffc58b4051f
 C1 destructor, this: 0x7ffc58b4051f
 main() continues
 C1 destructor, this: 0x7ffc58b4051e
 main() ends
 #+end_example

 ~Conversion constructors~ should be used with caution because they will allow the compiler to do ~implicit type conversion~:
#+BEGIN_SRC C++
   class C1
   {
   public:
       C1();
       // This is a conversion constructor.
       C1(int);
   };

   void func(C1);
   void foo(const C1&);

   int main()
   {
       C1 m{};
       int n{};

       // For example, if we mistakenly type 'n' instead of 'm', both of these function calls will be still valid because the compiler will do implicit type conversion using the conversion constructor.
       func(n); 
       foo(n);
   }
 #+END_SRC

 The compiler can do ~implicit standard type conversion~ and ~implicit user-defined type conversion~ sequentially. These are both valid, meaning order does not matter:
  - ~implicit standard type conversion~ + ~implicit user-defined type conversion~.
  - ~implicit user-defined type conversion~ + ~implicit standard type conversion~.

 This makes ~conversion constructors~ a bit dangerous. Example for ~implicit standard type conversion~ + ~implicit user-defined type conversion~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1();
       // These are conversion constructors.
       C1(int);
       C1(bool);
   };

   int main()
   {
       C1 c1;
       double dval{};
       int ival;
       int* ptr = &ival;

       // These are also valid because implicit conversion from double to int and from bool to int is valid.
       // Implicit standard conversion from double to int
       // Imlicit user-defined conversion from int to C1
       // Similar to static_cast<C1>(static_cast<int>(dval));
       c1 = dval; 
       // Implicit standard conversion from bool to int
       // Imlicit user-defined conversion from int to C1
        // Similar to static_cast<C1>(static_cast<int>(10 > 5));
       c1 = 10 > 5;

       // This is very dangerous because implicit type conversion from pointer types to bool type exist. We can call C1(bool) conversion constructor with pointer types.
       // Implicit standard conversion from pointer types to bool
       // Imlicit user-defined conversion from bool to C1
        // Similar to static_cast<C1>(static_cast<bool>(ptr));
       c1 = ptr;
   }

 #+END_SRC

 The compiler won't do more than one ~user-defined conversion~ sequentially, meaning ~implicit user-defined type conversion~ + ~implicit user-defined type conversion~ is not allowed:
 #+BEGIN_SRC C++
   class C1
   {
   
   };

   class C2
   {
   public:
       // Conversion consructor for C1 to C2.
       // There is an implicit conversion from C1 to C2.
       C2(C1);
   };

   class C3
   {
   public:
       // Conversion consructor for C2 to C3.
       // There is an implicit conversion from C2 to C3.
       C3(C2);
   }

   int main()
   {
       C1 c1;
       // This is valid because there is an implicit conversion from C1 to C2 because of the conversion constructor. 
       C2 c2 = c1;
       // This is invalid the compiler won't to sequential user-defined conversions.
       // There is an implicit conversion from C1 to C2 and from C2 to C3 but the compiler will not allow multiple implicit user-defined conversions.
       C3 c3 = c1;
       // But it is possible explicitly.
       // Explicit type conversion from C1 to C2 and implicit type conversion from C2 to C3 is valid.
       C3 c3a = static_cast<C2>(c1);
   }

 #+END_SRC

*** Explicit constructor
 It is possible to prevent ~implicit user-defined conversion~ by declaring ~explicit constructor~. ~explicit~ keyword must be used in the ~declaration~ of the ~constructor~ not in the ~definition~.
 
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1();
       // This is an explicit conversion constructor.
       explicit C1(int);
   };

   void func(C1)
   {
       
   }

   C1 foo()
   {
       return 2;
   }

   int main()
   {
       // These are invalid now because C1(int) conversion constructor is an explicit constructor.
       // This would all be valid if C1(int) were not an explicit constructor.
       C1 c1;
       c1 = 3.5;
       c1 = 10 > 5;
       func(45);
       c1 = foo();
   }
 #+END_SRC

 ~explicit constructor~ also prevents ~copy initilization~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       C1();
       // This is an explicit conversion constructor.
       explicit C1(int);
   };

   int main()
   {
       // Actually, this is not a type conversion but explicit conversion also prevents copy initialization.
       // This is similar to c1(2) but it is invalid.
       C1 c1 = 2;
       // This is valid.
       C1 c1a(2);
   }
 #+END_SRC

 ~Explicit constructors~ are not seen by the compiler as ~viable functions~ in ~function overload resolution~:
 #+NAME: EXPLICIT_CONSTRUCTOR_01
 #+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
   class C1
   {
   public:
       // This is an explicit conversion constructor.
       explicit C1(int)
       {
           std::cout << "explicit C1(int)\n";
       }

       // This is an non-explicit conversion constructor.
       C1(double)
       {
           std::cout << "C1(double)\n";
       }
   };

   int main()
   {
       // It is normal to expect that this is a syntax error because C1(int) is explicit constructor but explicit constructor are not part of the function overload resolution so C1(double) is choosen by the compiler.
       C1 c1 = 2;
   }
 #+END_SRC

 Output:
 #+RESULTS: EXPLICIT_CONSTRUCTOR_01
 #+begin_example
 C1(double)
 #+end_example

 ~Explicit constructors~ only prevent ~implicit conversions~, we can still use ~explicit cast~:
 #+NAME: EXPLICIT_CONSTRUCTOR_02
 #+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
   class C1
   {
   public:
       // This is an explicit conversion constructor.
       explicit C1(int)
       {
           std::cout << "explicit C1(int)\n";
       }

       C1()
       {
           std::cout << "C1()\n";
       }
   };

   int main()
   {
       C1 c1;
       int x = 54;

       // This would be invalid without explicit type cast because C1(int) is explicit conversion constructor.
       c1 = static_cast<C1>(x);
   }
 #+END_SRC

 Output:
 #+RESULTS: EXPLICIT_CONSTRUCTOR_02

*** Copy elision
 ~Copy elision~ is an optimization performed by the compiler in certain cases where it can avoid creating a temporary copy of an object, even if the language's syntax suggests that a copy would be made. Instead of actually performing the copy, the compiler generates code that constructs or moves the object directly in its final destination. This optimization doesn't change the program's behavior or semantics. It simply avoids the overhead of unnecessary copying or moving. As of C++17, certain types of ~copy elision~ are guaranteed by the standard, such as in return value cases.

 If a ~copy elision~ is in the C++ standard:
  - It is mandatory, not compiler dependent.
  - The compiler doesn't need to throw any error if ~move/copy constructor~ of a class cannot be called in that context, for example if it is ~deleted~ or ~private~.
 If a ~copy elision~ is not in the C++ standard:
  - It is optional and compiler dependent.
  - The compiler has to throw a syntax error if ~move/copy constructor~ of a class cannot be called in that context, for example if it is ~deleted~ or ~private~.

 ~Copy elision~ on function arguments. This is mandatory ~copy elision~ as of C++17:
 #+NAME: COPY_ELLISION_01
 #+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
   class C1
   {
   public:
       C1()
       {
           std::cout << "C1 default constructor\n";
       }

       C1(const C1&)
       {
           std::cout << "C1 copy constructor\n";
       }
       
       ~C1()
       {
           std::cout << "C1 destructor\n";
       }
   };

   void func(C1)
   {
       
   }

   int main()
   {
       // Without copy elision:
       // Default constructor of temporary object C1{} will be called.
       // Copy constructor will be called for parameter of func(C1).
       // With copy elision:
       // Default constructor of temporary object C1{} will be directly called at the address of func(C1)'s parameter.
       // There won't be any copy constructor call.
       func(C1{});
   }
 #+END_SRC

 Output:
 #+RESULTS: COPY_ELLISION_01

If a ~copy elision~ is not part of the C++ standard (meaning, before C++17). The compiler has to throw a syntax error if ~copy constructor~ cannot be called in that context.
 #+NAME: COPY_ELLISION_02
 #+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
   class C1
   {
   public:
       C1()
       {
           std::cout << "C1 default constructor\n";
       }

       C1(const C1&) = delete;
       
       ~C1()
       {
           std::cout << "C1 destructor\n";
       }
   };

   void func(C1)
   {
       
   }

   int main()
   {
       // Before C++17:
       // It does not matter if the compiler decided to do copy elision or not. This will be syntax error because the copy constructor of C1 is deleted.
       // The compiler has to check if the copy constructor can be called, if not, throws a syntax error.
       // Reason behind this is there is no way to know if a compiler will choose to do copy elision or not. Some of them can choose to do copy elision some of them not. Because of that, it is not guaranteed that the copy constrcutor will never be called.
       // As of C++17:
       // This copy elision type is in standard and it means mandatory for compiler to do.
       // This guarantees that all of the compilers will perform copy elision and the copy constructor will never be called.
       // Because of this there is no need to check for the compiler if copy constructor can be called or not.
       func(C1{}); // As of C++17, this is valid.
   }
 #+END_SRC

 Output:
 #+RESULTS: COPY_ELLISION_02

~Copy elision~ if a function returns a ~temporary object~. This ~copy elision~ is called ~return value optimization~ or shortly ~RVO~:
 #+NAME: COPY_ELLISION_03
 #+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
   class C1
   {
   public:
       C1()
       {
           std::cout << "C1 default constructor\n";
       }

       C1(const C1&)
       {
           std::cout << "C1 copy constructor\n";
       }
       
       ~C1()
       {
           std::cout << "C1 destructor\n";
       }
   };

   C1 func(void)
   {
       return C1{};
   }

   int main()
   {
       // Without copy elision:
       // Default constructor of temporary object C1{} inside func() will be called.
       // Copy constructor will be called for the return value of func().
       // Copy constructor of c1 will be called with the return value of func().
       // With copy elision:
       // Default constructor of temporary object C1{} will be directly called at the address of c1.
       // There won't be any copy constructor call.
       C1 c1 = func();
   }
 #+END_SRC

 Output:
 #+RESULTS: COPY_ELLISION_03

~Copy elision~ if a function returns a ~local object~. This ~copy elision~ is called ~named return value optimization~ or shortly ~NRVO~. This is not mandatory ~copy elision~, meaning not part of the language standard:
 #+NAME: COPY_ELLISION_04
 #+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
   class C1
   {
   public:
       C1()
       {
           std::cout << "C1 default constructor\n";
       }

       C1(const C1&)
       {
           std::cout << "C1 copy constructor\n";
       }
       
       ~C1()
       {
           std::cout << "C1 destructor\n";
       }
   };

   C1 func(void)
   {
       C1 c1;

       // Codes for setting and changing c etc.

       return c1;
   }

   int main()
   {
       // Without copy elision:
       // Default constructor of local object c1 inside func() will be called.
       // Copy constructor will be called for the return value of func().
       // Copy constructor of c1 will be called with the return value of func().
       // With copy elision:
       // Default constructor of local object c1 will be directly called at the address of c1 in the main.
       // There won't be any copy constructor call.
       C1 c1 = func();
   }
 #+END_SRC

 Output:
 #+RESULTS: COPY_ELLISION_04

*** Static data members
 ~Static data members~ in C++ are members of a class that are ~shared by all objects~ of that class. They belong to the class itself, rather than to any specific object (unlike ~non-static data members~), and have the same value for all instances of the class. ~Static data members~ have ~static lifetime~. They are created before the ~main function~ starts and live until the end of program. ~Static data members~ can also be ~inlined~ (~inline variables~ in C++17).

 #+BEGIN_SRC C++
   class C1
   {
   public:
       static int i; // There will be only one i shared by all of the objects. This is also called class variable.
       int a, b, c; // Each object of C1 will have it is own a, b and c because they are non-static data members.
   };
 #+END_SRC

 ~Static data members~ can be qualified with a class name to access them outside of class:
 #+BEGIN_SRC C++ 
   class C1
   {
   public:
       static int x;
   };

   int main()
   {
       C1::x;
   }
 #+END_SRC

 ~Static data members~ can be also accessed from instances of class by using ~dot and arrow operarators~.
 #+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
   class C1
   {
   public:
       static int x;
   };

   int main()
   {
       C1 a;
       C1 b;
       C1* c = &b;

       std::cout << "C1::x" << C1::x << '\n';

       // This can be dangerous because the static data member name can be
       // mistakenly written instead of the non-static data member name,
       // which will not cause any syntax errors unless there is a type mismatch, etc.
       a.x = 1;
       std::cout << "C1::x" << C1::x << '\n';
       b.x = 2;
       std::cout << "C1::x" << C1::x << '\n';
       c->x = 3;
       std::cout << "C1::x" << C1::x << '\n';
   }
 #+END_SRC

 The ~access control~ rules also apply to ~static data members~:
 #+BEGIN_SRC C++
   class C1
   {
       static int x;
   };

   int main()
   {
       // This is invalid. Cannot access private member.
       C1::x = 10;
   }
 #+END_SRC

 ~Declaration~ of ~static data members~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // This is just a declaration not a definition.
       // The compiler will not give any storage space for x because it doesn't have definition.
       static int x;
   };

   int main()
   {
       // This would compile but cannot be linked. C1::x doesn't have any definition but declaration. 
       C1::x = 5;
   }
 #+END_SRC

 ~Definition~ of ~static data members~:
 #+BEGIN_SRC C++
   // c1.h
   class C1
   {
   public:
       // This is just a declaration not a definition.
       // The compiler will not give any storage space for x because it doesn't have definition.
       static int x;
   };

   // c1.c
   int C1::x; // This is tne definition of C1::x. Note that static keyword is not used in the definition.

   // main.cpp
   // #include c1.h
   int main()
   {
       // This would compile and link. C1::x has a declaration and definition.
       C1::x = 5;
   }
 #+END_SRC

 A ~static data member~ which is ~declared~ in ~class definition~ can be an ~incomplete type~:
 #+BEGIN_SRC C++
   class C2; // Forward declaration.

   class C1
   {
   private:
       // C2 is incomplete type but this declaration is valid because there is no storage space required at this point.
       // The compiler will know necessary storage space when it finds the definition of C2 in other source files.
       static C2 c2;
   };
 #+END_SRC

The ~static data members~ which are ~const~ and ~integral type~ can be ~defined~ in ~class definition~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // This is a declaration and a definition for x. 
       static const int x = 10; // This is valid definition, x is const and has integral type(int).
       // static const double y = 5.5; // This is invalid, y is const but double is real number type not integral type.
   };

   int main()
   {
       // This is valid.
       C1::x;
   }

 #+END_SRC

As of C++17, ~static data members~ can also be ~inlined~ (~inline variables~):
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // This is a declaration and a definition for x. 
       static inline double x = 5.5; 
   };

   int main()
   {
       // This is valid.
       C1::x = 10.10;
   }
 #+END_SRC

 ~Constructor initializer list~ cannot be used for ~static data members~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // This is a syntax error. mz is static data member 
       // and cannot be initialized in constructor initializer list.
       // Static data members are already initialized before main function is being called.
       C1() : mx(10), my(20), mz(30) {}
   private:
       int mx, int my;
       static int mz;
   };
 #+END_SRC

 ~Static data members~ can also be accessed by ~this pointer~:
 #+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
   class C1
   {
   public:
       void func(int a)
       {
           // These are same.
           this->x = a;
           x = a;
           C1::x = a;
       }
   private:
       static int x;
   };

   int main()
   {
       C1 c1a, c1b, c1c;

       c1a.func(10);
       std::cout << "C1::x: " << C1::x << '\n'
       c1b.func(20);
       std::cout << "C1::x: " << C1::x << '\n'
       c1c.func(30);
       std::cout << "C1::x: " << C1::x << '\n'
   }
 #+END_SRC

 As an example, a ~static data member~ can be used for a lookup table:
 #+BEGIN_SRC C++
   class Date
   {
   private:
       // Names of the week days are not specific to any instance of Date class.
       // Names can be stored in a static data member and can be accessed by instances when required.
       static constexpr const char* week_days[] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
   };
 #+END_SRC
 
 ~Non-static const member functions~ can mutate ~static data members~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       void func() const
       {
           // Valid. Const member function means this pointer is const
           // but mx is static data member and doesn't have any relation with this pointer.
           mx = 5; // Equals to C1::mx = 5;
           // Invalid. This pointer is const.
           my = 5; // Equals to this->my = 5;
       }
       
   private:
       static int mx;
       int my;
   };
 #+END_SRC

*** Static member functions
~Static member functions~ in C++ are functions that belong to a class rather than to any specific object of the class. They can be called without creating an instance of the class and have access only to the static members of the class. ~Static member functions~ don't have ~this pointer~.

 #+BEGIN_SRC C++
   class C1
   {
   public:
       void f1(); // Non-static member function.
       static void f2(); // Static member function.
   };

   int main()
   {
       // This is invalid. f1() is a non-static member function and can only be called with an instance.
       C1::f1();
       // This is valid. f2() is a static member function and doesn't belong to any specific object.
       C1::f2();
   }
 #+END_SRC

 ~Static member functions~ doesn't have ~this pointer~ but this doesn't mean they cannot access ~private members~ of the class:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       static void func();
       
   private:
       int mx;
   };

   C1::func()
   {
       C1 c1{};

       // mx is private member of C1 and can be accessed inside static member functions.
       // Accessing private members and not having this pointer are different concepts.
       auto int a = c1.mx;
   }
 #+END_SRC

The ~access control~ rules also apply to ~static member functions~:
 #+BEGIN_SRC C++
   class C1
   {
   private:
       static void func();
       int mx;
   };

   C1::func()
   {
       C1 c1{};

       // mx is private member of C1 and can be accessed inside static member functions.
       // Accessing private members and not having this pointer are different concepts.
       auto int a = c1.mx;
   }

   int main()
   {
       // This is invalid. C1::func() is private and cannot be accessed outside of the class.
       C1::func();
   }
 #+END_SRC

 ~Static member functions~ can be ~defined~ in ~class definition~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       // This is a declaration and a definition. Implicitly inline.
       static void func()
       {
           
       }
   };
 #+END_SRC
 
 ~Declaration~ and ~definition~ can also be separated:
 #+BEGIN_SRC C++
   // c1.h
   class C1
   {
   public:
       // This is a declaration.
       static void func();
   };

   // c1.cpp
   void C1::func
   {
       
   }
 #+END_SRC

 ~Static member functions~ cannot be ~const~ because there is no ~this pointer~ to make ~const~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       static void func() const; // This is invalid.
   };
 #+END_SRC

~Static member functions~ can use ~static data members~ with ~unqualied name~:
 #+BEGIN_SRC C++
   class C1
   {
   public:
       static void func()
       {
           // Valid.
           mx = 10;
       }

   private:
       static int mx;
   };
 #+END_SRC

 ~Static member functions~ can also be called from instances of class by using ~dot and arrow operarators~.
#+BEGIN_SRC C++
   class C1
   {
   public:
       static void func();
   };

   int main()
   {
       C1 c1a, c1b;

       // These are valid. func() is static member function and doesn't belong to any specific instance but still can be called with this syntax.
       // Equals to C1::func();
       c1a.func();
       c1b.func();
   }
 #+END_SRC

 There is no type difference between pointers to ~global functions~ and pointers to ~static member functions~:
#+BEGIN_SRC C++
  class C1
  {
  public:
      static int f1(int);
  };

  static int f2(int);

  int main()
  {
      // fp1 and fp2 are function pointers with same type and can store address of C1::f1() and f2().
      int (*fp1)(int) = &C1::f1;
      int (*fp2)(int) = &f2;
  }
#+END_SRC

 An ~identifier~ used to initialize a ~static data member~ is first searched in ~class scope~, if it is not found it is searched in ~namespace scope~:
#+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
  class C1
  {
  public:
      static int func()
      {
          return 777;
      }

      static int x;
  };

  int func()
  {
      return 5;
  }

  // Valid. func() will be first searched in class scope.
  int C1::x = func();

  int main()
  {
      // Prints 777.
      std::cout << "C1::x: " << C1::x << '\n';
  }
#+END_SRC

 A simple example using ~static member function~ and ~static data member~ to keep track of how many instances of a class are created:
#+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
  class C1
  {
  public:
      C1()
      {
          ++live_count;
      }

      C1(int)
      {
          ++live_count;
      }

      ~C1()
      {
          --live_count;
      }

      // Delete copy constructor and copy operator.
      C1(const C1&) = delete;
      C1& operator=(const C1&) = delete;

      static int get_live_count()
      {
          return live_count;
      }

  private:
      static inline int live_count;
  };

  int main()
  {
      C1 c1a, c1b, c1c;
      auto p1 = new C1{ 3 };
      auto p2 = new C1{ 5 };

      std::cout << "C1::get_live_count: " << C1::get_live_count() << '\n';

      delete p1;

      std::cout << "C1::get_live_count: " << C1::get_live_count() << '\n';
      
  }
#+END_SRC

 ~Named constructor idiom~ example using ~static member function~:
#+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
  class C1
  {
  public:
      static C1* create_object()
      {
          return new C1;
      }

      void func();
    
  private:
      // Client codes cannot local class instances by calling constructor.
      C1(); // Private default constructor.
  };

  int main()
  {
      auto c1a = C1::create_object();
      c1a->func();
  }
#+END_SRC

#+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
  class Complex
  {
  public:
      static Complex create_cartesian(double r, double i)
      {
          return C1(r, i);
      }

      static Complex create_polar(double angle, double distance)
      {
          return C1(angle, distance, 0);
      }

  private:
      Complex(double r, double i); // Cartesian.
      Complex(double angle, double distance, int); // Polar.
  };

  int main()
  {
      auto complex_cartesian = Complex::create_cartesian(2.3, 5.6);
      auto complex_polar = Complex::create_polar(2.3, 0.5);
  }
#+END_SRC

 Classic ~singleton~ example:
#+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
  class C1
  {
  public:
      static C1* get_instance()
      {
          if (!m_instance)
          {
              m_instance = new C1;
          }

          return m_instance;
      }
      
      static void f1();
      static void f2();
  private:
      C1(); // Private default constructor.
      inline static C1* m_instance;
  };

  int main()
  {
      C1* c1a = C1::get_instance();

      c1a->f1();
      C1::get_instance()->f2();
  }
#+END_SRC

 Meyer's ~singleton~ example:
#+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
  class C1
  {
  public:
      static C1& get_instance()
      {
          static C1 c;

          return c;
      }
      
      static void f1();
      static void f2();
  private:
      C1(); // Private default constructor.
  };

  int main()
  {
      C1& c1a = C1::get_instance();

      c1a.f1();
      C1::get_instance().f2();
  }
#+END_SRC

*** Friend declarations
 In C++, ~friend declarations~ allow a function or a class to access the ~private~ and ~protected~ members of another class. This is useful when you want an external function or another class to have ~privileged access~ to certain parts of a class that would otherwise be inaccessible. ~Friend declarations~ in C++ grant other functions or classes ~full access to all private and protected members of a class~. It is not possible to restrict this access to specific members without employing special design patterns or idioms. Once a function or class is declared as a ~friend~, it has ~unrestricted access~ to the class's ~private~ and ~protected~ members.

#+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
  class C1
  {
  public:
      friend void f1(C1);

      // It is also possible to define friend functions inlined.
      // This is not a member function of C1. This is called hidden friend.
      friend void f2(C1 c1)
      {
          c1.f3();
      }

  private:
      void f3();
      int mx;
  };

  // Friend function
  void f1(C1 c1)
  {
      C1 c1a;
      // Friend declaration make it possible to reach private members of class.
      c1a.f3();
      c1a.mx = 3;
      c1.f3();
  }
#+END_SRC

~Friend declarations~ can be in the ~private~, ~protected~ or ~public~ section of the class. It does not make any difference:
#+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
  class C1
  {
  private:
      friend void f1(C1);
      void f2();
      int mx;
  };

  // Friend function
  void f1(C1 c1)
  {
      C1 c1a;
      // Friend declaration make it possible to reach private members of class.
      c1a.f2();
      c1a.mx = 3;
      c1.f2();
  }
#+END_SRC

~Friend declaration~ can be made for a specific function of an another class:
#+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
  class C2
  {
      void f1();
  };

  class C1
  {
  private:
      // To define C2::f1() function as a friend, the class definition of C2 has to be visible here.
      friend void C2::f1();
      void f2();
  };

  void C2::f1()
  {
      C1 c;
      c.f2();
  }
#+END_SRC

~Friend declarations~ can be made for an another class:
#+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
  class C1
  {
  private:
      // Friend class can be incomplete type.
      friend class C2;
      
      void f1();
      void f2();
  };

  class C2
  {
      void f3()
      {
          C1 c1;
          c1.f1();
          c1.f2();
      }

      void f4()
      {
          C1 c1;
          c1.f1();
          c1.f2();
      }
  };
#+END_SRC

~Friend declarations~ are one-way:
#+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
  class C1
  {
  private:
      // Friend class can be incomplete type.
      friend class C2;
      
      void f1();
      void f2();
      
      void f3()
      {
          C2 c2;

          // This is invalid. Members of C2 can reach the private/protected members of C1 but C1 cannot access C2's.
          c2.f4();
      }
  };

  class C2
  {
  private:
      void f4()
      {
          C1 c1;
          c1.f1();
          c1.f2();
      }

      void f5()
      {
          C1 c1;
          c1.f1();
          c1.f2();
      }
  };
#+END_SRC

~Friend declarations~ do not chain:
#+BEGIN_SRC C++ :includes iostream :results output :exports both :wrap example
  class C1
  {
  private:
      void f1();
      friend class C2;
  };

  class C2
  {
  private:
      void f2()
      {
          C1 c1;
          c1.f1();
      }
      
      friend class C3;
  };

  class C3
  {
  private:
      void f3()
      {
          C2 c2;
          
          c2.f2();

          C1 c1;
          // C3 is friend of C2, C2 is friend of C1. But, this does not make C3 and C1 friends.
          c1.f1(); // This is invalid. Friend of my friend is not my friend.
      }
  };
#+END_SRC

cpp015 - 00:00:00


